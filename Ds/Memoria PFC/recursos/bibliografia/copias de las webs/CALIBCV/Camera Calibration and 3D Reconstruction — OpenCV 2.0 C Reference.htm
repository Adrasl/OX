<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0090)http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    
    <title>Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference</title>
    <link rel="stylesheet" href="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/default.css" type="text/css">
    <link rel="stylesheet" href="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/pygments.css" type="text/css">
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '#',
        VERSION:     '2.0+ SVN',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/jquery.js"></script>
    <script type="text/javascript" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/doctools.js"></script>
    <link rel="top" title="OpenCV 2.0 C Reference" href="http://opencv.willowgarage.com/documentation/index.html">
    <link rel="up" title="cv. Image Processing and Computer Vision" href="http://opencv.willowgarage.com/documentation/cv._image_processing_and_computer_vision.html">
    <link rel="next" title="highgui. High-level GUI and Media IO" href="http://opencv.willowgarage.com/documentation/highgui._high-level_gui_and_media_io.html">
    <link rel="prev" title="Object Detection" href="http://opencv.willowgarage.com/documentation/object_detection.html"> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="http://opencv.willowgarage.com/documentation/genindex.html" title="General Index" accesskey="I">index</a></li>
        <li class="right">
          <a href="http://opencv.willowgarage.com/documentation/highgui._high-level_gui_and_media_io.html" title="highgui. High-level GUI and Media IO" accesskey="N">next</a> |</li>
        <li class="right">
          <a href="http://opencv.willowgarage.com/documentation/object_detection.html" title="Object Detection" accesskey="P">previous</a> |</li>
        <li><a href="http://opencv.willowgarage.com/documentation/index.html">OpenCV 2.0 C Reference</a> »</li>
          <li><a href="http://opencv.willowgarage.com/documentation/cv._image_processing_and_computer_vision.html" accesskey="U">cv. Image Processing and Computer Vision</a> »</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="camera-calibration-and-3d-reconstruction">
<h1>Camera Calibration and 3D Reconstruction<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#camera-calibration-and-3d-reconstruction" title="Permalink to this headline">¶</a></h1>
<blockquote>
<p>The functions in this section use the so-called pinhole camera model. That is, a scene view is formed by projecting 3D points into the image plane using a perspective transformation.</p>
<div class="math">
<p><img src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/e54b10af8f47105041076c6163d6fce959f68322.png" alt="s \; m&#39; = A [R|t] M&#39;"></p>
</div><p>or</p>
<div class="math">
<p><img src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/cb5a3ce58906fe9ea1b7c833f7335005e6b5dce2.png" alt="s \vecthree {u}{v}{1} = \vecthreethree {f_ x}{0}{c_ x} {0}{f_ y}{c_ y} {0}{0}{1} \begin{bmatrix} r_{11} &amp; r_{12} &amp; r_{13} &amp; t_1 \\ r_{21} &amp; r_{22} &amp; r_{23} &amp; t_2 \\ r_{31} &amp; r_{32} &amp; r_{33} &amp; t_3 \end{bmatrix} \begin{bmatrix} X \\ Y \\ Z \\ 1 \end{bmatrix}"></p>
</div><p>Where <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/3b6afcdae3238d0889eb2b9361faa2ed159ff097.png" alt="$(X, Y, Z)$"> are the coordinates of a 3D point in the world coordinate space, <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/8f68f58d002a7a00d3685300b8e32abd88a181f8.png" alt="$(u, v)$"> are the coordinates of the projection point in pixels. <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/9459d05be4627a2a60d078431c6fb93491c59be4.png" alt="$A$"> is called a camera matrix, or a matrix of intrinsic parameters. <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/9120da031ad1ae3a893936f6edb704f4eb2ef7b1.png" alt="$(cx, cy)$"> is a principal point (that is usually at the image center), and <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/9749f795b834d2d43b159646710de312cfbaa1e7.png" alt="$fx, fy$"> are the focal lengths expressed in pixel-related units. Thus, if an image from camera is scaled by some factor, all of these parameters should be scaled (multiplied/divided, respectively) by the same factor. The matrix of intrinsic parameters does not depend on the scene viewed and, once estimated, can be re-used (as long as the focal length is fixed (in case of zoom lens)). The joint rotation-translation matrix <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/1a316a4d6f04da7f22aaccd7d72b5e9767403257.png" alt="$[R|t]$"> is called a matrix of extrinsic parameters. It is used to describe the camera motion around a static scene, or vice versa, rigid motion of an object in front of still camera. That is, <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/1a316a4d6f04da7f22aaccd7d72b5e9767403257.png" alt="$[R|t]$"> translates coordinates of a point <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/3b6afcdae3238d0889eb2b9361faa2ed159ff097.png" alt="$(X, Y, Z)$"> to some coordinate system, fixed with respect to the camera. The transformation above is equivalent to the following (when <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/9608fdfb1eeacf85b555b325cfd997c06c076426.png" alt="$z \ne 0$">):</p>
<div class="math">
<p><img src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/e44bb181af1428f13429a181d89ae68ecc473932.png" alt="\begin{array}{l} \vecthree {x}{y}{z} = R \vecthree {X}{Y}{Z} + t\\ x&#39; = x/z\\ y&#39; = y/z\\ u = f_ x*x&#39; + c_ x\\ v = f_ y*y&#39; + c_ y \end{array}"></p>
</div><p>Real lenses usually have some distortion, mostly radial distorion and slight tangential distortion. So, the above model is extended as:</p>
<div class="math">
<p><img src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/a097625553f45b06a4c7a024456ee1ac1da3c8af.png" alt="\begin{array}{l} \vecthree {x}{y}{z} = R \vecthree {X}{Y}{Z} + t\\ x&#39; = x/z\\ y&#39; = y/z\\ x” = x&#39; (1 + k_1 r^2 + k_2 r^4 + k_3 r^6) + 2 p_1 x&#39; y&#39; + p_2(r^2 + 2 x&#39;^2) \\ y” = y&#39; (1 + k_1 r^2 + k_2 r^4 + k_3 r^6) + p_1 (r^2 + 2 y&#39;^2) + 2 p_2 x&#39; y&#39; \\ \text {where} \quad r^2 = x&#39;^2 + y&#39;^2 \\ u = f_ x*x” + c_ x\\ v = f_ y*y” + c_ y \end{array}"></p>
</div><p><img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/4ee904d7ed89cc12f14885d61cf91bd64a0925f3.png" alt="$k_1$">, <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/88eb4ba5e122a9ae80e2dd792f21ee6adbdc8ae4.png" alt="$k_2$">, <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/bfc5cd485077c0f18964d86e652cb4810c24dbc1.png" alt="$k_3$"> are radial distortion coefficients, <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/9d5027ac1fbb484b97d4d8d6dd0f0dff79fc835f.png" alt="$p_1$">, <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/6d574568509c7384bbf9859862d56b092b17b99d.png" alt="$p_2$"> are tangential distortion coefficients. Higher-order coefficients are not considered in OpenCV. In the functions below the coefficients are passed or returned as</p>
<div class="math">
<p><img src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/4972eec50bbe577c72b5d258e682495024072d5f.png" alt="(k_1, k_2, p_1, p_2[, k_3])"></p>
</div><p>vector. That is, if the vector contains 4 elements, it means that <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/faea21c8bd3315b06321c934d3bdf4c799e57f73.png" alt="$k_3=0$">. The distortion coefficients do not depend on the scene viewed, thus they also belong to the intrinsic camera parameters. And they remain the same regardless of the captured image resolution. That is, if, for example, a camera has been calibrated on images of <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/4f1accd262cec7100db616af9669df0913d0bc21.png" alt="$320 \times 240$"> resolution, absolutely the same distortion coefficients can be used for images of <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/868a631add5b6fda29069bab7271657c02cd83a1.png" alt="$640 \times 480$"> resolution from the same camera (while <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/25e0fa5e0f8c5864c5290b69edf98930e055f7ce.png" alt="$f_ x$">, <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/4dee68490e30bbe4f59304315b89b72ea620f5e2.png" alt="$f_ y$">, <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/99c2aa6416f63028f52f45159e5e98d3307bcb81.png" alt="$c_ x$"> and <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/560bb0834286987772bb503a76edca7c4074498f.png" alt="$c_ y$"> need to be scaled appropriately).</p>
<p>The functions below use the above model to</p>
<ul class="simple">
<li>Project 3D points to the image plane given intrinsic and extrinsic parameters</li>
<li>Compute extrinsic parameters given intrinsic parameters, a few 3D points and their projections.</li>
<li>Estimate intrinsic and extrinsic camera parameters from several views of a known calibration pattern (i.e. every view is described by several 3D-2D point correspodences).</li>
<li>Estimate the relative position and orientation of the stereo camera “heads” and compute the rectification transformation that makes the camera optical axes parallel.</li>
</ul>
</blockquote>
<div class="section" id="calcimagehomography">
<span id="index-12"></span><span id="id1"></span><h2>CalcImageHomography<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#calcimagehomography" title="Permalink to this headline">¶</a></h2>
<dl class="cfunction">
<dt id="cvCalcImageHomography">
void <tt class="descname">cvCalcImageHomography</tt><big>(</big>float*<em> line</em>, CvPoint3D32f*<em> center</em>, float*<em> intrinsic</em>, float*<em> homography</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvCalcImageHomography" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the homography matrix for an oblong planar object (e.g. arm).</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>line</em> – the main object axis direction (vector (dx,dy,dz))</li>
<li><em>center</em> – object center ((cx,cy,cz))</li>
<li><em>intrinsic</em> – intrinsic camera parameters (3x3 matrix)</li>
<li><em>homography</em> – output homography matrix (3x3)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The function calculates the homography matrix for the initial image transformation from image plane to the plane, defined by a 3D oblong object line (See __Figure <a href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#id37"><span class="problematic" id="id38">6-10__</span></a> in the OpenCV Guide 3D Reconstruction Chapter).</p>
</dd></dl>

</div>
<div class="section" id="calibratecamera2">
<span id="index-13"></span><span id="id2"></span><h2>CalibrateCamera2<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#calibratecamera2" title="Permalink to this headline">¶</a></h2>
<p>bgroup({calibrateCamera})</p>
<dl class="cfunction">
<dt id="cvCalibrateCamera2">
double <tt class="descname">cvCalibrateCamera2</tt><big>(</big>const CvMat*<em> objectPoints</em>, const CvMat*<em> imagePoints</em>, const CvMat*<em> pointCounts</em>, CvSize<em> imageSize</em>, CvMat*<em> cameraMatrix</em>, CvMat*<em> distCoeffs</em>, CvMat*<em> rvecs=NULL</em>, CvMat*<em> tvecs=NULL</em>, int<em> flags=0</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvCalibrateCamera2" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the camera intrinsic and extrinsic parameters from several views of a calibration pattern.</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>objectPoints</em> – The joint matrix of object points - calibration pattern features in the model coordinate space. It is floating-point 3xN or Nx3 1-channel, or 1xN or Nx1 3-channel array, where N is the total number of points in all views.</li>
<li><em>imagePoints</em> – The joint matrix of object points projections in the camera views. It is floating-point 2xN or Nx2 1-channel, or 1xN or Nx1 2-channel array, where N is the total number of points in all views</li>
<li><em>pointCounts</em> – Integer 1xM or Mx1 vector (where M is the number of calibration pattern views) containing the number of points in each particular view. The sum of vector elements must match the size of <tt class="docutils literal"><span class="pre">objectPoints</span></tt> and <tt class="docutils literal"><span class="pre">imagePoints</span></tt> (=N).</li>
<li><em>imageSize</em> – Size of the image, used only to initialize the intrinsic camera matrix</li>
<li><em>cameraMatrix</em> – The output 3x3 floating-point camera matrix <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/3d94efa81b9b7efbd5d534238b09f48049547fca.png" alt="$A = \vecthreethree {f_ x}{0}{c_ x}{0}{f_ y}{c_ y}{0}{0}{1}$">.If <tt class="xref docutils literal"><span class="pre">CV_CALIB_USE_INTRINSIC_GUESS</span></tt> and/or <tt class="xref docutils literal"><span class="pre">CV_CALIB_FIX_ASPECT_RATIO</span></tt> are specified, some or all of <tt class="docutils literal"><span class="pre">fx,</span> <span class="pre">fy,</span> <span class="pre">cx,</span> <span class="pre">cy</span></tt> must be initialized before calling the function</li>
<li><em>distCoeffs</em> – The output 4x1, 1x4, 5x1 or 1x5 vector of distortion coefficients <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/796eb1a636b634304dad7fa020666f8bb64ff406.png" alt="$(k_1, k_2, p_1, p_2[, k_3])$">.</li>
<li><em>rvecs</em> – The output 3xM or Mx3 1-channel, or 1xM or Mx1 3-channel array of rotation vectors (see <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#rodrigues2"><em>Rodrigues2</em></a>), estimated for each pattern view. That is, each k-th rotation vector together with the corresponding k-th translation vector (see the next output parameter description) brings the calibration pattern from the model coordinate space (in which object points are specified) to the world coordinate space, i.e. real position of the calibration pattern in the k-th pattern view (k=0..M-1)</li>
<li><em>tvecs</em> – The output 3xM or Mx3 1-channel, or 1xM or Mx1 3-channel array of translation vectors, estimated for each pattern view.</li>
<li><em>flags</em> – <p>Different flags, may be 0 or combination of the following values:</p>
<ul>
<li><strong>CV_CALIB_USE_INTRINSIC_GUESS</strong> - <tt class="docutils literal"><span class="pre">cameraMatrix</span></tt> contains the valid initial values of <tt class="docutils literal"><span class="pre">fx,</span> <span class="pre">fy,</span> <span class="pre">cx,</span> <span class="pre">cy</span></tt> that are optimized further. Otherwise, <tt class="docutils literal"><span class="pre">(cx,</span> <span class="pre">cy)</span></tt> is initially set to the image center (<tt class="docutils literal"><span class="pre">imageSize</span></tt> is used here), and focal distances are computed in some least-squares fashion. Note, that if intrinsic parameters are known, there is no need to use this function just to estimate the extrinsic parameters. Use <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#findextrinsiccameraparams2"><em>FindExtrinsicCameraParams2</em></a> instead.</li>
<li><strong>CV_CALIB_FIX_PRINCIPAL_POINT</strong> - The principal point is not changed during the global optimization, it stays at the center or at the other location specified when <tt class="xref docutils literal"><span class="pre">CV_CALIB_USE_INTRINSIC_GUESS</span></tt> is set too.</li>
<li><strong>CV_CALIB_FIX_ASPECT_RATIO</strong> - The functions considers only <tt class="docutils literal"><span class="pre">fy</span></tt> as a free parameter, the ratio <tt class="docutils literal"><span class="pre">fx/fy</span></tt> stays the same as in the input <tt class="docutils literal"><span class="pre">cameraMatrix</span></tt>. When <tt class="xref docutils literal"><span class="pre">CV_CALIB_USE_INTRINSIC_GUESS</span></tt> is not set, the actual input values of <tt class="docutils literal"><span class="pre">fx</span></tt> and <tt class="docutils literal"><span class="pre">fy</span></tt> are ignored, only their ratio is computed and used further.</li>
<li><strong>CV_CALIB_ZERO_TANGENT_DIST</strong> - Tangential distortion coefficients <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/5fc5aee779977a712898a359f972ae3cef2085a0.png" alt="$(p_1, p_2)$"> will be set to zeros and stay zero.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The function estimates the intrinsic camera parameters and extrinsic parameters for each of the views. The coordinates of 3D object points and their correspondent 2D projections in each view must be specified. That may be achieved by using an object with known geometry and easily detectable feature points. Such an object is called a calibration rig or calibration pattern, and OpenCV has built-in support for a chessboard as a calibration rig (see <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#findchessboardcorners"><em>FindChessboardCorners</em></a>). Currently, initialization of intrinsic parameters (when <tt class="xref docutils literal"><span class="pre">CV_CALIB_USE_INTRINSIC_GUESS</span></tt> is not set) is only implemented for planar calibration patterns (where z-coordinates of the object points must be all 0’s). 3D calibration rigs can also be used as long as initial <tt class="docutils literal"><span class="pre">cameraMatrix</span></tt> is provided.</p>
<p>The algorithm does the following:</p>
<ul class="simple">
<li>First, it computes the initial intrinsic parameters (the option only available for planar calibration patterns) or reads them from the input parameters. The distortion coefficients are all set to zeros initially (unless some of <tt class="xref docutils literal"><span class="pre">CV_CALIB_FIX_K?</span></tt> are specified).</li>
<li>The the initial camera pose is estimated as if the intrinsic parameters have been already known. This is done using <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#findextrinsiccameraparams2"><em>FindExtrinsicCameraParams2</em></a></li>
<li>After that the global Levenberg-Marquardt optimization algorithm is run to minimize the reprojection error, i.e. the total sum of squared distances between the observed feature points <tt class="docutils literal"><span class="pre">imagePoints</span></tt> and the projected (using the current estimates for camera parameters and the poses) object points <tt class="docutils literal"><span class="pre">objectPoints</span></tt>; see <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#projectpoints2"><em>ProjectPoints2</em></a>.</li>
</ul>
<p>The function returns the final re-projection error.</p>
<p>Note: if you’re using a non-square (=non-NxN) grid and <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#findchessboardcorners"><em>FindChessboardCorners</em></a> for calibration, and <tt class="docutils literal"><span class="pre">calibrateCamera</span></tt> returns bad values (i.e. zero distortion coefficients, an image center very far from <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/ba4c3597ef931e81eb02082e42555ad6cd243f9f.png" alt="$(w/2-0.5,h/2-0.5)$">, and / or large differences between <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/25e0fa5e0f8c5864c5290b69edf98930e055f7ce.png" alt="$f_ x$"> and <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/4dee68490e30bbe4f59304315b89b72ea620f5e2.png" alt="$f_ y$"> (ratios of 10:1 or more)), then you’ve probaby used <tt class="docutils literal"><span class="pre">patternSize=cvSize(rows,cols)</span></tt>, but should use <tt class="docutils literal"><span class="pre">patternSize=cvSize(cols,rows)</span></tt> in <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#findchessboardcorners"><em>FindChessboardCorners</em></a>.</p>
<p>See also: <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#findchessboardcorners"><em>FindChessboardCorners</em></a>, <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#findextrinsiccameraparams2"><em>FindExtrinsicCameraParams2</em></a>, <em class="xref">initCameraMatrix2D</em>, <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#stereocalibrate"><em>StereoCalibrate</em></a>, <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#undistort2"><em>Undistort2</em></a></p>
</dd></dl>

</div>
<div class="section" id="computecorrespondepilines">
<span id="index-14"></span><span id="id3"></span><h2>ComputeCorrespondEpilines<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#computecorrespondepilines" title="Permalink to this headline">¶</a></h2>
<p>bgroup({computeCorrespondEpilines})</p>
<dl class="cfunction">
<dt id="cvComputeCorrespondEpilines">
void <tt class="descname">cvComputeCorrespondEpilines</tt><big>(</big>const CvMat*<em> points</em>, int<em> whichImage</em>, const CvMat*<em> F</em>, CvMat*<em> lines</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvComputeCorrespondEpilines" title="Permalink to this definition">¶</a></dt>
<dd><p>For points in one image of a stereo pair, computes the corresponding epilines in the other image.</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>points</em> – The input points. <tt class="docutils literal"><span class="pre">2xN,</span> <span class="pre">Nx2,</span> <span class="pre">3xN</span></tt> or <tt class="docutils literal"><span class="pre">Nx3</span></tt> array (where <tt class="docutils literal"><span class="pre">N</span></tt> number of points). Multi-channel <tt class="docutils literal"><span class="pre">1xN</span></tt> or <tt class="docutils literal"><span class="pre">Nx1</span></tt> array is also acceptable</li>
<li><em>whichImage</em> – Index of the image (1 or 2) that contains the <tt class="docutils literal"><span class="pre">points</span></tt></li>
<li><em>F</em> – The fundamental matrix that can be estimated using <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#findfundamentalmat"><em>FindFundamentalMat</em></a> or <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#stereorectify"><em>StereoRectify</em></a>.</li>
<li><em>lines</em> – The output epilines, a <tt class="docutils literal"><span class="pre">3xN</span></tt> or <tt class="docutils literal"><span class="pre">Nx3</span></tt> array. Each line <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/6546e1d4222b87f15e10d1533985e6b9996c540f.png" alt="$ax + by + c=0$"> is encoded by 3 numbers <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/2fd4ad65ca9fc7945375cdb55938595bdba63261.png" alt="$(a, b, c)$"></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>For every point in one of the two images of a stereo-pair the function finds the equation of the corresponding epipolar line in the other image.</p>
<p>From the fundamental matrix definition (see <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#findfundamentalmat"><em>FindFundamentalMat</em></a>), line <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/1b8d02578d1c20c470ee9c645f73717bc414e070.png" alt="$l^{(2)}_ i$"> in the second image for the point <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/0252eadbd994157eb6db7367df45720191fdab4d.png" alt="$p^{(1)}_ i$"> in the first image (i.e. when <tt class="docutils literal"><span class="pre">whichImage=1</span></tt>) is computed as:</p>
<div class="math">
<p><img src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/b4497cd70fb61da0137ca850c4ff866f74a668bf.png" alt="l^{(2)}_ i = F p^{(1)}_ i"></p>
</div><p>and, vice versa, when <tt class="docutils literal"><span class="pre">whichImage=2</span></tt>, <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/4fcece8e1a24c3657440aac341d6c80ecebc4699.png" alt="$l^{(1)}_ i$"> is computed from <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/3b2523b5c88739da22b29ff9e533e7630ee35ff2.png" alt="$p^{(2)}_ i$"> as:</p>
<div class="math">
<p><img src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/d8ba9d99501accba1a7441cc04a3a313cae91b38.png" alt="l^{(1)}_ i = F^ T p^{(2)}_ i"></p>
</div><p>Line coefficients are defined up to a scale. They are normalized, such that <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/8e9b67013a567c7ac3c88bb05ffb28b26324078d.png" alt="$a_ i^2+b_ i^2=1$">.</p>
</dd></dl>

</div>
<div class="section" id="convertpointshomogeneous">
<span id="index-15"></span><span id="id4"></span><h2>ConvertPointsHomogeneous<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#convertpointshomogeneous" title="Permalink to this headline">¶</a></h2>
<p>bgroup({convertPointsHomogeneous})</p>
<dl class="cfunction">
<dt id="cvConvertPointsHomogeneous">
void <tt class="descname">cvConvertPointsHomogeneous</tt><big>(</big>const CvMat*<em> src</em>, CvMat*<em> dst</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvConvertPointsHomogeneous" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert points to/from homogeneous coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>src</em> – The input point array, <tt class="docutils literal"><span class="pre">2xN,</span> <span class="pre">Nx2,</span> <span class="pre">3xN,</span> <span class="pre">Nx3,</span> <span class="pre">4xN</span> <span class="pre">or</span> <span class="pre">Nx4</span> <span class="pre">(where</span> <span class="pre">``N</span></tt> is the number of points)``. Multi-channel <tt class="docutils literal"><span class="pre">1xN</span></tt> or <tt class="docutils literal"><span class="pre">Nx1</span></tt> array is also acceptable</li>
<li><em>dst</em> – The output point array, must contain the same number of points as the input; The dimensionality must be the same, 1 less or 1 more than the input, and also within 2 to 4</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The function converts 2D or 3D points from/to homogeneous coordinates, or simply copies or transposes the array. If the input array dimensionality is larger than the output, each coordinate is divided by the last coordinate:</p>
<div class="math">
<p><img src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/df8f6c5a35d1b52e56fdf4aca810f22f88dbcdff.png" alt="\begin{array}{l} (x,y[,z],w) -&gt; (x&#39;,y&#39;[,z&#39;])\\ \text {where} \\ x&#39; = x/w \\ y&#39; = y/w \\ z&#39; = z/w \quad \text {(if output is 3D)} \end{array}"></p>
</div><p>If the output array dimensionality is larger, an extra 1 is appended to each point. Otherwise, the input array is simply copied (with optional transposition) to the output.</p>
<p>Note because the function accepts a large variety of array layouts, it may report an error when input/output array dimensionality is ambiguous. It is always safe to use the function with number of points <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/7f5486a9066994a9550d41cb9a358e24b48d15fc.png" alt="$\texttt{N} \ge 5$">, or to use multi-channel <tt class="docutils literal"><span class="pre">Nx1</span></tt> or <tt class="docutils literal"><span class="pre">1xN</span></tt> arrays.</p>
</dd></dl>

</div>
<div class="section" id="createpositobject">
<span id="index-16"></span><span id="id5"></span><h2>CreatePOSITObject<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#createpositobject" title="Permalink to this headline">¶</a></h2>
<dl class="cfunction">
<dt id="cvCreatePOSITObject">
CvPOSITObject* <tt class="descname">cvCreatePOSITObject</tt><big>(</big>CvPoint3D32f*<em> points</em>, int<em> point_count</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvCreatePOSITObject" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes a structure containing object information.</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>points</em> – Pointer to the points of the 3D object model</li>
<li><em>point_count</em> – Number of object points</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The function allocates memory for the object structure and computes the object inverse matrix.</p>
<p>The preprocessed object data is stored in the structure <em class="xref">CvPOSITObject</em>, internal for OpenCV, which means that the user cannot directly access the structure data. The user may only create this structure and pass its pointer to the function.</p>
<p>An object is defined as a set of points given in a coordinate system. The function <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#posit"><em>POSIT</em></a> computes a vector that begins at a camera-related coordinate system center and ends at the <tt class="docutils literal"><span class="pre">points[0]</span></tt> of the object.</p>
<p>Once the work with a given object is finished, the function <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#releasepositobject"><em>ReleasePOSITObject</em></a> must be called to free memory.</p>
</dd></dl>

</div>
<div class="section" id="createstereobmstate">
<span id="index-17"></span><span id="id6"></span><h2>CreateStereoBMState<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#createstereobmstate" title="Permalink to this headline">¶</a></h2>
<dl class="cfunction">
<dt id="cvCreateStereoBMState">
CvStereoBMState* <tt class="descname">cvCreateStereoBMState</tt><big>(</big>int<em> preset=CV_STEREO_BM_BASIC</em>, int<em> numberOfDisparities=0</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvCreateStereoBMState" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates block matching stereo correspondence structure.</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>preset</em> – ID of one of the pre-defined parameter sets. Any of the parameters can be overridden after creating the structure.</li>
<li><em>numberOfDisparities</em> – <p>The number of disparities. If the parameter is 0, it is taken from the preset, otherwise the supplied value overrides the one from preset.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#define CV_STEREO_BM_BASIC 0</span>
<span class="cp">#define CV_STEREO_BM_FISH_EYE 1</span>
<span class="cp">#define CV_STEREO_BM_NARROW 2</span>
</pre></div>
</div>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The function creates the stereo correspondence structure and initializes it. It is possible to override any of the parameters at any time between the calls to <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#findstereocorrespondencebm"><em>FindStereoCorrespondenceBM</em></a>.</p>
</dd></dl>

</div>
<div class="section" id="createstereogcstate">
<span id="index-18"></span><span id="id7"></span><h2>CreateStereoGCState<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#createstereogcstate" title="Permalink to this headline">¶</a></h2>
<dl class="cfunction">
<dt id="cvCreateStereoGCState">
CvStereoGCState* <tt class="descname">cvCreateStereoGCState</tt><big>(</big>int<em> numberOfDisparities</em>, int<em> maxIters</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvCreateStereoGCState" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the state of graph cut-based stereo correspondence algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>numberOfDisparities</em> – The number of disparities. The disparity search range will be <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/6e209233fdb9a0ac10b4f0aaec16c40594a92bd4.png" alt="$\texttt{state-&gt;minDisparity} \le disparity &lt; \texttt{state-&gt;minDisparity} + \texttt{state-&gt;numberOfDisparities}$"></li>
<li><em>maxIters</em> – Maximum number of iterations. On each iteration all possible (or reasonable) alpha-expansions are tried. The algorithm may terminate earlier if it could not find an alpha-expansion that decreases the overall cost function value. See  for details.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The function creates the stereo correspondence structure and initializes it. It is possible to override any of the parameters at any time between the calls to <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#findstereocorrespondencegc"><em>FindStereoCorrespondenceGC</em></a>.</p>
</dd></dl>

</div>
<div class="section" id="cvstereobmstate">
<span id="index-19"></span><span id="id8"></span><h2>CvStereoBMState<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvstereobmstate" title="Permalink to this headline">¶</a></h2>
<p>The structure for block matching stereo correspondence algorithm.</p>
<blockquote>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">CvStereoBMState</span>
<span class="p">{</span>
    <span class="c1">//pre filters (normalize input images):</span>
    <span class="kt">int</span>       <span class="n">preFilterType</span><span class="p">;</span> <span class="c1">// 0 for now</span>
    <span class="kt">int</span>       <span class="n">preFilterSize</span><span class="p">;</span> <span class="c1">// ~5x5..21x21</span>
    <span class="kt">int</span>       <span class="n">preFilterCap</span><span class="p">;</span>  <span class="c1">// up to ~31</span>
    <span class="c1">//correspondence using Sum of Absolute Difference (SAD):</span>
    <span class="kt">int</span>       <span class="n">SADWindowSize</span><span class="p">;</span> <span class="c1">// Could be 5x5..21x21</span>
    <span class="kt">int</span>       <span class="n">minDisparity</span><span class="p">;</span>  <span class="c1">// minimum disparity (=0)</span>
    <span class="kt">int</span>       <span class="n">numberOfDisparities</span><span class="p">;</span> <span class="c1">// maximum disparity - minimum disparity</span>
    <span class="c1">//post filters (knock out bad matches):</span>
    <span class="kt">int</span>       <span class="n">textureThreshold</span><span class="p">;</span> <span class="c1">// areas with no texture are ignored</span>
    <span class="kt">float</span>     <span class="n">uniquenessRatio</span><span class="p">;</span><span class="c1">// filter out pixels if there are other close matches</span>
                              <span class="c1">// with different disparity</span>
    <span class="kt">int</span>       <span class="n">speckleWindowSize</span><span class="p">;</span> <span class="c1">// the maximum area of speckles to remove</span>
                                 <span class="c1">// (set to 0 to disable speckle filtering)</span>
    <span class="kt">int</span>       <span class="n">speckleRange</span><span class="p">;</span> <span class="c1">// acceptable range of disparity variation in each connected component</span>
    <span class="c1">// internal data</span>
    <span class="p">...</span>
<span class="p">}</span>
<span class="n">CvStereoBMState</span><span class="p">;</span>
</pre></div>
</div>
</blockquote>
<p>The block matching stereo correspondence algorithm, by Kurt Konolige, is very fast one-pass stereo matching algorithm that uses sliding sums of absolute differences between pixels in the left image and the pixels in the right image, shifted by some varying amount of pixels (from <tt class="docutils literal"><span class="pre">minDisparity</span></tt> to <tt class="docutils literal"><span class="pre">minDisparity+numberOfDisparities</span></tt>). On a pair of images WxH the algorithm computes disparity in <tt class="docutils literal"><span class="pre">O(W*H*numberOfDisparities)</span></tt> time. In order to improve quality and reability of the disparity map, the algorithm includes pre-filtering and post-filtering procedures.</p>
<p>Note that the algorithm searches for the corresponding blocks in x direction only. It means that the supplied stereo pair should be rectified. Vertical stereo layout is not directly supported, but in such a case the images could be transposed by user.</p>
</div>
<div class="section" id="cvstereogcstate">
<span id="index-20"></span><span id="id9"></span><h2>CvStereoGCState<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvstereogcstate" title="Permalink to this headline">¶</a></h2>
<p>The structure for graph cuts-based stereo correspondence algorithm</p>
<blockquote>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">CvStereoGCState</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">Ithreshold</span><span class="p">;</span> <span class="c1">// threshold for piece-wise linear data cost function (5 by default)</span>
    <span class="kt">int</span> <span class="n">interactionRadius</span><span class="p">;</span> <span class="c1">// radius for smoothness cost function (1 by default; means Potts model)</span>
    <span class="kt">float</span> <span class="n">K</span><span class="p">,</span> <span class="n">lambda</span><span class="p">,</span> <span class="n">lambda1</span><span class="p">,</span> <span class="n">lambda2</span><span class="p">;</span> <span class="c1">// parameters for the cost function</span>
                                       <span class="c1">// (usually computed adaptively from the input data)</span>
    <span class="kt">int</span> <span class="n">occlusionCost</span><span class="p">;</span> <span class="c1">// 10000 by default</span>
    <span class="kt">int</span> <span class="n">minDisparity</span><span class="p">;</span> <span class="c1">// 0 by default; see CvStereoBMState</span>
    <span class="kt">int</span> <span class="n">numberOfDisparities</span><span class="p">;</span> <span class="c1">// defined by user; see CvStereoBMState</span>
    <span class="kt">int</span> <span class="n">maxIters</span><span class="p">;</span> <span class="c1">// number of iterations; defined by user.</span>

    <span class="c1">// internal buffers</span>
    <span class="n">CvMat</span><span class="o">*</span> <span class="n">left</span><span class="p">;</span>
    <span class="n">CvMat</span><span class="o">*</span> <span class="n">right</span><span class="p">;</span>
    <span class="n">CvMat</span><span class="o">*</span> <span class="n">dispLeft</span><span class="p">;</span>
    <span class="n">CvMat</span><span class="o">*</span> <span class="n">dispRight</span><span class="p">;</span>
    <span class="n">CvMat</span><span class="o">*</span> <span class="n">ptrLeft</span><span class="p">;</span>
    <span class="n">CvMat</span><span class="o">*</span> <span class="n">ptrRight</span><span class="p">;</span>
    <span class="n">CvMat</span><span class="o">*</span> <span class="n">vtxBuf</span><span class="p">;</span>
    <span class="n">CvMat</span><span class="o">*</span> <span class="n">edgeBuf</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">CvStereoGCState</span><span class="p">;</span>
</pre></div>
</div>
</blockquote>
<p>The graph cuts stereo correspondence algorithm, described in  (as KZ1), is non-realtime stereo correpsondence algorithm that usually gives very accurate depth map with well-defined object boundaries. The algorithm represents stereo problem as a sequence of binary optimization problems, each of those is solved using maximum graph flow algorithm. The state structure above should not be allocated and initialized manually; instead, use <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#createstereogcstate"><em>CreateStereoGCState</em></a> and then override necessary parameters if needed.</p>
</div>
<div class="section" id="decomposeprojectionmatrix">
<span id="index-21"></span><span id="id10"></span><h2>DecomposeProjectionMatrix<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#decomposeprojectionmatrix" title="Permalink to this headline">¶</a></h2>
<p>bgroup({decomposeProjectionMatrix})</p>
<dl class="cfunction">
<dt id="cvDecomposeProjectionMatrix">
void <tt class="descname">cvDecomposeProjectionMatrix</tt><big>(</big>const CvMat<em> *projMatrix</em>, CvMat<em> *cameraMatrix</em>, CvMat<em> *rotMatrix</em>, CvMat<em> *transVect</em>, CvMat<em> *rotMatrX=NULL</em>, CvMat<em> *rotMatrY=NULL</em>, CvMat<em> *rotMatrZ=NULL</em>, CvPoint3D64f<em> *eulerAngles=NULL</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvDecomposeProjectionMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Decomposes the projection matrix into a rotation matrix and a camera matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>projMatrix</em> – The 3x4 input projection matrix P</li>
<li><em>cameraMatrix</em> – The output 3x3 camera matrix K</li>
<li><em>rotMatrix</em> – The output 3x3 external rotation matrix R</li>
<li><em>transVect</em> – The output 4x1 translation vector T</li>
<li><em>rotMatrX</em> – Optional 3x3 rotation matrix around x-axis</li>
<li><em>rotMatrY</em> – Optional 3x3 rotation matrix around y-axis</li>
<li><em>rotMatrZ</em> – Optional 3x3 rotation matrix around z-axis</li>
<li><em>eulerAngles</em> – Optional 3 points containing the three Euler angles of rotation</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The function computes a decomposition of a projection matrix into a calibration and a rotation matrix and the position of the camera.</p>
<p>It optionally returns three rotation matrices, one for each axis, and the three Euler angles that could be used in OpenGL.</p>
<p>The function is based on <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#rqdecomp3x3"><em>RQDecomp3x3</em></a>.</p>
</dd></dl>

</div>
<div class="section" id="drawchessboardcorners">
<span id="index-22"></span><span id="id11"></span><h2>DrawChessboardCorners<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#drawchessboardcorners" title="Permalink to this headline">¶</a></h2>
<p>bgroup({drawChessboardCorners})</p>
<dl class="cfunction">
<dt id="cvDrawChessboardCorners">
void <tt class="descname">cvDrawChessboardCorners</tt><big>(</big>CvArr*<em> image</em>, CvSize<em> patternSize</em>, CvPoint2D32f*<em> corners</em>, int<em> count</em>, int<em> patternWasFound</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvDrawChessboardCorners" title="Permalink to this definition">¶</a></dt>
<dd><p>Renders the detected chessboard corners.</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>image</em> – The destination image; it must be an 8-bit color image</li>
<li><em>patternSize</em> – The number of inner corners per chessboard row and column. (patternSize = cvSize(points_per_row,points_per_colum) = cvSize(columns,rows) )</li>
<li><em>corners</em> – The array of corners detected</li>
<li><em>count</em> – The number of corners</li>
<li><em>patternWasFound</em> – Indicates whether the complete board was found <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/9c57823e1bca1a6570a5e7dd2e08617c4733ac8b.png" alt="$(\ne 0)$"> or not <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/bc6fd1ee28585b824a39754113a4ac440921e0df.png" alt="$(=0)$">. One may just pass the return value :ref:<a href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#id12"><span class="problematic" id="id13">`</span></a>FindChessboardCorners`bgroup({findChessboardCorners}) here</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The function draws the individual chessboard corners detected as red circles if the board was not found or as colored corners connected with lines if the board was found.</p>
</dd></dl>

</div>
<div class="section" id="findchessboardcorners">
<span id="index-23"></span><span id="id14"></span><h2>FindChessboardCorners<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#findchessboardcorners" title="Permalink to this headline">¶</a></h2>
<p>bgroup({findChessboardCorners})</p>
<dl class="cfunction">
<dt id="cvFindChessboardCorners">
int <tt class="descname">cvFindChessboardCorners</tt><big>(</big>const void*<em> image</em>, CvSize<em> patternSize</em>, CvPoint2D32f*<em> corners</em>, int*<em> cornerCount=NULL</em>, int<em> flags=CV_CALIB_CB_ADAPTIVE_THRESH</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvFindChessboardCorners" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the positions of the internal corners of the chessboard.</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>image</em> – Source chessboard view; it must be an 8-bit grayscale or color image</li>
<li><em>patternSize</em> – The number of inner corners per chessboard row and column ( patternSize = cvSize(points_per_row,points_per_colum) = cvSize(columns,rows) )</li>
<li><em>corners</em> – The output array of corners detected</li>
<li><em>cornerCount</em> – The output corner counter. If it is not NULL, it stores the number of corners found</li>
<li><em>flags</em> – <p>Various operation flags, can be 0 or a combination of the following values:</p>
<ul>
<li><strong>CV_CALIB_CB_ADAPTIVE_THRESH</strong> - use adaptive thresholding to convert the image to black and white, rather than a fixed threshold level (computed from the average image brightness).</li>
<li><strong>CV_CALIB_CB_NORMALIZE_IMAGE</strong> - normalize the image gamma with <em class="xref">EqualizeHist</em> before applying fixed or adaptive thresholding.</li>
<li><strong>CV_CALIB_CB_FILTER_QUADS</strong> - use additional criteria (like contour area, perimeter, square-like shape) to filter out false quads that are extracted at the contour retrieval stage.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The function attempts to determine whether the input image is a view of the chessboard pattern and locate the internal chessboard corners. The function returns a non-zero value if all of the corners have been found and they have been placed in a certain order (row by row, left to right in every row), otherwise, if the function fails to find all the corners or reorder them, it returns 0. For example, a regular chessboard has 8 x 8 squares and 7 x 7 internal corners, that is, points, where the black squares touch each other. The coordinates detected are approximate, and to determine their position more accurately, the user may use the function <a class="reference external" href="http://opencv.willowgarage.com/documentation/feature_detection.html#findcornersubpix"><em>FindCornerSubPix</em></a>.</p>
<p>Note: the function requires some white space (like a square-thick border, the wider the better) around the board to make the detection more robust in various environment (otherwise if there is no border and the background is dark, the outer black squares could not be segmented properly and so the square grouping and ordering algorithm will fail).</p>
</dd></dl>

</div>
<div class="section" id="findextrinsiccameraparams2">
<span id="index-24"></span><span id="id15"></span><h2>FindExtrinsicCameraParams2<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#findextrinsiccameraparams2" title="Permalink to this headline">¶</a></h2>
<p>bgroup({solvePnP})</p>
<dl class="cfunction">
<dt id="cvFindExtrinsicCameraParams2">
void <tt class="descname">cvFindExtrinsicCameraParams2</tt><big>(</big>const CvMat*<em> objectPoints</em>, const CvMat*<em> imagePoints</em>, const CvMat*<em> cameraMatrix</em>, const CvMat*<em> distCoeffs</em>, CvMat*<em> rvec</em>, CvMat*<em> tvec</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvFindExtrinsicCameraParams2" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the object pose from the 3D-2D point correspondences</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>objectPoints</em> – The array of object points in the object coordinate space, 3xN or Nx3 1-channel, or 1xN or Nx1 3-channel, where N is the number of points.</li>
<li><em>imagePoints</em> – The array of corresponding image points, 2xN or Nx2 1-channel or 1xN or Nx1 2-channel, where N is the number of points.</li>
<li><em>cameraMatrix</em> – The input camera matrix <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/a7de2eb1fc4073569e797961b31a6e258ff74558.png" alt="$A = \vecthreethree {fx}{0}{cx}{0}{fy}{cy}{0}{0}{1} $"></li>
<li><em>distCoeffs</em> – The input 4x1, 1x4, 5x1 or 1x5 vector of distortion coefficients <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/796eb1a636b634304dad7fa020666f8bb64ff406.png" alt="$(k_1, k_2, p_1, p_2[, k_3])$">. If it is NULL, all of the distortion coefficients are set to 0</li>
<li><em>rvec</em> – The output rotation vector (see <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#rodrigues2"><em>Rodrigues2</em></a>) that (together with <tt class="docutils literal"><span class="pre">tvec</span></tt>) brings points from the model coordinate system to the camera coordinate system</li>
<li><em>tvec</em> – The output translation vector</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The function estimates the object pose given a set of object points, their corresponding image projections, as well as the camera matrix and the distortion coefficients. This function finds such a pose that minimizes reprojection error, i.e. the sum of squared distances between the observed projections <tt class="docutils literal"><span class="pre">imagePoints</span></tt> and the projected (using <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#projectpoints2"><em>ProjectPoints2</em></a>) <tt class="docutils literal"><span class="pre">objectPoints</span></tt>.</p>
</dd></dl>

</div>
<div class="section" id="findfundamentalmat">
<span id="index-25"></span><span id="id16"></span><h2>FindFundamentalMat<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#findfundamentalmat" title="Permalink to this headline">¶</a></h2>
<p>bgroup({findFundamentalMat})</p>
<dl class="cfunction">
<dt id="cvFindFundamentalMat">
int <tt class="descname">cvFindFundamentalMat</tt><big>(</big>const CvMat*<em> points1</em>, const CvMat*<em> points2</em>, CvMat*<em> fundamentalMatrix</em>, int<em> method=CV_FM_RANSAC</em>, double<em> param1=1.</em>, double<em> param2=0.99</em>, CvMat*<em> status=NULL</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvFindFundamentalMat" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the fundamental matrix from the corresponding points in two images.</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>points1</em> – Array of <tt class="docutils literal"><span class="pre">N</span></tt> points from the first image.It can be <tt class="docutils literal"><span class="pre">2xN,</span> <span class="pre">Nx2,</span> <span class="pre">3xN</span></tt> or <tt class="docutils literal"><span class="pre">Nx3</span></tt> 1-channel array or <tt class="docutils literal"><span class="pre">1xN</span></tt> or <tt class="docutils literal"><span class="pre">Nx1</span></tt> 2- or 3-channel array. The point coordinates should be floating-point (single or double precision)</li>
<li><em>points2</em> – Array of the second image points of the same size and format as <tt class="docutils literal"><span class="pre">points1</span></tt></li>
<li><em>fundamentalMatrix</em> – The output fundamental matrix or matrices. The size should be 3x3 or 9x3 (7-point method may return up to 3 matrices)</li>
<li><em>method</em> – <p>Method for computing the fundamental matrix</p>
<ul>
<li><strong>CV_FM_7POINT</strong> - for a 7-point algorithm. <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/3c8d4ea9cf0ceccc624845322e72803ab69e5d40.png" alt="$N = 7$"></li>
<li><strong>CV_FM_8POINT</strong> - for an 8-point algorithm. <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/4a2f72343cd36430941e6546348d985f7bb7886e.png" alt="$N \ge 8$"></li>
<li><strong>CV_FM_RANSAC</strong> - for the RANSAC algorithm. <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/4a2f72343cd36430941e6546348d985f7bb7886e.png" alt="$N \ge 8$"></li>
<li><strong>CV_FM_LMEDS</strong> - for the LMedS algorithm. <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/4a2f72343cd36430941e6546348d985f7bb7886e.png" alt="$N \ge 8$"></li>
</ul>
</li>
<li><em>param1</em> – The parameter is used for RANSAC. It is the maximum distance from point to epipolar line in pixels, beyond which the point is considered an outlier and is not used for computing the final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the point localization, image resolution and the image noise</li>
<li><em>param2</em> – The parameter is used for RANSAC or LMedS methods only. It specifies the desirable level of confidence (probability) that the estimated matrix is correct</li>
<li><em>status</em> – The optional output array of N elements, every element of which is set to 0 for outliers and to 1 for the other points. The array is computed only in RANSAC and LMedS methods. For other methods it is set to all 1’s</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The epipolar geometry is described by the following equation:</p>
<div class="math">
<p><img src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/162ff63199717c7c97b46402e94d0ba4783a48bd.png" alt="[p_2; 1]^ T F [p_1; 1] = 0"></p>
</div><p>where <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/e7a4a23041c75a92a8d6965f14cc61fb2509ef39.png" alt="$F$"> is fundamental matrix, <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/9d5027ac1fbb484b97d4d8d6dd0f0dff79fc835f.png" alt="$p_1$"> and <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/6d574568509c7384bbf9859862d56b092b17b99d.png" alt="$p_2$"> are corresponding points in the first and the second images, respectively.</p>
<p>The function calculates the fundamental matrix using one of four methods listed above and returns the number of fundamental matrices found (1 or 3) and 0, if no matrix is found. Normally just 1 matrix is found, but in the case of 7-point algorithm the function may return up to 3 solutions (<img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/be2b219cd3b0a0c9b17d5ddf89680a986c79bdda.png" alt="$9 \times 3$"> matrix that stores all 3 matrices sequentially).</p>
<p>The calculated fundamental matrix may be passed further to <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#computecorrespondepilines"><em>ComputeCorrespondEpilines</em></a> that finds the epipolar lines corresponding to the specified points. It can also be passed to <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#stereorectifyuncalibrated"><em>StereoRectifyUncalibrated</em></a> to compute the rectification transformation.</p>
<blockquote>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">int</span> <span class="n">point_count</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="n">CvMat</span><span class="o">*</span> <span class="n">points1</span><span class="p">;</span>
<span class="n">CvMat</span><span class="o">*</span> <span class="n">points2</span><span class="p">;</span>
<span class="n">CvMat</span><span class="o">*</span> <span class="n">status</span><span class="p">;</span>
<span class="n">CvMat</span><span class="o">*</span> <span class="n">fundamental_matrix</span><span class="p">;</span>

<span class="n">points1</span> <span class="o">=</span> <span class="n">cvCreateMat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">point_count</span><span class="p">,</span><span class="n">CV_32FC2</span><span class="p">);</span>
<span class="n">points2</span> <span class="o">=</span> <span class="n">cvCreateMat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">point_count</span><span class="p">,</span><span class="n">CV_32FC2</span><span class="p">);</span>
<span class="n">status</span> <span class="o">=</span> <span class="n">cvCreateMat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">point_count</span><span class="p">,</span><span class="n">CV_8UC1</span><span class="p">);</span>

<span class="cm">/* Fill the points here ... */</span>
<span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">point_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">points1</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">fl</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">x</span><span class="p">,,</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,,</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="n">points1</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">fl</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">y</span><span class="p">,,</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,,</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="n">points2</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">fl</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">x</span><span class="p">,,</span><span class="mi">2</span><span class="p">,</span><span class="n">i</span><span class="p">,,</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="n">points2</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">fl</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">y</span><span class="p">,,</span><span class="mi">2</span><span class="p">,</span><span class="n">i</span><span class="p">,,</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">fundamental_matrix</span> <span class="o">=</span> <span class="n">cvCreateMat</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">CV_32FC1</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fm_count</span> <span class="o">=</span> <span class="n">cvFindFundamentalMat</span><span class="p">(</span> <span class="n">points1</span><span class="p">,</span><span class="n">points2</span><span class="p">,</span><span class="n">fundamental_matrix</span><span class="p">,</span>
                                     <span class="n">CV_FM_RANSAC</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.99</span><span class="p">,</span><span class="n">status</span> <span class="p">);</span>
</pre></div>
</div>
</blockquote>
</dd></dl>

</div>
<div class="section" id="findhomography">
<span id="index-26"></span><span id="id17"></span><h2>FindHomography<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#findhomography" title="Permalink to this headline">¶</a></h2>
<p>bgroup({findHomography})</p>
<dl class="cfunction">
<dt id="cvFindHomography">
void <tt class="descname">cvFindHomography</tt><big>(</big>const CvMat*<em> srcPoints</em>, const CvMat*<em> dstPoints</em>, CvMat* H int<em> method=0</em>, double<em> ransacReprojThreshold=0</em>, CvMat*<em> status=NULL</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvFindHomography" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<p>Finds the perspective transformation between two planes.</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name" colspan="2">param srcPoints:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><p class="first">Coordinates of the points in the original plane, 2xN, Nx2, 3xN or Nx3 1-channel array (the latter two are for representation in homogeneous coordinates), where N is the number of points. 1xN or Nx1 2- or 3-channel array can also be passed.</p>
</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">param dstPoints:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><p class="first">Point coordinates in the destination plane, 2xN, Nx2, 3xN or Nx3 1-channel, or 1xN or Nx1 2- or 3-channel array.</p>
</td>
</tr>
<tr class="field"><th class="field-name">param H:</th><td class="field-body"><p class="first">The output 3x3 homography matrix</p>
</td>
</tr>
<tr class="field"><th class="field-name">param method:</th><td class="field-body"><p class="first">The method used to computed homography matrix; one of the following:</p>
<ul class="simple">
<li><strong>0</strong> - a regular method using all the points</li>
<li><strong>CV_RANSAC</strong> - RANSAC-based robust method</li>
<li><strong>CV_LMEDS</strong> - Least-Median robust method</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">param ransacReprojThreshold:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><p class="first">The maximum allowed reprojection error to treat a point pair as an inlier (used in the RANSAC method only). That is, if</p>
<div class="last math">
<p><img src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/2d4b2af3b30388f97b56211982b5ea0b47916f66.png" alt="\| \texttt{dstPoints}_ i - \texttt{convertPointHomogeneous}(\texttt{H} \texttt{srcPoints}_ i)\| &gt; \texttt{ransacReprojThreshold}"></p>
</div></td>
</tr>
</tbody>
</table>
</blockquote>
<dl class="docutils">
<dt>then the point <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/b700df16175296c05fa384cc9b12ff063a31d484.png" alt="$i$"> is considered an outlier. If <tt class="docutils literal"><span class="pre">srcPoints</span></tt> and <tt class="docutils literal"><span class="pre">dstPoints</span></tt> are measured in pixels, it usually makes sense to set this parameter somewhere in the range 1 to 10.</dt>
<dd><table class="first docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">param status:</th><td class="field-body">The optional output mask set by a robust method (<tt class="xref docutils literal"><span class="pre">CV_RANSAC</span></tt> or <tt class="xref docutils literal"><span class="pre">CV_LMEDS</span></tt>). Note that the input mask values are ignored.</td>
</tr>
</tbody>
</table>
<p>The function finds the perspective transformation <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/ba357b8f3edc9aad0e852cd483803f0a7e6d5d25.png" alt="$H$"> between the source and the destination planes:</p>
<div class="math">
<p><img src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/6fef36e9451d7e61d602d152b8509f6df6fe205b.png" alt="s_ i \vecthree {x&#39;_ i}{y&#39;_ i}{1} \sim H \vecthree {x_ i}{y_ i}{1}"></p>
</div><p>So that the back-projection error</p>
<div class="math">
<p><img src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/f6fb6b1b158098b0818f969ee5d18ed60b466679.png" alt="\sum _ i \left( x&#39;_ i-\frac{h_{11} x_ i + h_{12} y_ i + h_{13}}{h_{31} x_ i + h_{32} y_ i + h_{33}} \right)^2+ \left( y&#39;_ i-\frac{h_{21} x_ i + h_{22} y_ i + h_{23}}{h_{31} x_ i + h_{32} y_ i + h_{33}} \right)^2"></p>
</div><p>is minimized. If the parameter <tt class="docutils literal"><span class="pre">method</span></tt> is set to the default value 0, the function uses all the point pairs to compute the initial homography estimate with a simple least-squares scheme.</p>
<p>However, if not all of the point pairs (<img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/b80f3cf55d4feec5e3d5331fda13c501ce471cfc.png" alt="$srcPoints_ i$">, <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/36751b7f2fb938612822352cd27bc3df98e19ad1.png" alt="$dstPoints_ i$">) fit the rigid perspective transformation (i.e. there are some outliers), this initial estimate will be poor. In this case one can use one of the 2 robust methods. Both methods, <tt class="docutils literal"><span class="pre">RANSAC</span></tt> and <tt class="docutils literal"><span class="pre">LMeDS</span></tt>, try many different random subsets of the corresponding point pairs (of 4 pairs each), estimate the homography matrix using this subset and a simple least-square algorithm and then compute the quality/goodness of the computed homography (which is the number of inliers for RANSAC or the median re-projection error for LMeDs). The best subset is then used to produce the initial estimate of the homography matrix and the mask of inliers/outliers.</p>
<p>Regardless of the method, robust or not, the computed homography matrix is refined further (using inliers only in the case of a robust method) with the Levenberg-Marquardt method in order to reduce the re-projection error even more.</p>
<p>The method <tt class="docutils literal"><span class="pre">RANSAC</span></tt> can handle practically any ratio of outliers, but it needs the threshold to distinguish inliers from outliers. The method <tt class="docutils literal"><span class="pre">LMeDS</span></tt> does not need any threshold, but it works correctly only when there are more than 50% of inliers. Finally, if you are sure in the computed features, where can be only some small noise present, but no outliers, the default method could be the best choice.</p>
<p>The function is used to find initial intrinsic and extrinsic matrices. Homography matrix is determined up to a scale, thus it is normalized so that <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/54c1bfdafc99b2327d38d8d66104d768ef242894.png" alt="$h_{33}=1$">.</p>
<p class="last">See also: <a class="reference external" href="http://opencv.willowgarage.com/documentation/geometric_image_transformations.html#getaffinetransform"><em>GetAffineTransform</em></a>, <a class="reference external" href="http://opencv.willowgarage.com/documentation/geometric_image_transformations.html#getperspectivetransform"><em>GetPerspectiveTransform</em></a>, <em class="xref">EstimateRigidMotion</em>, <a class="reference external" href="http://opencv.willowgarage.com/documentation/geometric_image_transformations.html#warpperspective"><em>WarpPerspective</em></a>, <a class="reference external" href="http://opencv.willowgarage.com/documentation/operations_on_arrays.html#perspectivetransform"><em>PerspectiveTransform</em></a></p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="findstereocorrespondencebm">
<span id="index-27"></span><span id="id18"></span><h2>FindStereoCorrespondenceBM<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#findstereocorrespondencebm" title="Permalink to this headline">¶</a></h2>
<dl class="cfunction">
<dt id="cvFindStereoCorrespondenceBM">
void <tt class="descname">cvFindStereoCorrespondenceBM</tt><big>(</big>const CvArr*<em> left</em>, const CvArr*<em> right</em>, CvArr*<em> disparity</em>, CvStereoBMState*<em> state</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvFindStereoCorrespondenceBM" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the disparity map using block matching algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>left</em> – The left single-channel, 8-bit image.</li>
<li><em>right</em> – The right image of the same size and the same type.</li>
<li><em>disparity</em> – The output single-channel 16-bit signed, or 32-bit floating-point disparity map of the same size as input images. In the first case the computed disparities are represented as fixed-point numbers with 4 fractional bits (i.e. the computed disparity values are multiplied by 16 and rounded to integers).</li>
<li><em>state</em> – Stereo correspondence structure.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The function cvFindStereoCorrespondenceBM computes disparity map for the input rectified stereo pair. Invalid pixels (for which disparity can not be computed) are set to <tt class="docutils literal"><span class="pre">state-&gt;minDisparity</span> <span class="pre">-</span> <span class="pre">1</span></tt> (or to <tt class="docutils literal"><span class="pre">(state-&gt;minDisparity-1)*16</span></tt> in the case of 16-bit fixed-point disparity map)</p>
</dd></dl>

</div>
<div class="section" id="findstereocorrespondencegc">
<span id="index-28"></span><span id="id19"></span><h2>FindStereoCorrespondenceGC<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#findstereocorrespondencegc" title="Permalink to this headline">¶</a></h2>
<dl class="cfunction">
<dt id="cvFindStereoCorrespondenceGC">
void <tt class="descname">cvFindStereoCorrespondenceGC</tt><big>(</big>const CvArr*<em> left</em>, const CvArr*<em> right</em>, CvArr*<em> dispLeft</em>, CvArr*<em> dispRight</em>, CvStereoGCState*<em> state</em>, int useDisparityGuess =<em> CV_DEFAULT(0)</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvFindStereoCorrespondenceGC" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the disparity map using graph cut-based algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>left</em> – The left single-channel, 8-bit image.</li>
<li><em>right</em> – The right image of the same size and the same type.</li>
<li><em>dispLeft</em> – The optional output single-channel 16-bit signed left disparity map of the same size as input images.</li>
<li><em>dispRight</em> – The optional output single-channel 16-bit signed right disparity map of the same size as input images.</li>
<li><em>state</em> – Stereo correspondence structure.</li>
<li><em>useDisparityGuess</em> – If the parameter is not zero, the algorithm will start with pre-defined disparity maps. Both dispLeft and dispRight should be valid disparity maps. Otherwise, the function starts with blank disparity maps (all pixels are marked as occlusions).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The function computes disparity maps for the input rectified stereo pair. Note that the left disparity image will contain values in the following range:</p>
<div class="math">
<p><img src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/7f306eec85631e88d9b7c27e2e716f6d17166aed.png" alt="-\texttt{state-&gt;numberOfDisparities}-\texttt{state-&gt;minDisparity} &lt; dispLeft(x,y) \le -\texttt{state-&gt;minDisparity},"></p>
</div><p>or</p>
<div class="math">
<p><img src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/aba05c1801b063a773b5cf0bcb1be7af6e0fdd4f.png" alt="dispLeft(x,y) == \texttt{CV\_ STEREO\_ GC\_ OCCLUSION}"></p>
</div><p>and for the right disparity image the following will be true:</p>
<div class="math">
<p><img src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/8b3f737d2b72291ecdf625e5337564ce7784d105.png" alt="\texttt{state-&gt;minDisparity} \le dispRight(x,y) &lt; \texttt{state-&gt;minDisparity} + \texttt{state-&gt;numberOfDisparities}"></p>
</div><p>or</p>
<div class="math">
<p><img src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/9daa82c1ecc18a88aabeae355973a2b56916796a.png" alt="dispRight(x,y) == \texttt{CV\_ STEREO\_ GC\_ OCCLUSION}"></p>
</div><p>that is, the range for the left disparity image will be inversed, and the pixels for which no good match has been found, will be marked as occlusions.</p>
<p>Here is how the function can be called:</p>
<blockquote>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// image_left and image_right are the input 8-bit single-channel images</span>
<span class="c1">// from the left and the right cameras, respectively</span>
<span class="n">CvSize</span> <span class="n">size</span> <span class="o">=</span> <span class="n">cvGetSize</span><span class="p">(</span><span class="n">image_left</span><span class="p">);</span>
<span class="n">CvMat</span><span class="o">*</span> <span class="n">disparity_left</span> <span class="o">=</span> <span class="n">cvCreateMat</span><span class="p">(</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">CV_16S</span> <span class="p">);</span>
<span class="n">CvMat</span><span class="o">*</span> <span class="n">disparity_right</span> <span class="o">=</span> <span class="n">cvCreateMat</span><span class="p">(</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">CV_16S</span> <span class="p">);</span>
<span class="n">CvStereoGCState</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="n">cvCreateStereoGCState</span><span class="p">(</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
<span class="n">cvFindStereoCorrespondenceGC</span><span class="p">(</span> <span class="n">image_left</span><span class="p">,</span> <span class="n">image_right</span><span class="p">,</span>
    <span class="n">disparity_left</span><span class="p">,</span> <span class="n">disparity_right</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
<span class="n">cvReleaseStereoGCState</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">state</span> <span class="p">);</span>
<span class="c1">// now process the computed disparity images as you want ...</span>
</pre></div>
</div>
</blockquote>
<p>and this is the output left disparity image computed from the well-known Tsukuba stereo pair and multiplied by -16 (because the values in the left disparity images are usually negative):</p>
<blockquote>
<div class="highlight-c"><div class="highlight"><pre><span class="n">CvMat</span><span class="o">*</span> <span class="n">disparity_left_visual</span> <span class="o">=</span> <span class="n">cvCreateMat</span><span class="p">(</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">CV_8U</span> <span class="p">);</span>
<span class="n">cvConvertScale</span><span class="p">(</span> <span class="n">disparity_left</span><span class="p">,</span> <span class="n">disparity_left_visual</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span> <span class="p">);</span>
<span class="n">cvSave</span><span class="p">(</span> <span class="s">"disparity.pgm"</span><span class="p">,</span> <span class="n">disparity_left_visual</span> <span class="p">);</span>
</pre></div>
</div>
</blockquote>
<img alt="_images/disparity.png" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/disparity.png">
</dd></dl>

</div>
<div class="section" id="getoptimalnewcameramatrix">
<span id="index-29"></span><span id="id20"></span><h2>GetOptimalNewCameraMatrix<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#getoptimalnewcameramatrix" title="Permalink to this headline">¶</a></h2>
<p>bgroup({getOptimalNewCameraMatrix})</p>
<dl class="cfunction">
<dt id="cvGetOptimalNewCameraMatrix">
void <tt class="descname">cvGetOptimalNewCameraMatrix</tt><big>(</big>const CvMat*<em> cameraMatrix</em>, const CvMat*<em> distCoeffs</em>, CvSize<em> imageSize</em>, double<em> alpha</em>, CvMat*<em> newCameraMatrix</em>, CvSize<em> newImageSize=cvSize(0</em>, 0), CvRect*<em> validPixROI=0</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvGetOptimalNewCameraMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the new camera matrix based on the free scaling parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>cameraMatrix</em> – The input camera matrix</li>
<li><em>distCoeffs</em> – The input 4x1, 1x4, 5x1 or 1x5 vector of distortion coefficients <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/796eb1a636b634304dad7fa020666f8bb64ff406.png" alt="$(k_1, k_2, p_1, p_2[, k_3])$">.</li>
<li><em>imageSize</em> – The original image size</li>
<li><em>alpha</em> – The free scaling parameter between 0 (when all the pixels in the undistorted image will be valid) and 1 (when all the source image pixels will be retained in the undistorted image); see <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#stereorectify"><em>StereoRectify</em></a></li>
<li><em>newCameraMatrix</em> – The output new camera matrix.</li>
<li><em>newImageSize</em> – The image size after rectification. By default it will be set to <tt class="docutils literal"><span class="pre">imageSize</span></tt>.</li>
<li><em>validPixROI</em> – The optional output rectangle that will outline all-good-pixels region in the undistorted image. See <tt class="docutils literal"><span class="pre">roi1,</span> <span class="pre">roi2</span></tt> description in <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#stereorectify"><em>StereoRectify</em></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The function computes  the optimal new camera matrix based on the free scaling parameter. By varying this parameter the user may retrieve only sensible pixels <tt class="docutils literal"><span class="pre">alpha=0</span></tt>, keep all the original image pixels if there is valuable information in the corners <tt class="docutils literal"><span class="pre">alpha=1</span></tt>, or get something in between. When <tt class="docutils literal"><span class="pre">alpha&gt;0</span></tt>, the undistortion result will likely have some black pixels corresponding to “virtual” pixels outside of the captured distorted image. The original camera matrix, distortion coefficients, the computed new camera matrix and the <tt class="docutils literal"><span class="pre">newImageSize</span></tt> should be passed to <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#initundistortrectifymap"><em>InitUndistortRectifyMap</em></a> to produce the maps for <a class="reference external" href="http://opencv.willowgarage.com/documentation/geometric_image_transformations.html#remap"><em>Remap</em></a>.</p>
</dd></dl>

</div>
<div class="section" id="initintrinsicparams2d">
<span id="index-30"></span><span id="id21"></span><h2>InitIntrinsicParams2D<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#initintrinsicparams2d" title="Permalink to this headline">¶</a></h2>
<p>bgroup({initCameraMatrix2D})</p>
<dl class="cfunction">
<dt id="cvInitIntrinsicParams2D">
void <tt class="descname">cvInitIntrinsicParams2D</tt><big>(</big>const CvMat*<em> objectPoints</em>, const CvMat*<em> imagePoints</em>, const CvMat*<em> npoints</em>, CvSize<em> imageSize</em>, CvMat*<em> cameraMatrix</em>, double<em> aspectRatio=1.</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvInitIntrinsicParams2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the initial camera matrix from the 3D-2D point correspondences</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>objectPoints</em> – The joint array of object points; see <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#calibratecamera2"><em>CalibrateCamera2</em></a></li>
<li><em>imagePoints</em> – The joint array of object point projections; see <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#calibratecamera2"><em>CalibrateCamera2</em></a></li>
<li><em>npoints</em> – The array of point counts; see <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#calibratecamera2"><em>CalibrateCamera2</em></a></li>
<li><em>imageSize</em> – The image size in pixels; used to initialize the principal point</li>
<li><em>cameraMatrix</em> – The output camera matrix <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/dc2cefeb8487ccfbad752796b15e813f13ae5535.png" alt="$\vecthreethree {f_ x}{0}{c_ x}{0}{f_ y}{c_ y}{0}{0}{1}$"></li>
<li><em>aspectRatio</em> – If it is zero or negative, both <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/25e0fa5e0f8c5864c5290b69edf98930e055f7ce.png" alt="$f_ x$"> and <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/4dee68490e30bbe4f59304315b89b72ea620f5e2.png" alt="$f_ y$"> are estimated independently. Otherwise <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/b804986ea0b6b3667c62c3786b334ab4673c66bb.png" alt="$f_ x = f_ y * \texttt{aspectRatio}$"></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The function estimates and returns the initial camera matrix for camera calibration process. Currently, the function only supports planar calibration patterns, i.e. patterns where each object point has z-coordinate =0.</p>
</dd></dl>

</div>
<div class="section" id="initundistortmap">
<span id="index-31"></span><span id="id22"></span><h2>InitUndistortMap<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#initundistortmap" title="Permalink to this headline">¶</a></h2>
<dl class="cfunction">
<dt id="cvInitUndistortMap">
void <tt class="descname">cvInitUndistortMap</tt><big>(</big>const CvMat*<em> cameraMatrix</em>, const CvMat*<em> distCoeffs</em>, CvArr*<em> map1</em>, CvArr*<em> map2</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvInitUndistortMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes an undistortion map.</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>cameraMatrix</em> – The input camera matrix <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/a7de2eb1fc4073569e797961b31a6e258ff74558.png" alt="$A = \vecthreethree {fx}{0}{cx}{0}{fy}{cy}{0}{0}{1} $"></li>
<li><em>distCoeffs</em> – The input 4x1, 1x4, 5x1 or 1x5 vector of distortion coefficients <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/796eb1a636b634304dad7fa020666f8bb64ff406.png" alt="$(k_1, k_2, p_1, p_2[, k_3])$">.</li>
<li><em>map1</em> – The first output map of type <tt class="xref docutils literal"><span class="pre">CV_32FC1</span></tt> or <tt class="xref docutils literal"><span class="pre">CV_16SC2</span></tt> - the second variant is more efficient</li>
<li><em>map2</em> – The second output map of type <tt class="xref docutils literal"><span class="pre">CV_32FC1</span></tt> or <tt class="xref docutils literal"><span class="pre">CV_16UC1</span></tt> - the second variant is more efficient</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The function is a simplified variant of <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#initundistortrectifymap"><em>InitUndistortRectifyMap</em></a> where the rectification transformation <tt class="docutils literal"><span class="pre">R</span></tt> is identity matrix and <tt class="docutils literal"><span class="pre">newCameraMatrix=cameraMatrix</span></tt>.</p>
</dd></dl>

</div>
<div class="section" id="initundistortrectifymap">
<span id="index-32"></span><span id="id23"></span><h2>InitUndistortRectifyMap<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#initundistortrectifymap" title="Permalink to this headline">¶</a></h2>
<p>bgroup({initUndistortRectifyMap})</p>
<dl class="cfunction">
<dt id="cvInitUndistortRectifyMap">
void <tt class="descname">cvInitUndistortRectifyMap</tt><big>(</big>const CvMat*<em> cameraMatrix</em>, const CvMat*<em> distCoeffs</em>, const CvMat*<em> R</em>, const CvMat*<em> newCameraMatrix</em>, CvArr*<em> map1</em>, CvArr*<em> map2</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvInitUndistortRectifyMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the undistortion and rectification transformation map.</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>cameraMatrix</em> – The input camera matrix <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/72418649e970ea6adaa81d93e8a0d713ecd2f05a.png" alt="$A=\vecthreethree {f_ x}{0}{c_ x}{0}{f_ y}{c_ y}{0}{0}{1}$"></li>
<li><em>distCoeffs</em> – The input 4x1, 1x4, 5x1 or 1x5 vector of distortion coefficients <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/796eb1a636b634304dad7fa020666f8bb64ff406.png" alt="$(k_1, k_2, p_1, p_2[, k_3])$">.</li>
<li><em>R</em> – The optional rectification transformation in object space (3x3 matrix). <tt class="docutils literal"><span class="pre">R1</span></tt> or <tt class="docutils literal"><span class="pre">R2</span></tt>, computed by <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#stereorectify"><em>StereoRectify</em></a> can be passed here. If the matrix is NULL, the identity transformation is assumed</li>
<li><em>newCameraMatrix</em> – The new camera matrix <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/8b00ca1160784c09df592a0834ecb85057f61e77.png" alt="$A&#39;=\vecthreethree {f_ x&#39;}{0}{c_ x&#39;}{0}{f_ y&#39;}{c_ y&#39;}{0}{0}{1}$"></li>
<li><em>map1</em> – The first output map of type <tt class="xref docutils literal"><span class="pre">CV_32FC1</span></tt> or <tt class="xref docutils literal"><span class="pre">CV_16SC2</span></tt> - the second variant is more efficient</li>
<li><em>map2</em> – The second output map of type <tt class="xref docutils literal"><span class="pre">CV_32FC1</span></tt> or <tt class="xref docutils literal"><span class="pre">CV_16UC1</span></tt> - the second variant is more efficient</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The function computes the joint undistortion+rectification transformation and represents the result in the form of maps for <a class="reference external" href="http://opencv.willowgarage.com/documentation/geometric_image_transformations.html#remap"><em>Remap</em></a>. The undistorted image will look like the original, as if it was captured with a camera with camera matrix <tt class="docutils literal"><span class="pre">=newCameraMatrix</span></tt> and zero distortion. In the case of monocular camera <tt class="docutils literal"><span class="pre">newCameraMatrix</span></tt> is usually equal to <tt class="docutils literal"><span class="pre">cameraMatrix</span></tt>, or it can be computed by <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#getoptimalnewcameramatrix"><em>GetOptimalNewCameraMatrix</em></a> for a better control over scaling. In the case of stereo camera <tt class="docutils literal"><span class="pre">newCameraMatrix</span></tt> is normally set to <tt class="docutils literal"><span class="pre">P1</span></tt> or <tt class="docutils literal"><span class="pre">P2</span></tt> computed by <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#stereorectify"><em>StereoRectify</em></a>.</p>
<p>Also, this new camera will be oriented differently in the coordinate space, according to <tt class="docutils literal"><span class="pre">R</span></tt>. That, for example, helps to align two heads of a stereo camera so that the epipolar lines on both images become horizontal and have the same y- coordinate (in the case of horizontally aligned stereo camera).</p>
<p>The function actually builds the maps for the inverse mapping algorithm that is used by <a class="reference external" href="http://opencv.willowgarage.com/documentation/geometric_image_transformations.html#remap"><em>Remap</em></a>. That is, for each pixel <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/8f68f58d002a7a00d3685300b8e32abd88a181f8.png" alt="$(u, v)$"> in the destination (corrected and rectified) image the function computes the corresponding coordinates in the source image (i.e. in the original image from camera). The process is the following:</p>
<div class="math">
<p><img src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/1783ac5a277fecf4bd52ae4a1fbf65ac0adf31d3.png" alt="\begin{array}{l} x \leftarrow (u - {c&#39;}_ x)/{f&#39;}_ x \\ y \leftarrow (v - {c&#39;}_ y)/{f&#39;}_ y \\ {[X\, Y\, W]}^ T \leftarrow R^{-1}*[x\, y\, 1]^ T \\ x&#39; \leftarrow X/W \\ y&#39; \leftarrow Y/W \\ x&quot; \leftarrow x&#39; (1 + k_1 r^2 + k_2 r^4 + k_3 r^6) + 2p_1 x&#39; y&#39; + p_2(r^2 + 2 x&#39;^2) \\ y&quot; \leftarrow y&#39; (1 + k_1 r^2 + k_2 r^4 + k_3 r^6) + p_1 (r^2 + 2 y&#39;^2) + 2 p_2 x&#39; y&#39; \\ map_ x(u,v) \leftarrow x&quot; f_ x + c_ x \\ map_ y(u,v) \leftarrow y&quot; f_ y + c_ y \end{array}"></p>
</div><p>where <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/796eb1a636b634304dad7fa020666f8bb64ff406.png" alt="$(k_1, k_2, p_1, p_2[, k_3])$"> are the distortion coefficients.</p>
<p>In the case of a stereo camera this function is called twice, once for each camera head, after <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#stereorectify"><em>StereoRectify</em></a>, which in its turn is called after <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#stereocalibrate"><em>StereoCalibrate</em></a>. But if the stereo camera was not calibrated, it is still possible to compute the rectification transformations directly from the fundamental matrix using <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#stereorectifyuncalibrated"><em>StereoRectifyUncalibrated</em></a>. For each camera the function computes homography <tt class="docutils literal"><span class="pre">H</span></tt> as the rectification transformation in pixel domain, not a rotation matrix <tt class="docutils literal"><span class="pre">R</span></tt> in 3D space. The <tt class="docutils literal"><span class="pre">R</span></tt> can be computed from <tt class="docutils literal"><span class="pre">H</span></tt> as</p>
<div class="math">
<p><img src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/ea0cc153f43723aa14b68b873dbcd66462437a66.png" alt="\texttt{R} = \texttt{cameraMatrix}^{-1} \cdot \texttt{H} \cdot \texttt{cameraMatrix}"></p>
</div><p>where the <tt class="docutils literal"><span class="pre">cameraMatrix</span></tt> can be chosen arbitrarily.</p>
</dd></dl>

</div>
<div class="section" id="posit">
<span id="index-33"></span><span id="id24"></span><h2>POSIT<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#posit" title="Permalink to this headline">¶</a></h2>
<dl class="cfunction">
<dt id="cvPOSIT">
void <tt class="descname">cvPOSIT</tt><big>(</big>CvPOSITObject*<em> posit_object</em>, CvPoint2D32f*<em> imagePoints</em>, double<em> focal_length</em>, CvTermCriteria<em> criteria</em>, CvMatr32f<em> rotationMatrix</em>, CvVect32f<em> translation_vector</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvPOSIT" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the POSIT algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>posit_object</em> – Pointer to the object structure</li>
<li><em>imagePoints</em> – Pointer to the object points projections on the 2D image plane</li>
<li><em>focal_length</em> – Focal length of the camera used</li>
<li><em>criteria</em> – Termination criteria of the iterative POSIT algorithm</li>
<li><em>rotationMatrix</em> – Matrix of rotations</li>
<li><em>translation_vector</em> – Translation vector</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The function implements the POSIT algorithm. Image coordinates are given in a camera-related coordinate system. The focal length may be retrieved using the camera calibration functions. At every iteration of the algorithm a new perspective projection of the estimated pose is computed.</p>
<p>Difference norm between two projections is the maximal distance between corresponding points. The parameter <tt class="docutils literal"><span class="pre">criteria.epsilon</span></tt> serves to stop the algorithm if the difference is small.</p>
</dd></dl>

</div>
<div class="section" id="projectpoints2">
<span id="index-34"></span><span id="id25"></span><h2>ProjectPoints2<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#projectpoints2" title="Permalink to this headline">¶</a></h2>
<p>bgroup({projectPoints})</p>
<dl class="cfunction">
<dt id="cvProjectPoints2">
void <tt class="descname">cvProjectPoints2</tt><big>(</big>const CvMat*<em> objectPoints</em>, const CvMat*<em> rvec</em>, const CvMat*<em> tvec</em>, const CvMat*<em> cameraMatrix</em>, const CvMat*<em> distCoeffs</em>, CvMat*<em> imagePoints</em>, CvMat*<em> dpdrot=NULL</em>, CvMat*<em> dpdt=NULL</em>, CvMat*<em> dpdf=NULL</em>, CvMat*<em> dpdc=NULL</em>, CvMat*<em> dpddist=NULL</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvProjectPoints2" title="Permalink to this definition">¶</a></dt>
<dd><p>Project 3D points on to an image plane.</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>objectPoints</em> – The array of object points, 3xN or Nx3 1-channel or 1xN or Nx1 3-channel , where N is the number of points in the view</li>
<li><em>rvec</em> – The rotation vector, see <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#rodrigues2"><em>Rodrigues2</em></a></li>
<li><em>tvec</em> – The translation vector</li>
<li><em>cameraMatrix</em> – The camera matrix <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/c5bacd037bd83d89b0303f1317692f6140363ff3.png" alt="$A = \vecthreethree {f_ x}{0}{c_ x}{0}{f_ y}{c_ y}{0}{0}{_1} $"></li>
<li><em>distCoeffs</em> – The input 4x1, 1x4, 5x1 or 1x5 vector of distortion coefficients <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/796eb1a636b634304dad7fa020666f8bb64ff406.png" alt="$(k_1, k_2, p_1, p_2[, k_3])$">. If it is NULL, all of the distortion coefficients are considered 0’s</li>
<li><em>imagePoints</em> – The output array of image points, 2xN or Nx2 1-channel or 1xN or Nx1 2-channel</li>
<li><em>dpdrot</em> – Optional 2Nx3 matrix of derivatives of image points with respect to components of the rotation vector</li>
<li><em>dpdt</em> – Optional 2Nx3 matrix of derivatives of image points with respect to components of the translation vector</li>
<li><em>dpdf</em> – Optional 2Nx2 matrix of derivatives of image points with respect to <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/25e0fa5e0f8c5864c5290b69edf98930e055f7ce.png" alt="$f_ x$"> and <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/4dee68490e30bbe4f59304315b89b72ea620f5e2.png" alt="$f_ y$"></li>
<li><em>dpdc</em> – Optional 2Nx2 matrix of derivatives of image points with respect to <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/99c2aa6416f63028f52f45159e5e98d3307bcb81.png" alt="$c_ x$"> and <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/560bb0834286987772bb503a76edca7c4074498f.png" alt="$c_ y$"></li>
<li><em>dpddist</em> – Optional 2Nx4 matrix of derivatives of image points with respect to distortion coefficients</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The function computes projections of 3D points to the image plane given intrinsic and extrinsic camera parameters. Optionally, the function computes jacobians - matrices of partial derivatives of image points coordinates (as functions of all the input parameters) with respect to the particular parameters, intrinsic and/or extrinsic. The jacobians are used during the global optimization in <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#calibratecamera2"><em>CalibrateCamera2</em></a>, <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#findextrinsiccameraparams2"><em>FindExtrinsicCameraParams2</em></a> and <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#stereocalibrate"><em>StereoCalibrate</em></a>. The function itself can also used to compute re-projection error given the current intrinsic and extrinsic parameters.</p>
<p>Note, that by setting <tt class="docutils literal"><span class="pre">rvec=tvec=(0,0,0)</span></tt>, or by setting <tt class="docutils literal"><span class="pre">cameraMatrix</span></tt> to 3x3 identity matrix, or by passing zero distortion coefficients, you can get various useful partial cases of the function, i.e. you can compute the distorted coordinates for a sparse set of points, or apply a perspective transformation (and also compute the derivatives) in the ideal zero-distortion setup etc.</p>
</dd></dl>

</div>
<div class="section" id="reprojectimageto3d">
<span id="index-35"></span><span id="id26"></span><h2>ReprojectImageTo3D<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#reprojectimageto3d" title="Permalink to this headline">¶</a></h2>
<p>bgroup({reprojectImageTo3D})</p>
<dl class="cfunction">
<dt id="cvReprojectImageTo3D">
void <tt class="descname">cvReprojectImageTo3D</tt><big>(</big>const CvArr*<em> disparity</em>, CvArr*<em> _3dImage</em>, const CvMat*<em> Q</em>, int<em> handleMissingValues=0</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvReprojectImageTo3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Reprojects disparity image to 3D space.</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>disparity</em> – The input single-channel 16-bit signed or 32-bit floating-point disparity image</li>
<li><em>_3dImage</em> – The output 3-channel floating-point image of the same size as <tt class="docutils literal"><span class="pre">disparity</span></tt>. Each element of <tt class="docutils literal"><span class="pre">_3dImage(x,y)</span></tt> will contain the 3D coordinates of the point <tt class="docutils literal"><span class="pre">(x,y)</span></tt>, computed from the disparity map.</li>
<li><em>Q</em> – The <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/29719acc3df794f0be41cd7f72bf521040338d1e.png" alt="$4 \times 4$"> perspective transformation matrix that can be obtained with <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#stereorectify"><em>StereoRectify</em></a></li>
<li><em>handleMissingValues</em> – If true, when the pixels with the minimal disparity (that corresponds to the ouliers; see <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#findstereocorrespondencebm"><em>FindStereoCorrespondenceBM</em></a>) will be transformed to 3D points with some very large Z value (currently set to 10000)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The function transforms 1-channel disparity map to 3-channel image representing a 3D surface. That is, for each pixel <tt class="docutils literal"><span class="pre">(x,y)</span></tt> and the corresponding disparity <tt class="docutils literal"><span class="pre">d=disparity(x,y)</span></tt> it computes:</p>
<div class="math">
<p><img src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/354db917902144657db487af3ca4b62b2ffb3c57.png" alt="\begin{array}{l} [X\; Y\; Z\; W]^ T = \texttt{Q}*[x\; y\; \texttt{disparity}(x,y)\; 1]^ T \\ \texttt{\_ 3dImage}(x,y) = (X/W,\; Y/W,\; Z/W) \end{array}"></p>
</div><p>The matrix <tt class="docutils literal"><span class="pre">Q</span></tt> can be arbitrary <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/29719acc3df794f0be41cd7f72bf521040338d1e.png" alt="$4 \times 4$"> matrix, e.g. the one computed by <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#stereorectify"><em>StereoRectify</em></a>. To reproject a sparse set of points bgroup({(x,y,d),...}) to 3D space, use <a class="reference external" href="http://opencv.willowgarage.com/documentation/operations_on_arrays.html#perspectivetransform"><em>PerspectiveTransform</em></a>.</p>
</dd></dl>

</div>
<div class="section" id="rqdecomp3x3">
<span id="index-36"></span><span id="id27"></span><h2>RQDecomp3x3<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#rqdecomp3x3" title="Permalink to this headline">¶</a></h2>
<p>bgroup({RQDecomp3x3})</p>
<dl class="cfunction">
<dt id="cvRQDecomp3x3">
void <tt class="descname">cvRQDecomp3x3</tt><big>(</big>const CvMat<em> *M</em>, CvMat<em> *R</em>, CvMat<em> *Q</em>, CvMat<em> *Qx=NULL</em>, CvMat<em> *Qy=NULL</em>, CvMat<em> *Qz=NULL</em>, CvPoint3D64f<em> *eulerAngles=NULL</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvRQDecomp3x3" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the ‘RQ’ decomposition of 3x3 matrices.</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>M</em> – The 3x3 input matrix</li>
<li><em>R</em> – The output 3x3 upper-triangular matrix</li>
<li><em>Q</em> – The output 3x3 orthogonal matrix</li>
<li><em>Qx</em> – Optional 3x3 rotation matrix around x-axis</li>
<li><em>Qy</em> – Optional 3x3 rotation matrix around y-axis</li>
<li><em>Qz</em> – Optional 3x3 rotation matrix around z-axis</li>
<li><em>eulerAngles</em> – Optional three Euler angles of rotation</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The function computes a RQ decomposition using the given rotations. This function is used in <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#decomposeprojectionmatrix"><em>DecomposeProjectionMatrix</em></a> to decompose the left 3x3 submatrix of a projection matrix into a camera and a rotation matrix.</p>
<p>It optionally returns three rotation matrices, one for each axis, and the three Euler angles  that could be used in OpenGL.</p>
</dd></dl>

</div>
<div class="section" id="releasepositobject">
<span id="index-37"></span><span id="id28"></span><h2>ReleasePOSITObject<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#releasepositobject" title="Permalink to this headline">¶</a></h2>
<dl class="cfunction">
<dt id="cvReleasePOSITObject">
void <tt class="descname">cvReleasePOSITObject</tt><big>(</big>CvPOSITObject**<em> posit_object</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvReleasePOSITObject" title="Permalink to this definition">¶</a></dt>
<dd><p>Deallocates a 3D object structure.</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>posit_object</em> – Double pointer to <tt class="xref docutils literal"><span class="pre">CvPOSIT</span></tt> structure</td>
</tr>
</tbody>
</table>
<p>The function releases memory previously allocated by the function <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#createpositobject"><em>CreatePOSITObject</em></a>.</p>
</dd></dl>

</div>
<div class="section" id="releasestereobmstate">
<span id="index-38"></span><span id="id29"></span><h2>ReleaseStereoBMState<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#releasestereobmstate" title="Permalink to this headline">¶</a></h2>
<dl class="cfunction">
<dt id="cvReleaseStereoBMState">
void <tt class="descname">cvReleaseStereoBMState</tt><big>(</big>CvStereoBMState**<em> state</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvReleaseStereoBMState" title="Permalink to this definition">¶</a></dt>
<dd><p>Releases block matching stereo correspondence structure.</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>state</em> – Double pointer to the released structure.</td>
</tr>
</tbody>
</table>
<p>The function releases the stereo correspondence structure and all the associated internal buffers.</p>
</dd></dl>

</div>
<div class="section" id="releasestereogcstate">
<span id="index-39"></span><span id="id30"></span><h2>ReleaseStereoGCState<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#releasestereogcstate" title="Permalink to this headline">¶</a></h2>
<dl class="cfunction">
<dt id="cvReleaseStereoGCState">
void <tt class="descname">cvReleaseStereoGCState</tt><big>(</big>CvStereoGCState**<em> state</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvReleaseStereoGCState" title="Permalink to this definition">¶</a></dt>
<dd><p>Releases the state structure of the graph cut-based stereo correspondence algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>state</em> – Double pointer to the released structure.</td>
</tr>
</tbody>
</table>
<p>The function releases the stereo correspondence structure and all the associated internal buffers.</p>
</dd></dl>

</div>
<div class="section" id="rodrigues2">
<span id="index-40"></span><span id="id31"></span><h2>Rodrigues2<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#rodrigues2" title="Permalink to this headline">¶</a></h2>
<p>bgroup({Rodrigues})</p>
<dl class="cfunction">
<dt id="cvRodrigues2">
int <tt class="descname">cvRodrigues2</tt><big>(</big>const CvMat*<em> src</em>, CvMat*<em> dst</em>, CvMat*<em> jacobian=0</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvRodrigues2" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a rotation matrix to a rotation vector or vice versa.</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>src</em> – The input rotation vector (3x1 or 1x3) or rotation matrix (3x3)</li>
<li><em>dst</em> – The output rotation matrix (3x3) or rotation vector (3x1 or 1x3), respectively</li>
<li><em>jacobian</em> – Optional output Jacobian matrix, 3x9 or 9x3 - partial derivatives of the output array components with respect to the input array components</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="math">
<p><img src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/d348278803d453bc940ee0049672f182cf5a6c08.png" alt="\begin{array}{l} \theta \leftarrow norm(r)\\ r \leftarrow r/\theta \\ R = \cos {\theta } I + (1-\cos {\theta }) r r^ T + \sin {\theta } \vecthreethree {0}{-r_ z}{r_ y} {r_ z}{0}{-r_ x} {-r_ y}{r_ x}{0} \end{array}"></p>
</div><p>Inverse transformation can also be done easily, since</p>
<div class="math">
<p><img src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/76c27b8e53f9542c847b6a8c81bbfd963b1cb3cf.png" alt="\sin (\theta ) \vecthreethree {0}{-r_ z}{r_ y} {r_ z}{0}{-r_ x} {-r_ y}{r_ x}{0} = \frac{R - R^ T}{2}"></p>
</div><p>A rotation vector is a convenient and most-compact representation of a rotation matrix (since any rotation matrix has just 3 degrees of freedom). The representation is used in the global 3D geometry optimization procedures like <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#calibratecamera2"><em>CalibrateCamera2</em></a>, <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#stereocalibrate"><em>StereoCalibrate</em></a> or <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#findextrinsiccameraparams2"><em>FindExtrinsicCameraParams2</em></a>.</p>
</dd></dl>

</div>
<div class="section" id="stereocalibrate">
<span id="index-41"></span><span id="id32"></span><h2>StereoCalibrate<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#stereocalibrate" title="Permalink to this headline">¶</a></h2>
<p>bgroup({stereoCalibrate})</p>
<dl class="cfunction">
<dt id="cvStereoCalibrate">
double <tt class="descname">cvStereoCalibrate</tt><big>(</big>const CvMat*<em> objectPoints</em>, const CvMat*<em> imagePoints1</em>, const CvMat*<em> imagePoints2</em>, const CvMat*<em> pointCounts</em>, CvMat*<em> cameraMatrix1</em>, CvMat*<em> distCoeffs1</em>, CvMat*<em> cameraMatrix2</em>, CvMat*<em> distCoeffs2</em>, CvSize<em> imageSize</em>, CvMat*<em> R</em>, CvMat*<em> T</em>, CvMat*<em> E=0</em>, CvMat*<em> F=0</em>, CvTermCriteria term_crit=cvTermCriteria(<em> CV_TERMCRIT_ITER+CV_TERMCRIT_EPS</em>, 30, 1e-6), int<em> flags=CV_CALIB_FIX_INTRINSIC</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvStereoCalibrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Calibrates stereo camera.</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>objectPoints</em> – The joint matrix of object points - calibration pattern features in the model coordinate space. It is floating-point 3xN or Nx3 1-channel, or 1xN or Nx1 3-channel array, where N is the total number of points in all views.</li>
<li><em>imagePoints1</em> – The joint matrix of object points projections in the first camera views. It is floating-point 2xN or Nx2 1-channel, or 1xN or Nx1 2-channel array, where N is the total number of points in all views</li>
<li><em>imagePoints2</em> – The joint matrix of object points projections in the second camera views. It is floating-point 2xN or Nx2 1-channel, or 1xN or Nx1 2-channel array, where N is the total number of points in all views</li>
<li><em>pointCounts</em> – Integer 1xM or Mx1 vector (where M is the number of calibration pattern views) containing the number of points in each particular view. The sum of vector elements must match the size of <tt class="docutils literal"><span class="pre">objectPoints</span></tt> and <tt class="docutils literal"><span class="pre">imagePoints*</span></tt> (=N).</li>
<li><em>cameraMatrix1</em> – The input/output first camera matrix: <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/800628f2c04adc7830ce1bc818d813314ff0563c.png" alt="$ \vecthreethree {f_ x^{(j)}}{0}{c_ x^{(j)}}{0}{f_ y^{(j)}}{c_ y^{(j)}}{0}{0}{1}$">, <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/37fd12437115820b76151a574346547652073514.png" alt="$j = 0,\,  1$">. If any of <tt class="xref docutils literal"><span class="pre">CV_CALIB_USE_INTRINSIC_GUESS</span></tt>, <tt class="xref docutils literal"><span class="pre">CV_CALIB_FIX_ASPECT_RATIO</span></tt>, <tt class="xref docutils literal"><span class="pre">CV_CALIB_FIX_INTRINSIC</span></tt> or <tt class="xref docutils literal"><span class="pre">CV_CALIB_FIX_FOCAL_LENGTH</span></tt> are specified, some or all of the matrices’ components must be initialized; see the flags description</li>
<li><em>distCoeffs1</em> – The input/output lens distortion coefficients for the first camera, 4x1, 5x1, 1x4 or 1x5 floating-point vectors <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/bb9e0c5e36c8e46cabc2fc061ac9039865d4d33d.png" alt="$(k_1^{(j)}, k_2^{(j)}, p_1^{(j)}, p_2^{(j)}[, k_3^{(j)}])$">, <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/37fd12437115820b76151a574346547652073514.png" alt="$j = 0,\,  1$">. If any of <tt class="xref docutils literal"><span class="pre">CV_CALIB_FIX_K1</span></tt>, <tt class="xref docutils literal"><span class="pre">CV_CALIB_FIX_K2</span></tt> or <tt class="xref docutils literal"><span class="pre">CV_CALIB_FIX_K3</span></tt> is specified, then the corresponding elements of the distortion coefficients must be initialized.</li>
<li><em>cameraMatrix2</em> – The input/output second camera matrix, as cameraMatrix1.</li>
<li><em>distCoeffs2</em> – The input/output lens distortion coefficients for the second camera, as distCoeffs1.</li>
<li><em>imageSize</em> – Size of the image, used only to initialize intrinsic camera matrix.</li>
<li><em>R</em> – The output rotation matrix between the 1st and the 2nd cameras’ coordinate systems.</li>
<li><em>T</em> – The output translation vector between the cameras’ coordinate systems.</li>
<li><em>E</em> – The optional output essential matrix.</li>
<li><em>F</em> – The optional output fundamental matrix.</li>
<li><em>term_crit</em> – The termination criteria for the iterative optimization algorithm.</li>
<li><em>flags</em> – <p>Different flags, may be 0 or combination of the following values:</p>
<ul>
<li><strong>CV_CALIB_FIX_INTRINSIC</strong> - If it is set, <tt class="docutils literal"><span class="pre">cameraMatrix?</span></tt>, as well as <tt class="docutils literal"><span class="pre">distCoeffs?</span></tt> are fixed, so that only <tt class="docutils literal"><span class="pre">R,</span> <span class="pre">T,</span> <span class="pre">E</span></tt> and <tt class="docutils literal"><span class="pre">F</span></tt> are estimated.</li>
<li><strong>CV_CALIB_USE_INTRINSIC_GUESS</strong> - The flag allows the function to optimize some or all of the intrinsic parameters, depending on the other flags, but the initial values are provided by the user.</li>
<li><strong>CV_CALIB_FIX_PRINCIPAL_POINT</strong> - The principal points are fixed during the optimization.</li>
<li><strong>CV_CALIB_FIX_FOCAL_LENGTH</strong> - <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/dbc5b1ab5728c543224a400b6a76963d9fe7b977.png" alt="$f^{(j)}_ x$"> and <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/94d344c4b00f3970d0fa42274cd4fb6d75cb20df.png" alt="$f^{(j)}_ y$"> are fixed.</li>
<li><strong>CV_CALIB_FIX_ASPECT_RATIO</strong> - <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/94d344c4b00f3970d0fa42274cd4fb6d75cb20df.png" alt="$f^{(j)}_ y$"> is optimized, but the ratio <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/21b463a80ab967b5986472440e3f2dff08af60ff.png" alt="$f^{(j)}_ x/f^{(j)}_ y$"> is fixed.</li>
<li><strong>CV_CALIB_SAME_FOCAL_LENGTH</strong> - Enforces <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/caa8bede7c88f7ccaa20494eb3006f8cf952274f.png" alt="$f^{(0)}_ x=f^{(1)}_ x$"> and <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/b55a258bd79758daf105434650809233bedbb099.png" alt="$f^{(0)}_ y=f^{(1)}_ y$"></li>
<li><strong>CV_CALIB_ZERO_TANGENT_DIST</strong> - Tangential distortion coefficients for each camera are set to zeros and fixed there.</li>
<li><strong>CV_CALIB_FIX_K1, CV_CALIB_FIX_K2, CV_CALIB_FIX_K3</strong> - Fixes the corresponding radial distortion coefficient (the coefficient must be passed to the function)</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The function estimates transformation between the 2 cameras making a stereo pair. If we have a stereo camera, where the relative position and orientatation of the 2 cameras is fixed, and if we computed poses of an object relative to the fist camera and to the second camera, (R1, T1) and (R2, T2), respectively (that can be done with <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#findextrinsiccameraparams2"><em>FindExtrinsicCameraParams2</em></a>), obviously, those poses will relate to each other, i.e. given (<img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/1616b8edeb0e82354a2d38aa8404efedfd60b2be.png" alt="$R_1$">, <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/597297a35abe2d3a8beaf2b7ce1379f22c1e8b33.png" alt="$T_1$">) it should be possible to compute (<img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/0f19a528a2b26a462cc37c40500b55011e1bfd02.png" alt="$R_2$">, <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/9964fed71bedbdd40d8469f50f36048f0e71c6a3.png" alt="$T_2$">) - we only need to know the position and orientation of the 2nd camera relative to the 1st camera. That’s what the described function does. It computes (<img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/5bc30d1e2b7dad3157318e7a90badc4db5414045.png" alt="$R$">, <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/1ad24b93cb7240c6783e7f8d5a896b11324f5d74.png" alt="$T$">) such that:</p>
<div class="math">
<p><img src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/5632dc536f6e99adae315a8cde830ece8a3ed7b0.png" alt="R_2=R*R_1 T_2=R*T_1 + T,"></p>
</div><p>Optionally, it computes the essential matrix E:</p>
<div class="math">
<p><img src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/0bfee564f1a1c196a22ff7dbc028ea6714e3dd7d.png" alt="E= \vecthreethree {0}{-T_2}{T_1} {T_2}{0}{-T_0} {-T_1}{T_0}{0} *R"></p>
</div><p>where <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/bd4d6e6c548b83a095acd9ee95214276ac10efd7.png" alt="$T_ i$"> are components of the translation vector <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/1ad24b93cb7240c6783e7f8d5a896b11324f5d74.png" alt="$T$">: <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/103c252db35112e55c5e691bc4b1ccd0137ce216.png" alt="$T=[T_0, T_1, T_2]^ T$">. And also the function can compute the fundamental matrix F:</p>
<div class="math">
<p><img src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/437d2aeff916cb47765d925b50353e5748a9341c.png" alt="F = cameraMatrix2^{-T} E cameraMatrix1^{-1}"></p>
</div><p>Besides the stereo-related information, the function can also perform full calibration of each of the 2 cameras. However, because of the high dimensionality of the parameter space and noise in the input data the function can diverge from the correct solution. Thus, if intrinsic parameters can be estimated with high accuracy for each of the cameras individually (e.g. using <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#calibratecamera2"><em>CalibrateCamera2</em></a>), it is recommended to do so and then pass <tt class="xref docutils literal"><span class="pre">CV_CALIB_FIX_INTRINSIC</span></tt> flag to the function along with the computed intrinsic parameters. Otherwise, if all the parameters are estimated at once, it makes sense to restrict some parameters, e.g. pass <tt class="xref docutils literal"><span class="pre">CV_CALIB_SAME_FOCAL_LENGTH</span></tt> and <tt class="xref docutils literal"><span class="pre">CV_CALIB_ZERO_TANGENT_DIST</span></tt> flags, which are usually reasonable assumptions.</p>
<p>Similarly to <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#calibratecamera2"><em>CalibrateCamera2</em></a>, the function minimizes the total re-projection error for all the points in all the available views from both cameras. The function returns the final value of the re-projection error.</p>
</dd></dl>

</div>
<div class="section" id="stereorectify">
<span id="index-42"></span><span id="id33"></span><h2>StereoRectify<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#stereorectify" title="Permalink to this headline">¶</a></h2>
<p>bgroup({stereoRectify})</p>
<dl class="cfunction">
<dt id="cvStereoRectify">
void <tt class="descname">cvStereoRectify</tt><big>(</big>const CvMat*<em> cameraMatrix1</em>, const CvMat*<em> cameraMatrix2</em>, const CvMat*<em> distCoeffs1</em>, const CvMat*<em> distCoeffs2</em>, CvSize<em> imageSize</em>, const CvMat*<em> R</em>, const CvMat*<em> T</em>, CvMat*<em> R1</em>, CvMat*<em> R2</em>, CvMat*<em> P1</em>, CvMat*<em> P2</em>, CvMat*<em> Q=0</em>, int<em> flags=CV_CALIB_ZERO_DISPARITY</em>, double<em> alpha=-1</em>, CvSize<em> newImageSize=cvSize(0</em>, 0), CvRect*<em> roi1=0</em>, CvRect*<em> roi2=0</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvStereoRectify" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes rectification transforms for each head of a calibrated stereo camera.</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>cameraMatrix1, cameraMatrix2</em> – The camera matrices <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/6b185aa1f132b027f4f3aad3b6c454162c9c19e8.png" alt="$\vecthreethree {f_ x^{(j)}}{0}{c_ x^{(j)}}{0}{f_ y^{(j)}}{c_ y^{(j)}}{0}{0}{1}$">.</li>
<li><em>distCoeffs1, distCoeffs2</em> – The input distortion coefficients for each camera, <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/bddd6ddff9173492e4bacdc6350c9ecdc7ef0867.png" alt="${k_1}^{(j)}, {k_2}^{(j)}, {p_1}^{(j)}, {p_2}^{(j)} [, {k_3}^{(j)}]$"></li>
<li><em>imageSize</em> – Size of the image used for stereo calibration.</li>
<li><em>R</em> – The rotation matrix between the 1st and the 2nd cameras’ coordinate systems.</li>
<li><em>T</em> – The translation vector between the cameras’ coordinate systems.</li>
<li><em>R1, R2</em> – The output <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/aaad045782e82f999cca0731e7725b165814c62c.png" alt="$3 \times 3$"> rectification transforms (rotation matrices) for the first and the second cameras, respectively.</li>
<li><em>P1, P2</em> – The output <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/07295c56f43d6c9139735629be473b3238587ff8.png" alt="$3 \times 4$"> projection matrices in the new (rectified) coordinate systems.</li>
<li><em>Q</em> – The output <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/29719acc3df794f0be41cd7f72bf521040338d1e.png" alt="$4 \times 4$"> disparity-to-depth mapping matrix, see <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#reprojectimageto3d"><em>ReprojectImageTo3D</em></a>.</li>
<li><em>flags</em> – The operation flags; may be 0 or <tt class="xref docutils literal"><span class="pre">CV_CALIB_ZERO_DISPARITY</span></tt>. If the flag is set, the function makes the principal points of each camera have the same pixel coordinates in the rectified views. And if the flag is not set, the function may still shift the images in horizontal or vertical direction (depending on the orientation of epipolar lines) in order to maximize the useful image area.</li>
<li><em>alpha</em> – The free scaling parameter. If it is -1, the functions performs some default scaling. Otherwise the parameter should be between 0 and 1. <tt class="docutils literal"><span class="pre">alpha=0</span></tt> means that the rectified images will be zoomed and shifted so that only valid pixels are visible (i.e. there will be no black areas after rectification). <tt class="docutils literal"><span class="pre">alpha=1</span></tt> means that the rectified image will be decimated and shifted so that all the pixels from the original images from the cameras are retained in the rectified images, i.e. no source image pixels are lost. Obviously, any intermediate value yields some intermediate result between those two extreme cases.</li>
<li><em>newImageSize</em> – The new image resolution after rectification. The same size should be passed to <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#initundistortrectifymap"><em>InitUndistortRectifyMap</em></a>, see the <tt class="docutils literal"><span class="pre">stereo_calib.cpp</span></tt> sample in OpenCV samples directory. By default, i.e. when (0,0) is passed, it is set to the original <tt class="docutils literal"><span class="pre">imageSize</span></tt>. Setting it to larger value can help you to preserve details in the original image, especially when there is big radial distortion.</li>
<li><em>roi1, roi2</em> – The optional output rectangles inside the rectified images where all the pixels are valid. If <tt class="docutils literal"><span class="pre">alpha=0</span></tt>, the ROIs will cover the whole images, otherwise they likely be smaller, see the picture below</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The function computes the rotation matrices for each camera that (virtually) make both camera image planes the same plane. Consequently, that makes all the epipolar lines parallel and thus simplifies the dense stereo correspondence problem. On input the function takes the matrices computed by <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#stereocalibrate"><em>StereoCalibrate</em></a> and on output it gives 2 rotation matrices and also 2 projection matrices in the new coordinates. The 2 cases are distinguished by the function are:</p>
<ul class="simple">
<li>Horizontal stereo, when 1st and 2nd camera views are shifted relative to each other mainly along the x axis (with possible small vertical shift). Then in the rectified images the corresponding epipolar lines in left and right cameras will be horizontal and have the same y-coordinate. P1 and P2 will look as:</li>
</ul>
<div class="math">
<p><img src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/4e348fc139cd1a70c713f6fdc7b1bca8912d7a72.png" alt="\texttt{P1}= \begin{bmatrix} f &amp; 0 &amp; cx_1 &amp; 0 \\ 0 &amp; f &amp; cy &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix}"></p>
</div><div class="math">
<p><img src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/291e56e61972caa0e8706687a764a52d21e7f1db.png" alt="\texttt{P2}= \begin{bmatrix} f &amp; 0 &amp; cx_2 &amp; T_ x*f \\ 0 &amp; f &amp; cy &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix} ,"></p>
</div><p>where <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/262b73a78c8cafea2e7e6c7a6e30d81488660059.png" alt="$T_ x$"> is horizontal shift between the cameras and <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/f6110c5cd77d2775b426480024037c7b4e185445.png" alt="$cx_1=cx_2$"> if <tt class="xref docutils literal"><span class="pre">CV_CALIB_ZERO_DISPARITY</span></tt> is set.</p>
<ul class="simple">
<li>Vertical stereo, when 1st and 2nd camera views are shifted relative to each other mainly in vertical direction (and probably a bit in the horizontal direction too). Then the epipolar lines in the rectified images will be vertical and have the same x coordinate. P2 and P2 will look as:</li>
</ul>
<div class="math">
<p><img src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/1bfb394a5b6d29baf0b844160198a2aa39856db1.png" alt="\texttt{P1}= \begin{bmatrix} f &amp; 0 &amp; cx &amp; 0 \\ 0 &amp; f &amp; cy_1 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix}"></p>
</div><div class="math">
<p><img src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/6f463ee3debfa426daa2314b62036fce90d94026.png" alt="\texttt{P2}= \begin{bmatrix} f &amp; 0 &amp; cx &amp; 0 \\ 0 &amp; f &amp; cy_2 &amp; T_ y*f \\ 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix} ,"></p>
</div><p>where <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/33b50b406b692ea924441af873c93d9c9fa90f31.png" alt="$T_ y$"> is vertical shift between the cameras and <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/f79f4f48910c03cf4cfe83fc78448dee4be71046.png" alt="$cy_1=cy_2$"> if <tt class="docutils literal"><span class="pre">CALIB_ZERO_DISPARITY</span></tt> is set.</p>
<p>As you can see, the first 3 columns of <tt class="docutils literal"><span class="pre">P1</span></tt> and <tt class="docutils literal"><span class="pre">P2</span></tt> will effectively be the new “rectified” camera matrices. The matrices, together with <tt class="docutils literal"><span class="pre">R1</span></tt> and <tt class="docutils literal"><span class="pre">R2</span></tt>, can then be passed to <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#initundistortrectifymap"><em>InitUndistortRectifyMap</em></a> to initialize the rectification map for each camera.</p>
<p>Below is the screenshot from <tt class="docutils literal"><span class="pre">stereo_calib.cpp</span></tt> sample. Some red horizontal lines, as you can see, pass through the corresponding image regions, i.e. the images are well rectified (which is what most stereo correspondence algorithms rely on). The green rectangles are <tt class="docutils literal"><span class="pre">roi1</span></tt> and <tt class="docutils literal"><span class="pre">roi2</span></tt> - indeed, their interior are all valid pixels.</p>
<img alt="_images/stereo_undistort.jpg" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/stereo_undistort.jpg">
</dd></dl>

</div>
<div class="section" id="stereorectifyuncalibrated">
<span id="index-43"></span><span id="id34"></span><h2>StereoRectifyUncalibrated<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#stereorectifyuncalibrated" title="Permalink to this headline">¶</a></h2>
<p>bgroup({stereoRectifyUncalibrated})</p>
<dl class="cfunction">
<dt id="cvStereoRectifyUncalibrated">
void <tt class="descname">cvStereoRectifyUncalibrated</tt><big>(</big>const CvMat*<em> points1</em>, const CvMat*<em> points2</em>, const CvMat*<em> F</em>, CvSize<em> imageSize</em>, CvMat*<em> H1</em>, CvMat*<em> H2</em>, double<em> threshold=5</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvStereoRectifyUncalibrated" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes rectification transform for uncalibrated stereo camera.</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>points1, points2</em> – The 2 arrays of corresponding 2D points. The same formats as in <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#findfundamentalmat"><em>FindFundamentalMat</em></a> are supported</li>
<li><em>F</em> – The input fundamental matrix. It can be computed from the same set of point pairs using <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#findfundamentalmat"><em>FindFundamentalMat</em></a>.</li>
<li><em>imageSize</em> – Size of the image.</li>
<li><em>H1, H2</em> – The output rectification homography matrices for the first and for the second images.</li>
<li><em>threshold</em> – The optional threshold used to filter out the outliers. If the parameter is greater than zero, then all the point pairs that do not comply the epipolar geometry well enough (that is, the points for which <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/87463e9332de23347307d03866dae5746fd70564.png" alt="$|\texttt{points2[i]}^ T*\texttt{F}*\texttt{points1[i]}|&gt;\texttt{threshold}$">) are rejected prior to computing the homographies. Otherwise all the points are considered inliers.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The function computes the rectification transformations without knowing intrinsic parameters of the cameras and their relative position in space, hence the suffix “Uncalibrated”. Another related difference from <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#stereorectify"><em>StereoRectify</em></a> is that the function outputs not the rectification transformations in the object (3D) space, but the planar perspective transformations, encoded by the homography matrices <tt class="docutils literal"><span class="pre">H1</span></tt> and <tt class="docutils literal"><span class="pre">H2</span></tt>. The function implements the algorithm .</p>
<p>Note that while the algorithm does not need to know the intrinsic parameters of the cameras, it heavily depends on the epipolar geometry. Therefore, if the camera lenses have significant distortion, it would better be corrected before computing the fundamental matrix and calling this function. For example, distortion coefficients can be estimated for each head of stereo camera separately by using <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#calibratecamera2"><em>CalibrateCamera2</em></a> and then the images can be corrected using <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#undistort2"><em>Undistort2</em></a>, or just the point coordinates can be corrected with <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#undistortpoints"><em>UndistortPoints</em></a>.</p>
</dd></dl>

</div>
<div class="section" id="undistort2">
<span id="index-44"></span><span id="id35"></span><h2>Undistort2<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#undistort2" title="Permalink to this headline">¶</a></h2>
<p>bgroup({undistort})</p>
<dl class="cfunction">
<dt id="cvUndistort2">
void <tt class="descname">cvUndistort2</tt><big>(</big>const CvArr*<em> src</em>, CvArr*<em> dst</em>, const CvMat*<em> cameraMatrix</em>, const CvMat*<em> distCoeffs</em>, const CvMat*<em> newCameraMatrix=0</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvUndistort2" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms an image to compensate for lens distortion.</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>src</em> – The input (distorted) image</li>
<li><em>dst</em> – The output (corrected) image; will have the same size and the same type as <tt class="docutils literal"><span class="pre">src</span></tt></li>
<li><em>cameraMatrix</em> – The input camera matrix <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/bf26117021654056987b67b9200875d224c6b49e.png" alt="$A = \vecthreethree {f_ x}{0}{c_ x}{0}{f_ y}{c_ y}{0}{0}{1} $"></li>
<li><em>distCoeffs</em> – The vector of distortion coefficients, <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/bb9e0c5e36c8e46cabc2fc061ac9039865d4d33d.png" alt="$(k_1^{(j)}, k_2^{(j)}, p_1^{(j)}, p_2^{(j)}[, k_3^{(j)}])$"></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The function transforms the image to compensate radial and tangential lens distortion.</p>
<p>The function is simply a combination of <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#initundistortrectifymap"><em>InitUndistortRectifyMap</em></a> (with unity <tt class="docutils literal"><span class="pre">R</span></tt>) and <a class="reference external" href="http://opencv.willowgarage.com/documentation/geometric_image_transformations.html#remap"><em>Remap</em></a> (with bilinear interpolation). See the former function for details of the transformation being performed.</p>
<p>Those pixels in the destination image, for which there is no correspondent pixels in the source image, are filled with 0’s (black color).</p>
<p>The particular subset of the source image that will be visible in the corrected image can be regulated by <tt class="docutils literal"><span class="pre">newCameraMatrix</span></tt>. You can use <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#getoptimalnewcameramatrix"><em>GetOptimalNewCameraMatrix</em></a> to compute the appropriate <tt class="docutils literal"><span class="pre">newCameraMatrix</span></tt>, depending on your requirements.</p>
<p>The camera matrix and the distortion parameters can be determined using <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#calibratecamera2"><em>CalibrateCamera2</em></a>. If the resolution of images is different from the used at the calibration stage, <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/03d42049b8274d6157f510eec54a8265f1d0a443.png" alt="$f_ x, f_ y, c_ x$"> and <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/560bb0834286987772bb503a76edca7c4074498f.png" alt="$c_ y$"> need to be scaled accordingly, while the distortion coefficients remain the same.</p>
</dd></dl>

</div>
<div class="section" id="undistortpoints">
<span id="index-45"></span><span id="id36"></span><h2>UndistortPoints<a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#undistortpoints" title="Permalink to this headline">¶</a></h2>
<p>bgroup({undistortPoints})</p>
<dl class="cfunction">
<dt id="cvUndistortPoints">
void <tt class="descname">cvUndistortPoints</tt><big>(</big>const CvMat*<em> src</em>, CvMat*<em> dst</em>, const CvMat*<em> cameraMatrix</em>, const CvMat*<em> distCoeffs</em>, const CvMat*<em> R=NULL</em>, const CvMat*<em> P=NULL</em><big>)</big><a class="headerlink" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvUndistortPoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the ideal point coordinates from the observed point coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>src</em> – The observed point coordinates, same format as <tt class="docutils literal"><span class="pre">imagePoints</span></tt> in <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#projectpoints2"><em>ProjectPoints2</em></a></li>
<li><em>dst</em> – The output ideal point coordinates, after undistortion and reverse perspective transformation, same format as <tt class="docutils literal"><span class="pre">src</span></tt>.</li>
<li><em>cameraMatrix</em> – The camera matrix <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/dc2cefeb8487ccfbad752796b15e813f13ae5535.png" alt="$\vecthreethree {f_ x}{0}{c_ x}{0}{f_ y}{c_ y}{0}{0}{1}$"></li>
<li><em>distCoeffs</em> – The vector of distortion coefficients, <img class="math" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/bb9e0c5e36c8e46cabc2fc061ac9039865d4d33d.png" alt="$(k_1^{(j)}, k_2^{(j)}, p_1^{(j)}, p_2^{(j)}[, k_3^{(j)}])$"></li>
<li><em>R</em> – The rectification transformation in object space (3x3 matrix). <tt class="docutils literal"><span class="pre">R1</span></tt> or <tt class="docutils literal"><span class="pre">R2</span></tt>, computed by <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#stereorectify"><em>StereoRectify</em></a> can be passed here. If the matrix is empty, the identity transformation is used</li>
<li><em>P</em> – The new camera matrix (3x3) or the new projection matrix (3x4). <tt class="docutils literal"><span class="pre">P1</span></tt> or <tt class="docutils literal"><span class="pre">P2</span></tt>, computed by <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#stereorectify"><em>StereoRectify</em></a> can be passed here. If the matrix is empty, the identity new camera matrix is used</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The function is similar to <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#undistort2"><em>Undistort2</em></a> and <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#initundistortrectifymap"><em>InitUndistortRectifyMap</em></a>, but it operates on a sparse set of points instead of a raster image. Also the function does some kind of reverse transformation to <a class="reference internal" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#projectpoints2"><em>ProjectPoints2</em></a> (in the case of 3D object it will not reconstruct its 3D coordinates, of course; but for a planar object it will, up to a translation vector, if the proper <tt class="docutils literal"><span class="pre">R</span></tt> is specified).</p>
<blockquote>
<div class="highlight-c"><pre>// (u,v) is the input point, (u', v') is the output point
// camera_matrix=[fx 0 cx; 0 fy cy; 0 0 1]
// P=[fx' 0 cx' tx; 0 fy' cy' ty; 0 0 1 tz]
x" = (u - cx)/fx
y" = (v - cy)/fy
(x',y') = undistort(x",y",dist_coeffs)
[X,Y,W]T = R*[x' y' 1]T
x = X/W, y = Y/W
u' = x*fx' + cx'
v' = y*fy' + cy',</pre>
</div>
</blockquote>
<p>where undistort() is approximate iterative algorithm that estimates the normalized original point coordinates out of the normalized distorted point coordinates (“normalized” means that the coordinates do not depend on the camera matrix).</p>
<p>The function can be used both for a stereo camera head or for monocular camera (when R is NULL).</p>
</dd></dl>

</div>
</div>


          </div>
          <div class="feedback">
              <h2>Help and Feedback</h2>
              You did not find what you were looking for?
              <ul>
                  <li>Try the <a href="http://opencv.willowgarage.com/documentation/faq.html">FAQ</a>.</li>
                  <li>Ask a question in the <a href="http://tech.groups.yahoo.com/group/OpenCV/">user group/mailing list</a>.</li>
                  <li>If you think something is missing or wrong in the documentation,
                  please file a <a href="http://sourceforge.net/tracker/?func=add&group_id=22870&atid=376677">bug report</a>.</li>
              </ul>
          </div>
        </div>
      </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="http://opencv.willowgarage.com/documentation/index.html">
              <img class="logo" src="./Camera Calibration and 3D Reconstruction — OpenCV 2.0 C Reference_files/opencv-logo2.png" alt="Logo">
            </a></p>
            <h3><a href="http://opencv.willowgarage.com/documentation/index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#">Camera Calibration and 3D Reconstruction</a><ul>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#calcimagehomography">CalcImageHomography</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#calibratecamera2">CalibrateCamera2</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#computecorrespondepilines">ComputeCorrespondEpilines</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#convertpointshomogeneous">ConvertPointsHomogeneous</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#createpositobject">CreatePOSITObject</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#createstereobmstate">CreateStereoBMState</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#createstereogcstate">CreateStereoGCState</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvstereobmstate">CvStereoBMState</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#cvstereogcstate">CvStereoGCState</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#decomposeprojectionmatrix">DecomposeProjectionMatrix</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#drawchessboardcorners">DrawChessboardCorners</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#findchessboardcorners">FindChessboardCorners</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#findextrinsiccameraparams2">FindExtrinsicCameraParams2</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#findfundamentalmat">FindFundamentalMat</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#findhomography">FindHomography</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#findstereocorrespondencebm">FindStereoCorrespondenceBM</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#findstereocorrespondencegc">FindStereoCorrespondenceGC</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#getoptimalnewcameramatrix">GetOptimalNewCameraMatrix</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#initintrinsicparams2d">InitIntrinsicParams2D</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#initundistortmap">InitUndistortMap</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#initundistortrectifymap">InitUndistortRectifyMap</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#posit">POSIT</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#projectpoints2">ProjectPoints2</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#reprojectimageto3d">ReprojectImageTo3D</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#rqdecomp3x3">RQDecomp3x3</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#releasepositobject">ReleasePOSITObject</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#releasestereobmstate">ReleaseStereoBMState</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#releasestereogcstate">ReleaseStereoGCState</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#rodrigues2">Rodrigues2</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#stereocalibrate">StereoCalibrate</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#stereorectify">StereoRectify</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#stereorectifyuncalibrated">StereoRectifyUncalibrated</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#undistort2">Undistort2</a></li>
<li><a class="reference external" href="http://opencv.willowgarage.com/documentation/camera_calibration_and_3d_reconstruction.html#undistortpoints">UndistortPoints</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="http://opencv.willowgarage.com/documentation/object_detection.html" title="previous chapter">Object Detection</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="http://opencv.willowgarage.com/documentation/highgui._high-level_gui_and_media_io.html" title="next chapter">highgui. High-level GUI and Media IO</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="http://opencv.willowgarage.com/documentation/_sources/camera_calibration_and_3d_reconstruction.txt" rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="">
            <h3>Quick search</h3>
              <form class="search" action="http://opencv.willowgarage.com/documentation/search.html" method="get">
                <input type="text" name="q" size="18">
                <input type="submit" value="Go">
                <input type="hidden" name="check_keywords" value="yes">
                <input type="hidden" name="area" value="default">
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="http://opencv.willowgarage.com/documentation/genindex.html" title="General Index">index</a></li>
        <li class="right">
          <a href="http://opencv.willowgarage.com/documentation/highgui._high-level_gui_and_media_io.html" title="highgui. High-level GUI and Media IO">next</a> |</li>
        <li class="right">
          <a href="http://opencv.willowgarage.com/documentation/object_detection.html" title="Object Detection">previous</a> |</li>
        <li><a href="http://opencv.willowgarage.com/documentation/index.html">OpenCV 2.0 C Reference</a> »</li>
          <li><a href="http://opencv.willowgarage.com/documentation/cv._image_processing_and_computer_vision.html">cv. Image Processing and Computer Vision</a> »</li> 
      </ul>
    </div>
    <div class="footer">
      © Copyright 2009, authors.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.4.
    </div>
  
</body></html>