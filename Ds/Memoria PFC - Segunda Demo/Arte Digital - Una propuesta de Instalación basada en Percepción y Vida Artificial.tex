% Definimos el estilo del documento
\documentclass[12pt,A4,spanish]{book}

% Definimos los márgenes de la página
\usepackage[lmargin=2.5cm,rmargin=1.5cm,tmargin=3.0cm,bmargin=3.0cm]{geometry}

% Utilizamos el paquete para utilizar español
\usepackage[spanish]{babel}

% Utilizamos el paquete para gestionar acentos
\usepackage[latin1]{inputenc}

%Utilizamos el paquete para inluir imágenes jpg
\usepackage{graphicx}

%Para evitar problemas de imágenes flotantes
\usepackage{float}

%Utilizamos el paquete para incorporar graficos postcript
%\usepackage[dvips,final]{epsfig}

%utilizamos paquete para introducir cuadros de código
%\usepackage[utf8]{inputenc}
%\usepackage[T1]{fontenc}
\usepackage{listings}
%\usepackage{times}
\usepackage{color}

\definecolor{gray97}{gray}{.97}
\definecolor{gray75}{gray}{.75}
\definecolor{gray45}{gray}{.45}
 

\lstset{ frame=Ltb,
     framerule=0pt,
     aboveskip=0.5cm,
     framextopmargin=3pt,
     framexbottommargin=3pt,
     framexleftmargin=0.4cm,
     framesep=0pt,
     rulesep=.4pt,
     backgroundcolor=\color{gray97},
     rulesepcolor=\color{black},
     %
     stringstyle=\ttfamily,
     showstringspaces = false,
     basicstyle=\small\ttfamily,
     commentstyle=\color{gray45},
     keywordstyle=\bfseries,
     %
     numbers=left,
     numbersep=15pt,
     numberstyle=\tiny,
     numberfirstline = false,
     breaklines=true,
   }
 
% minimizar fragmentado de listados
\lstnewenvironment{listing}[1][]
   {\lstset{#1}\pagebreak[0]}{\pagebreak[0]}
 
\lstdefinestyle{consola}
   {basicstyle=\scriptsize\bf\ttfamily,
    backgroundcolor=\color{gray75},
   }
 
\lstdefinestyle{C++}
   {language=C++,
   } 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\setcounter{tocdepth}{3}

%Empieza el documento
\begin{document}

% Definimos titulo, autor, fecha, generamos titulo e indice de contenidos
\title{ARTE DIGITAL: UNA PROPUESTA DE INSTALACIÓN BASADA EN TÉCNICAS DE PERCEPCIÓN Y VIDA ARTIFICIAL MEDIANTE LA CREACIÓN DE UN SDK PARA INSTALACIONES GENÉRICO}
\author{Antonio José Sánchez López}
\date{Facultad de Informática.\\
Universidad de Las Palmas de G.C.}

\thispagestyle{empty}
\maketitle

%Definimos página posterior a la portada 
\thispagestyle{empty}
\noindent Facultad de Informática. Universidad de Las Palmas de G.C.

% Definimos página con datos sobre el proyecto 
\newpage
\thispagestyle{empty}
\section*{Proyecto fin de carrera}

\bigskip
\noindent {\bf Título: } Arte Digital: Una Propuesta de Instalación basada en Percepción y Vida Artificial\\
{\bf Apellidos y nombre del alumno: } Sánchez López, Antonio José\\
{\bf Fecha : } Octubre 2011 \\

\vspace{2cm}
\noindent{\bf Tutor: } Castrillón Santana, Modesto \\

% Definimos página posterior 
\newpage
\thispagestyle{empty}
\noindent Facultad de Informática. Universidad de Las Palmas de G.C.
\newpage

% Definimos una  pagina para los agradecimientos
\newpage
\thispagestyle{empty}
\section*{Agradecimientos}
 Aquí ponemos los agradecimientos

% Definimos página posterior 
\newpage
\thispagestyle{empty}
\noindent Facultad de Informática. Universidad de Las Palmas de G.C.
\newpage
\setcounter{page}{1}
\tableofcontents

% Definimos página posterior 
\newpage
\thispagestyle{empty}
\noindent Facultad de Informática. Universidad de Las Palmas de G.C.
\newpage

% Empezamos capitulos


\chapter{Introducci\'on}

 La introducción es lo primero que se lee, pero habitualmente lo último que se escribe. Pues su redacción
 depende de cómo se hayan escrito todas las otras secciones. Normalmente la introducción incluye una
 descripción muy general del proyecto y termina con un desglose del contenido de la memoria.

A lo largo de la historia, diversas disciplinas han hecho uso de la representación bidimensional para mostrar propuestas creativas. El ordenador es en la actualidad una herramienta de enorme potencial para el arte visual \cite{Spalter99}, tanto en el marco de la imagen estática, como en el contexto donde el factor tiempo se introduce en el proceso expresivo.
\\

Las imágenes son fácilmente comprendidas por los humanos, motivo por el cual es un ámbito válido de trabajo creativo. Por otro lado, esa diversidad posible en una imagen ocupa también a multitud de científicos del campo de la Visión por Computador en su búsqueda de técnicas para detectar y reconocer objetos en ese espacio de representación: la imagen. Espacio donde un humano reconoce objetos conocidos con gran facilidad.
\\

Desde el punto de vista de la imagen estática, una imagen es una matriz de píxeles que representan un punto en un espacio de muy alta dimensionalidad. La tecnología digital en este contexto, presenta la singularidad de la no existencia de un original único, el arte digital permite disponer del original en cualquier parte, éste es copiable hasta la saciedad sin pérdida. Adicionalmente, nuevos ámbitos tecnológicos han ido abriendo capacidades y posibilidades expresivas. Las tecnologías del vídeo digital y la animación introducen el factor tiempo en el proceso expresivo, la mutabilidad, la fugacidad y la narrativa temporal. La introducción de la interactividad a través del uso de las tecnologías de visión por computador aporta un nuevo canal expresivo y unas posibilidades para la generación de sensaciones a través de los conceptos de obra viva e interactiva, tal y como ya describiera Krueger en su concepto de Realidad Artificial \cite{Krueger85}. 
\\

La obra se puede convertir así en única y cambiante, reactiva a la interacción con su entorno en cada momento. Recupera el concepto de exclusividad, siendo además posible registrar la vida de la instalación. Este enfoque se relaciona de forma clara con el concepto de instalación manejado en el mundo artístico una obra es instalación si dialoga con el espacio que la circunda \cite{Iges99}. 
\\

La motivación de este proyecto es investigar el uso de capacidades actuales de Visión por Computador y Vida Artificial para su integración en instalaciones artísticas. Hay que destacar que nuestra experiencia se relaciona fundamentalmente con el mundo tecnológico, por tanto, no es nuestro objetivo presentar una obra de creación, sino mostrar las posibilidades interactivas que la Inteligencia Artificial puede introducir en el arte, yendo más allá de aplicaciones básicas en visión de segmentación de figura y fondo en contextos restringidos como en Messa di voce \cite{Levin04}, y abordando el contexto de detección de personas y vida artificial. 
\\

La exploración puede plantear y profundizar en nuevas posibilidades de interfaces y formas de interacción hombre-máquina.
\\

Abordar cuando tenga paciencia para repasar documentación y referencias e inspiración para escribir bonito... 
\chapter{Estado actual del tema}
 Descripción del estado actual del tema con referencia a trabajos anteriores en el caso de proyectos que
 sean continuación o relacionados con otros proyectos.
\\
 
Abordar cuando tenga paciencia para repasar documentación y referencias e inspiración para escribir bonito... 

\chapter{Metodología}
 Metodología a utilizar para el desarrollo del proyecto, herramientas de análisis, etc..
\\ 
Las Metodologías de Desarrollo Ágiles son un marco de trabajo conceptual de la ingeniería del software que propone realizar iteraciones de las distintas fases a lo largo del desarrollo. Cada metodología introduce sus propias definiciones, pero en conjunto reflejan siguientes fases: Planificación, Análisis de Requerimientos, Diseño, Codificación, Revisión y Documentación. Una iteración no agrega demasiada funcionalidad en relación al producto final, pero permite tener una demo de la misma al final de cada iteración, momento en el que se evalúa de nuevo las prioridades del proyecto. Así se consigue un producto que podrá probarse desde las primeras semanas al que ir añadiendo funcionalidades \cite{RCol09}. 
\\

La fortaleza del desarrollo ágil se centra en minimizar los riesgos desarrollando software en lapsos cortos y en su capacidad de respuesta al cambio, enfatizando el software funcional como objetivo y promoviendo las comunicaciones eficientes. \cite{KenB01}
\\

En nuestro caso concreto se ha decidido utilizar como metodología ágil el Proceso Unificado Esencial (Essential Unified Process - EssUP), creado por Invar Jacobson \cite{IJacobson09}. EssUp plantea un conjunto de nueve prácticas ligeras y compatibles, que pueden adoptarse de forma individual o combinadas según las necesidades de un proyecto en cuestión. Estas prácticas son: Definición de Casos de Uso, Definición de Iteración, Definición de Arquitectura, Definición de Componente, Definición de Modelo, Definición de Producto, Definición de Proceso, Definición de Equipo y Definición del Proceso Unificado.

%\begin{itemize}
%\item Definición de Casos de Uso
%\item Definición de Iteración
%\item Definición de Arquitectura
%\item Definición de Componente
%\item Definición de Modelo
%\item Definición de Producto
%\item Definición de Proceso
%\item Definición de Equipo
%\item Definición del Proceso Unificado
%\end{itemize}

Para el desarrollo de la aplicación se hará uso de los apartados necesarios en cada fase del proyecto. Invar Jacobson también ofrece software enfocado al seguimiento de estas tareas de forma gratuita. Estas herramientas son:

\begin{itemize}
\item EssWork: Herramienta para el desarrollo de software orientado a la práctica que combina tareas para un trabajo flexible, con coherencia y efectivo. 
\item Essential Modeler: Herramienta visual que permite crear diagramas de casos de uso UML y modelos de clases.
\end{itemize}

Finalmente, para el caso del Diseño de la Base de Datos cabe destacar que se usará el modelo de Diagramas de Entidad-Interrelación, que se continuará con un proceso de transformación mediante Diseño Relacional para obtener finalmente la Base de Datos.

\chapter{Recursos necesarios}
 Se detallan los recursos hardware, software u otros necesarios para el desarrollo del proyecto, incluyendo desde las aplicaciones necesarias así como librerías a utilizar y requerimientos hardware.
\\
\subsection{Software}

\begin{itemize}

\item Aplicaciones:
\begin{itemize}
\item TexMaker: Editor de LaTex.
\item EssWork: Editor de modelos de Casos de Uso.
\item Essential Modeler: Para el seguimiento y orientación de la metodología EssUp.
\item Dia: Para modelado de diagramas UML y Entidad-Interrelación.
\item Visual Studio 2008 Express Edition: Entorno de desarrollo.
\item Blender: Programa de edición 3D.
\item Gimp: Programa de edición 2D.
\item HeidiSQL: Front-end de MySQL.
\end{itemize}

\item Librerías:
\begin{itemize}
\item De Visión por Computador: OpenCV.
\item Motor gráfico: Se estudiarán UDK, CryEngine 3 ESDK, Crystal Space, OpenSceneGraph, Ogre, Irrlicht y Panda3D.
\item Interfaz gráfica de usuario: se estudiarán Qt y wxWidgets.
\item Para captura de audio y reproducción 3D se estudiará las capacidades del motor gráfico o de juego a usar, así como Fmod, OpenAL, SDL Mixer, Clunk, Irrklang y SFML.
\item Para composición de audio: Se estudiarán Chuck y Marsyas.
\item De sistema: Boost y SFML.
\item BBDD: MySQL, PostGreSQL.
\item De documentación: Doxygen.
\end{itemize}

\item Recursos:
\begin{itemize}
\item Imágenes: GCTextures.
\item Sonidos: wiki.laptop.org,go,Soundsamples; Jamendo.
\end{itemize}

\end{itemize}

\subsection{Hardware}
\begin{itemize}

\item Primera aproximación:
\begin{itemize}
\item Entorno controlado: fondo estático, buena iluminación, sin ruido ambiente.
\item 1 PC con: 1 Monitor/Proyector, 1 cámara, micrófono y altavoces sonido envolvente.
\end{itemize}

\item Segunda aproximación:
\begin{itemize}
\item Entorno controlado: fondo estático, buena iluminación, sin ruido ambiente, mobiliario.
\item 1 PC con: 1 Monitor/Proyector, 2 cámaras, micrófono y altavoces sonido envolvente.
\end{itemize}

\item-Tercera aproximación:
\begin{itemize}
\item Entorno controlado: fondo estático, buena iluminación, sin ruido ambiente, mobiliario.
\item 1 PC con: 2 Monitores/Proyectores, 2 cámaras, micrófono y altavoces sonido envolvente.
\end{itemize}

\item Cuarta aproximación:
\begin{itemize}
\item Entorno controlado: fondo estático, buena iluminación, sin ruido ambiente, mobiliario.
\item Varios PCs con: 2 Monitores/Proyectores, 2 cámaras, micrófono y altavoces sonido envolvente.
\end{itemize}

\end{itemize}


\chapter{Plan de trabajo y temporización}
Desarrollo del plan de trabajo desglosado en etapas, con una estimación en cada etapa del tiempo de ejecución
\begin{itemize}
\item Etapa 1: Acercamiento
\item Etapa 2: Primera Demo
\item Etapa 3: Funcionalidades Añadidas
\item Etapa 3+i: Funcionalidades Añadidas
\item Etapa n: Revisión Final
\item Etapa n+1: Publicidad
\end{itemize}

\begin{figure} [h]
\begin{center}
\includegraphics[width=\textwidth]{recursos_memoria/planificacion.png}
\end{center}
\caption{ \label{Temporizacion} Plan de trabajo y temporización}
\end{figure}

A continuación vendrán las secciones donde se desarrollan cada una de las etapas del proyecto


\chapter{Etapa 1: Acercamiento}

En esta fase se llevará a cabo la primera aproximación a la solución que se va adoptar. Para ello se hará un estudio global de las capacidades de las que se desea dotar a la aplicación, que pretende ser completo aunque no en profundidad. También se hará una búsqueda y estudio de las herramientas disponibles que puedan ofrecer las funcionalidades necesarias para la construcción del proyecto.

En las siguientes fases/iteraciones se abordarán y trabajará en profundidad un subconjunto de cada apartado con el objetivo de conseguir demos intermedias que sean funcionales.

\section{Análisis}

\subsection{Documentación y herramientas}
  Existe un conjunto de librerías bastante amplio que puede ser de utilidad en el desarrollo del proyecto. A continuación se hace una revisión de las mismas con el fin de elegir las que mejor se adapten a las necesidades del proyecto. Finalmente se elegirán las más adecuadas.
\\

(RECORDAR AÑADIR LA FEATURE-LIST DE LOS DISTINTOS MOTORES - copy paste en forma de tablas bonitas)

\subsubsection {UDK: Unreal Development Kit}
  A noviembre de 2009, el motor gráfico Unreal3, desarrollado por Epic Games, es considerado uno de los más potentes y de mayor calidad junto con el motor CryEngine de Crytek. A mediados del mismo mes Epic Games decide liberar UDK, su kit de desarrollo para proyectos sin ánimo de lucro, además de ofrecer licencias más asequibles para proyectos comerciales. Inicialmente el coste de una licencia para Unreal3 oscilaba alrededor los \$700.000.  Esta nueva situación hace posible tomarlo en consideración para el desarrollo de la aplicación que tratamos, por lo que se procede a su estudio. Es interesante comentar que Epic Games ya trabaja en la cuarta de versión de su motor, Unreal4, que planea estar disponible a partir de 2012~-2018.
\\

Algunas de las compañías que han usado Unreal 3 son: Atari, Activision, Capcom, Disney, Konami, Koei, 2K Games, Midway, THQ, Ubisoft, Sega, Sony, Electronic Arts, Square Enix y 3D Realms. Entre los ejemplos más destacados se encuentran las series BioShock o Gears of War, entre otros juegos como Medal of Honor: Airbone y Unreal Tournament 3.
\\

Sin duda, los resultados que pueden verse en las imágenes corresponden a proyectos de grandes compañías que disponen de una importante cantidad de recursos. Como muestra visual más razonable se encuentra uno de los juegos de ejemplo que puede encontrarse en la página oficial del UDK, Whizzle.
\\

Al ser un kit de desarrollo completo su lista de capacidades es muy extensa. En la siguiente tabla se muestra un resumen de su lista de capacidades de render:
\\

Finalmente, se exponen algunas de las características clave para la toma de decisión:
\\
\begin{itemize}
\item UDK es un kit de desarrollo software que ofrece un entorno completo para el desarrollo de videojuegos o aplicaciones similares. 
\item Está implementado con C++.
\item Aunque el motor Unreal3 es multiplataforma, UDK sólo está disponible para los Sistemas Operativos Windows por ahora.
\item El desarrollo de una aplicación en UDK puede realizarse en gran medida de forma visual a través de las opciones de la interfaz del entorno o escribiendo código en el lenguaje propio UnrealScript, similar a C++.
\item El código escrito en UnrealScript se ejecuta sobre una máquina virtual propia.
\item La máquina virtual de UnrealScript simula ejecución multihilos. Destacan que permiten la gestión de grandes cantidades de hilos, cantidad que hecho de otra forma, con el sistema de hilos nativo de Windows, podría provocar problemas.
\item La ejecución de código UnrealScript es mucho más lento que C++. Detallan que el código en C++ es 20x más rápido.
\item No se tiene acceso al código fuente del motor.
\item La interacción con otro tipo de código en tiempo de ejecución debe hacerse a través de ficheros (.ini) que pueda leer UnrealScript, modificando o implementando controladores de periféricos, o a través de conexiones TCP/UDP. Este punto dificulta en gran medida la interacción con otras librerías necesarias para el desarrollo del proyecto.
\item Es gratis para uso no comercial. En proyectos comerciales es necesario abonar una licencia y un porcentaje de las ventas en concepto de royalties que puede llegar al 25\% para ingresos superiores a 5000 euros.
\end{itemize}
Las capacidades del motor gráfico son sobresalientes. Sin embargo, el esquema de desarrollo con UDK no se ajusta adecuadamente al del  resto de la aplicación.

\subsubsection{CryENGINE 3 Educational SDK}

Como era de esperar, poco después de la salida del Unreal Development Kit por parte de Epic Games, otro de los grandes motores gráficos comerciales lanzó su propia alternativa. Se trata en este caso del motor CryENGINE 3, de Crytek, con su propio kit de desarrollo con licencia gratuita. Sin embargo, hay que destacar que los términos de la misma son mucho menos flexibles que la de Epic Games y enfocado sólo hacia un sector. El SDK sólo está disponible para instituciones académicas por parte de jefes de curso, exclusivamente para proyectos de naturaleza interna y con fines no comerciales. Se excluye específicamente el caso de estudiantes individuales o proyectos de grupo. Además, los términos de la licencia en sí no son públicos y sólo son accesibles para personal académico previa solicitud. 
\\

Por ahora el único juego que parece usar este motor es Crysis 2, actualmente en desarrollo por Crytek. 
\\

Aunque una alternativa más limitada, en términos de licencia de uso, y en contradicción con algunos puntos de la naturaleza del proyecto, como es el uso de software gratuito y en la medida de lo posible libre, podría ser una alternativa a tener en cuenta y se procede a su análisis. 
\\

En la siguiente tabla se muestra un resumen de su lista de capacidades de render:
\\

Finalmente, se exponen algunas de las características clave para la toma de decisión:

\begin{itemize}
\item Licencia de uso muy restrictiva. Sólo para proyectos académicos no comerciales y no puede ser solicitada por estudiantes individualmente. Continuidad del proyecto también limitada.
\end{itemize}

\subsubsection{Crystal Space}
Crystal Space es un entorno de desarrollo comúnmente usado con motor de juego. Está escrito en C++ usando un modelo Orientado a Objetos y soporta las principales plataformas. El SDK se distribuye bajo licencia LGPL, por lo que puede utilizarse de forma gratuita para cualquier tipo de desarrollo. Durante mucho tiempo se le ha considerado como uno de los motores libres más completos y populares, ya que no sólo es un motor de render sino un motor de juego, que incluye distintos módulos que facilitan el desarrollo.
\\

Algunos ejemplos de uso son PlaneShift, El Hierro Virtual (ULPGC) y el reciente Yo Frankie! (Apricot Open Game Project).

\begin{itemize}
\item Relación estrecha con Blender, entorno de diseño 3D y de desarrollo de videojuegos con el que se dispone de cierta experiencia.
\item Complejidad alta y relativamente abandonado, pasando largos períodos de tiempo entre revisiones.
\item Nueva versión del SDK publicada el 25 de Enero de 2010, que incluye algunas mejoras y pocas funcionalidades añadidas. Entre ellas destaca el uso de un plugin basado en OpenAL para ofrecer sonido 3D.
\item Resultados visualmente pobres y de bajo rendimiento incluso en proyectos desarrollados por equipos con experiencia.
\end{itemize}

(completar)

\subsubsection{Ogre, Object-Oriented Graphics Rendering Engine}
Ogre es considerado uno de los motores gráficos open-source multiplataforma más populares y de más éxito. Está escrito en C++ y está dirigido al mismo lenguaje, aunque existen wrappers para Python, Java y .NET. 
\\

A diferencia de otros, no está planteado como un motor de juego, sólo como motor gráfico. Aunque se le puede añadir con facilidad otras librerías. La filosofía de Ogre es que el desarrollador pueda añadir Ogre como un módulo más en su aplicación, así como los módulos que necesite, en lugar de tener que adaptar la aplicación para que encaje correctamente con una solución que pretenda abarcar más de lo que se necesita y provocando incomodidades e incompatibilidades.
\\

\begin{itemize}
\item Altamente modular, se le pueden añadir librerías y plugins con facilidad. 
\item Esto mismo hace que las capacidades sean más limitadas que las de los motores y SDKs.
\item Dispone de un equipo de desarrollo dinámico y de una comunidad muy activa.
\item Nueva versión publicada el 31 de Diciembre de 2009, con una lista amplia de mejoras.
\item Utiliza la licencia del MIT-X11, por lo que Ogre es gratuito, libre y puede usarse para cualquier tipo de desarrollo.
\end{itemize}
(completar)

\subsubsection{OSG: OpenSceneGraph}
OSG se presenta como una librería multiplataforma para el desarrollo de aplicaciones que requieran de visualización 3D con alto rendimiento, como visualización científica, realidad virtual o comúnmente juegos. 
\\

Es una librería ampliamente usada, con cierta tendencia hacia la visualización científica y geográfica, con una lista amplia de capacidades. Algunos ejemplos de uso son TerrainView, Pok3D, Nasa'a Blue Marble y Capaware!/Geviemer (ULPGC)

\begin{itemize}
\item Altamente modular y potente, con multitud de extensiones. 
\item Dispone de un equipo de desarrollo dinámico, con revisiones frecuentes y de una comunidad activa.
\item Se dispone de cierta experiencia con el entorno.
\item El diseño de la API puede ser confuso y en cierta medida deficiente en términos de facilidad de uso.
\item Documentación pobre.
\item Utiliza licencia LGPL, por lo que es gratuita, libre y puede usarse para cualquier tipo de desarrollo.
\end{itemize}
(completar)

\subsubsection{Irrlicht: Lightning Fast Realtime 3D Engine}
Motor gráfico 3D multiplataforma de código abierto y de alto rendimiento. Está escrito en C++, pero también esta disponible para lenguajes .NET, así como otros lenguajes como Java, Perl, Ruby, Python o Lua, mediante bindings. 

\begin{itemize}
\item Altamente modular, potente y con multitud de extensiones. 
\item Dispone de un equipo de desarrollo dinámico, con revisiones frecuentes y de una comunidad activa.
\item Utiliza la licencia zlib/libpng, por lo que es gratuito, libre y puede usarse para cualquier tipo de desarrollo.
\item Mediante IrrEDIT se peude construir escenarios con facilidad que peuden usarse dentro de Irrlycht.
\item Sin embargo, otras librerías como IrrKlang, para sonido, se distribuyen bajo licencias más restrictivas.
\item Se define a la altura de los motores comerciales pero tiene ciertas carencias.
\end{itemize}
(completar)

\subsubsection{Panda3D: Free 3D Game Engine}
Originalmente Panda3D, acrónimo de Platform Agnostic Networked Display Architecture, fue creado por Disney como parte de una de sus atracciones y posteriormente liberado, en 2002, con la intención de facilitar el trabajo con universidades y projectos de investigación en Realidad Virtual. 
\\

Acogido por el Carnegie Mellon Entertainment Technology Center, fue mejorado y preparado para su uso público. Panda3D se define como un motor de juego y un entorno de de trabajo para render 3D y desarrollo de juegos, libre, gratuito y multiplataforma, que puede usarse para cualquier tipo de desarrollo. Incluye motor gráfico, audio, gestión de entrada/salida y detección de colisiones entre otras capacidades.

\begin{itemize}
\item Dispone de un equipo de desarrollo dinámico, con revisiones frecuentes y de una comunidad activa. Aunque mayormente para Python.
\item Sin embargo, existe un menor dinamismo y soporte para C++ que para Python.
\item Tiene un diseño orientado a mejoras futuras e incluye funcionalidades avanzadas cercanas a los motores comerciales que aún no incluyen otros motores libres.
\item Diseño de la API atractivo y sencillo de usar.
\item Énfasis en la documentación de la librería, en distintas modalidades: manuales, referencias, y plantillas conceptuales, que facilitan en gran medida la comprensión y el uso de la librería. 
\item Se añade a la documentación tradicional diversos video tutoriales creados tanto por la comunidad, así como clases impartidas sobre Panda3D por David Rose, del Instituto de Realidad Virtual de Walt Disney.
\item Ampliamente usada por alumnos del Carnegie Mellon y en proyectos de equipos pequeños con resultados visuales atractivos y con buen rendimiento. 
\item Se distribuye bajo una licencia basada en BSD que permite su uso libre y gratuito para todo tipo de proyectos.
\end{itemize}
(completar)

\subsubsection{Doxygen: Source code documentation generator tool}
Generador de documentación multiplataforma para C++, entre otros lenguajes. Permite generar documentación online para su visualización en un navegador web (HTML), así como LaTex, MS-Word, PostCript, PDF con hipervínculos entre otros. Además puede usarse para extraer la estructura de código de fuentes no documentados, y generar grafos de dependencias, diagramas de clases y otros esquemas.
\\

Doxygen se distribuye bajo licencia GPL. De cualquier forma, los documentos producidos mediante Doxigen son trabajo derivado de los datos usados en su producción, por lo que no se ven afectados por la licencia.
\\

No se estudian más casos por considerarse la mejor(¿única?) opción y tener cierta experiencia con ella, lo que es una ventaja determinante.
\\

\subsubsection{Boost C++ Libraries }
Boost es un conjunto de librerías de código abierto multiplataforma con la intención de extender las capacidades del lenguaje de programación C++. Varios fundadores de Boost forman parte del Comité ISO de Estándares de C++, por lo que algunas de estas librerias terminan por introducirse en la siguiente versión estándar de C++. Utiliza una licencia propia, la Boost Software License, que permite su uso en cualquier tipo de proyectos, comerciales o no. 
\\

Algunas de las librerías de mayor uso son las que facilitan las operaciones con el sistema, I/O y gestión de hilos, entre muchas otras.


\subsubsection{Qt: Cross-platform Application and UI Framework}

Librería multiplataforma de Trolltech para desarrollar interfaces gráficas de usuario, así como para desarrollar aplicaciones de consola y servidores. Utiliza como lenguaje C++, aunque también está disponible para otros lenguajes a través de binding (Python, C\#, Ruby, Java, Ada y Php, entre otros).
\\

Qt es ampliamente usado y considerado como una de las opciones multiplataforma más completa y estable. Algunos ejemplos de uso son principalmente KDE, a partir del cual logró un considerable éxito y expansión, además de otras aplicaciones como Google Earth o Skype.
\\

Tras polémicas en sus inicios por publicitarse como código libre sin serlo, actualmente la biblioteca es gratuita y libre tomando en consideración las condiciones de las opciones LGPL 2.1 y GPL 3.0 para el proyecto. También existe otra opción de pago destinada para software comercial que no quiera cumplir con las condiciones anteriores. 


\subsubsection{wxWidgets: Cross-platform GUI Library}
Se trata de una librería para C++ para el desarrollo de interfaces gráficas de usuario. Es una de las pocas opciones realmente multiplataforma, gratuita y open source disponibles. Tiene la capacidad para ofrecer interfaces de aspecto nativo dependiendo de la máquina sobre la que se ejecuta el código. 
\\

wxWidgets, aunque con sus desventajas y limitaciones, es una libería ampliamente usada que ha creado comunidad. Algunos de sus usarios más conocidos son: AOL(AOL Comunicator), California Institute of Technology (Gambit), Carnegie Mellon University (Audacity),   Grisoft Inc. (AVG Antivirus), NASA (NASGRO), National Human Genome Research Institute - USA
(ComboScreen), TomTom (TomTom HOME), Xerox (VIPP) o la propia Universidad de Las Palmas de Gran Canaria (Capaware!) entre otros.
\\

Se exponen algunas de las características clave para la toma de decisión sobre su uso:
\begin{itemize}
\item Librería multiplataforma gratuita y open source para desarrollar interfaces gráficas de usuario para aplicaciones de escritorio.
\item No todas las opciones que ofrece la librería funciona en las distintas plataformas, por lo que hay que tener especial cuidado si que quiere que el proyecto sea, en potencia, multiplataforma. Esto limita las opciones de la librería que pueden usarse y la calidad visual del resultado.
\item Existe documentación, foros y una comunidad bastante amplia y activa.
\item Hay que tener en cuenta que durante el funcionamiento de la aplicación no existe una interfaz gráfica destinada al usuario en términos tradicionales. Es decir, no existen ventanas, botones, menús ni indicadores destinados a que el usuario las maneje. Por lo tanto no es un apartado crítico del proyecto. Sin embargo, se desea una interfaz gráfica que permita preparar la instalación en su situación final, además de gestionar ventanas y para mostrar las opciones de configuración de la aplicación. Las capacidades de wxWidgets resultan suficientes para estas necesidades.
\item Se dispone de amplia experiencia previa con la librería en otros proyectos.
\end{itemize}

Se decide optar por esta librería por cubrir las necesidades básicas del proyecto, por ser gratuita y libre, y por tener una extensa experiencia con la misma en otros proyectos, lo que es determinante para considerarla la mejor opción.

\subsubsection{OpenCV: Open Source Computer Vision}
OpenCV es una librería multiplataforma de funciones de visión por computador en tiempo real. Está desarrollada inicialmente por Intel, siendo gratuita tanto para uso comercial como investigación bajo licencia BSD. Surgió en 1999 como una iniciativa de Intel para mejorar aplicaciones intensivas en CPU, formando parte de una serie de proyectos que incluían ray tracing en tiempo real y pantallas de representación 3D. Actualmente acaba de salir la versión 2.0 que incluye amplias mejoras a la interfaz con C++, mejor prototipado, nuevas funciones y mejoras de rendimiento, especialmente en sistemas multicore. 
\\

Algunas de sus aplicaciones son HCI (Human-Computer Interaction), Identificación, Segmentación y Reconocimiento de objetos, Reconocimiento de Caras, Reconocimiento de Gestos, Motion tracking, Ego Motion, Motion Understanding, SFM(Structure from Motion), Calibración estéreo y multi-cámara, Percepción de Profundidad y Robótica móvil.
\\

La librería es utilizada en el proyecto principalmente para las tareas de reconocimiento de objetos, caras, gestos y movimiento, lo que formaría parte del Módulo de Reconocimiento. Además, también es utilizada para el proceso de imágenes con fines estéticos, adoptando los resultados de los algoritmos de reconocimiento como modificadores de las imágenes en si, formando parte del Módulo de Producción.

\subsubsection{Fmod: Music \& Sound Effects System}
Librería de audio propietaria y multiplataforma de Firelight Technologies que soporta un amplio abanico de formatos de audio. También tiene capacidad para reproducir sonido 3D en sistemas de sonido envolventes.
\\

La biblioteca es ampliamente utilizada en juegos y varios motores gráficos incluyen soporte para la misma. Algunos ejemplos son: BioShock, Call of Duty 4, Crysis, Far Cry, la saga Guitar Hero, Heavenly Sword, Hellgate: London, Metroid Prime 3, Second Life o World of Warcraft, entre otros.
\\

Fmod está disponible siguiendo distintos esquemas. Sin embargo, no es de código abierto y sólo es gratuito para desarrollo de aplicaciones no comerciales.

\subsubsection{OpenAL: Cross-platform 3D Audio API}
API de audio multiplataforma desarrollada por Creative Labs destinada la reproducción de audio posicional y multicanal en 3D. Se ideó para su uso extenso en videojuegos siguiendo las mismas convenciones que OpenGL, consiguiendo convertirse en un estándar aceptado. 
\\

La biblioteca es ampliamente usada en juegos y varios motores incluyen soporte para la misma. Algunos ejemplos relativamente recientes son: Doom3, Quake4, Unreal2, Unreal Tournament 3 o Hitman2. 
\\

Sin embargo, en los últimos años el mantenimiento de la misma se ha descuidado y aparecen errores, especialmente en sistemas de 64 bits. Son comunes las nuevas variaciones de OpenAL que le dan continuidad, como OpenAL Soft, OpenAL++ o distintas librerías a modo de wrapper que usan OpenAL por debajo, como SFML.
\\

De cualquier forma, OpenAL parece ser la única opción multiplataforma gratuita y libre para cualquier tipo de desarrollo que provea de posicionamiento 3D de audio en sistemas de sonido envolventes.

\subsubsection{SDL\_Mixer: Simple DirectMedia Layer Mixer}
Partiendo de la SDL, librería multiplataforma que permite el acceso de bajo nivel a dispositivos de audio, periféricos y hardware 3D, SDL\_Mixer se centra en el primer apartado facilitando la mezcla de sonido multicanal, así como la carga de samples y de música de distintos formatos.
\\

Sin embargo, aunque permite el acceso a bajo nivel, no aporta mayores funcionalidades por sí misma.
Bla bla bla...
\\
(completar)

\subsubsection{Clunk: Open Source 3D-Sound library}
Biblioteca de creación reciente de código abierto para C++ que pretende dar soporte para la generación de sonido 3D, binaural, en tiempo real. Propone una API bastante manejable y sencilla de usar, con un modelo orientado a la gestión de objetos. Sin embargo aún se encuentra en fase de testeo antes de lanzar su primera release. 
\\

Sin embargo, está preparado para generar sonido binaural, el cual tiene su mejor efecto en auriculares y no tanto en altavoces. Por otro lado del modelo de escucha sólo tiene en consideración posición, velocidad y dirección de orientación, sin información de verticalidad; por lo que no es posible definir realmente su estado en un entorno 3D, sólo en un plano.

\subsubsection{Irrklang: High level 3D audio engine/API}
API de alto nivel para sonido 2D/3D multiplataforma enfocado hacia C++ y lenguajes.NET. Da soporte para un amplio abanico de formatos de sonido y provee de una API muy sencilla de usar. Se puede encontrar bajo distintas licencias pero sólo es gratuito para desarrollos no comerciales.
\\

Al igual que OpenAL y FMOD éste sí permite definir completamente las propiedades necesarias para orientar en 3D tanto los sonidos como la escucha. Sin embargo, la limitaciones de licencia son menos interesantes que las de una opción más abierta.
\\
(completar)

\subsubsection{SFML: Simple and Fast Multimedia Library}
SFML se ofrece como una API open-source multimedia que provee mecanismos para la gestión del sistema, de gráficos, interfaz gráfica de usuario, sonido, periféricos y de red. La librería es multiplataforma y se encuentra disponible para varios lenguajes como C, C++,.NET, Python o Ruby, entre otros. 
\\

Sigue un diseño Orientado a Objetos y define un interfaz fácil de usar y de integrar en otros proyectos. Se compone de diferentes paquetes que pueden ser usados en conjunto o individualmente. Es de especial interés el paquete de sonido, que funciona a modo de wrapper de OpenAL, arreglando algunos de los bugs que tiene y simplificando su uso. 
\\

Se distribuye bajo licencia zlib/png, de la Open Source Initiative, por lo que es gratuita y abierta para todo tipo de proyectos.
\\

Tiene varios defectos. Por un lado, en el paquete de sonido la documentación es errónea, y puede llevar a confusiones importantes. Además la definición de la API, aunque más simple, limita la funcionalidad real de OpenAL hasta el punto de que no puede orientarse correctamente la escucha en 3D, por lo que sólo puede usarse en 2D o 3D en el plano horizontal. Sin embargo, pequeñas modificaciones en la libería permitirían recuperar esa funcionalidad sin problemas.

\subsubsection{Chuck: Strongly-timed, Concurrent, and On-the-fly Audio Programming Language}

Chuck es un lenguaje de programación para el análisis, síntesis, composición y producción de audio. La librería es multiplataforma y presenta un modelo de programación concurrente basado en tiempo, altamente preciso (strongly-timed) y con la habilidad de añadir y moficar código en tiempo de ejecución. Chuck soporta dispositivos MIDI, OSC, HID y audio multicanal.
\\

(completar, scripts, etc y estudiar más a fondo junto con Tapestrea, en comparación con Marsyas)

\subsubsection{Marsyas: Music Analysis, Retrieval and Synthesis for Audio Signals}
Librería y framework para C++ para el procesado de audio con especial énfasis en aplicaciones de extracción de información en música, creada principalmente por George Tzanetakis y desarrollada de forma abierta. Está enfocado hacia el prototipado rápido y la experimentación en el análisis y síntesis de audio, procurando un alto rendimiento. 

Bla bla bla...

(completar... y estudiar más a fondo en comparación con Chuck)

\subsubsection{PostgreSQL}
Potente Bases de Datos objeto-relacional open source. Es considerada la BBDD open source más avanzada y potente, con más de 15 años de desarrollo. Está disponible para múltiples sistemas operativos Linux, UNIX y Windows y dispone de interfaces con múltiples lenguages, entre ellos C++. 
\\
bla bla bla

\subsubsection{OODBMS: Object Oriented Data Base Management Systems}
Se han estudiado múltiples variantes de Bases de Datos Orientadas a Objetos. Sin embargo, no ha sido posible encontrar ninguna que se adapte a los requisitos software del proyecto. Se resumen detalles que implican su descarte:
\begin{itemize}
\item EyeDB: Disponible para C++, potente y estable. Sólo está disponible para Linux.
\item Metakit: Base de datos embebida limita su uso y crecimiento futuro del proyecto.
\item db4o: Embebida, sólo para Java o c\#.
\item Orient: Versión para Windows sólo embebida. Mala documentación.
\item NeoDatis: Sólo para Java o C\#.
\item Perst: Embebida.
\item Odaba: Proyecto antiguo, API confusa.
\item Matisse: Licencia gratuitia restrictiva, sólo para prueba de la librería.
\item Jade6: Licencia restrictiva, sólo para prueba de la librería.
\item Bifröst: Abandonado.
\item Cerebrum: ??
\item Frontier: Abandonado.
\item Oviedo3: Abandonado.
\item Thor: Proyecto del MIT, no disponible aún.
\item MongoDB: No es orientada a objetos sino a documentos, mala eficiencia en altas cantidades de transacciones.
\end{itemize}

\subsubsection{Debea: Database Access Library}
Se trata de una librería en C++ que actúa como mapper entre el modelo orientado a objetos de la aplicación y el esquema de persistencia elegido (base de datos SQL, CSV o ficheros XML). En el caso de SQL, aunque encapsula la persistencia de los objetos incluyendo una API sencilla para la carga y almacenamiento de los mismos y sus relaciones, sigue siendo posible ejecutar comandos SQL si se desea realizar consultas elaboradas. Usa la licencia de wxWindows por lo que es gratuita y libre. También está disponible para Linux y Windows. Soporta de forma nativa bases de datos SQLite3 y PostgreSQL, además de ficheros csv y xml y ofrece una API sencilla y una documentación clara.


\subsection {Análisis de Requisitos de Usuario}
La instalación se presenta como un espacio en el que el usuario puede entrar y moverse. Dentro de ese espacio se encontrará con una o varias pantallas, cámaras, micrófonos  y altavoces. A través de las cámaras y de los micrófonos se capturará información para su análisis y para la producción de efectos, y mediante las pantallas y los altavoces se mostrará un entorno. Es mediante la actitud e interacción del usuario con el espacio como el entorno virtual es generado. A su vez, este entorno será capaz de actuar y evolucionar por su cuenta dentro de un esquema de comportamiento, también definido mediante la interacción del usuario durante la sesión. Capacidades añadidas permitirían a un usuario entrar en el entorno de otro usuario. Aunque este apartado se dejará como trabajo futuro en función de la evolución del proyecto.
\\

Teniendo en cuenta estos aspectos, se detallan los siguientes requisitos:

\begin{itemize}
\item Captura de imagen del usuario.
\item Captura de sonido del usuario.
\item Reconocimiento de su posición en el espacio, localización de cabeza/cuerpo, posturas o gestos.
\item Reconocimiento de voz (sonidos, palabras) (en función de la evolución del proyecto)
\item Crear entorno propio (crear, borrar, cargar escenarios).
\item generación de esquema de comportamiento.
\item Generación de efectos visuales.
\item Generación de efectos de audio y composición musical.
\item Generación de elementos 3D.
\item Generación de elementos 2D.
\item Generación de vida artificial.
\item Interacción.
\begin{itemize}
\item Con la escena:
\begin{itemize}
\item Vista: Perspectiva Visual (asociación cámara/cabeza).
\item Oído: sonido estéreo ó 3D envolvente.
\item Provocar sonidos: ruidos, palmas, habla.
\item Movimiento dentro de la escena:
\begin{itemize}
\item No estar.
\item Estar.
\item Quedarse quieto.
\item Moverse. 
\item Contacto del usuario con los elementos de la escena (velocidad: estático, roce, golpe, gesto...)
\item Elementos: Crear, destruir, mover, provocar interacción/respuesta.
\item Definición de Esquema de Comportamiento/Psique: propia y de la escena, estudio del comportamiento e interacción que sentará las bases del estado del entorno (tipo de escena, iluminación, sonidos, efectos, tipos de elementos creados, comportamientos de los mismos).
\end{itemize}
\end{itemize}
\item Con otros usuarios: (en función de la evolución del proyecto)
\begin{itemize}
\item Entrar en escenarios de otros usuarios (limitación de interacción según permisos: ver/tocar/crear/destruir/psique-empatía(poder modificar esquema de comportamiento del otro usuario o que se modifique el suyo)).
\item Ver y comunicarse con otro usuario: avatar visual, comunicación por audio.
\end{itemize}
\end{itemize}
\item  Alta capacidad de personalización del entorno resultante y unicidad del entorno.
\end{itemize}

\newpage
\begin{figure} [H]
\begin{center}
\includegraphics[width=\textwidth]{recursos_memoria/casosdeuso.png}
\end{center}
\caption{ \label{F_CasosdeUso} Modelo de Casos de Uso.}
\end{figure}

\subsection {Análisis de Requisitos de Software}

Además de conseguir como resultado una Instalación que muestre las capacidades tecnológicas en el entorno del Arte, así como la experimentación en nuestras interfaces y formas de interacción del usuario, este proyecto pretende ofrecer un entorno de trabajo para el futuro desarrollo de nuevas aplicaciones de este tipo. De esta forma, la aplicación se enfoca como un proyecto open-source, un marco de trabajo compuesto de diferentes módulos independientes, de forma que la implementación subyacente sea modificable sin afectar al resto de los módulos. Para ello se debe definir un completo esquema de interfaces.
\\

Teniendo en cuenta estas características, se detallan los requisitos software del proyecto:
\begin{itemize}
\item Uso de software libre y multiplataforma.
\item Uso de recursos gratuitos.
\item El framework producido será software libre.
\item Diseño del framework orientado a multiplataforma, para facilitar su futura portabilidad.
\item Diseño de interfaces de forma que los módulos sean fácilmente sustituibles.
\item Sistema local/online persistente (según evolución del proyecto).
\end{itemize}


\section{Diseño}

\subsection{Estructuración de conceptos}
\begin{center}
(REVISAR Y DEFINIR BIEN)
\end{center}

\subsubsection{Aplicación}
-Aplicación:
  -Programa de que se ejecuta en un ordenador.
  -Carga un escenario para un usuario.
  -Puede entrar en escenarios cargados por otros usuarios en otras aplicaciones conectados al mismo sistema.

\subsubsection{Usuario}
-Usuario:
  -El usuario se presenta en la instalación y es reconocido por su cara (ID) y se crea un entorno/escenario.
  -El usuario puede querer crear un escenario nuevo o ver uno anterior (default: decidir cargar último/crear).
  -El usuario puede interactuar con un escenario propio o de otro usuario (preferencia, permisos) (default: todo, ver, tocar), and lógico bit a bit.
  -El usuario puede verse a sí mismo (avatar), a otros usuarios (avatar) y a otros escenarios en red (símbolos de escenarios).
  -Los cambios y la interacción del usuario define un patrón de comportamiento (psique, opciones: egocéntrico, tábula rasa).
\\

-Permisos: 
  -Conjunto de opciones que define la interacción entre un usuario(desea) y un escenario(permite).
  -Operación lógica (umpersand) definiría qué puede hacer un usuario en un escenario.
  -Posibles permisos: Ver/Tocar/Coger/Copiar/Crear/Destruir/Influenciar/LibreAlbedrío

\subsubsection{Entorno}
-Escenario/Entorno:
  -Se presenta ante / es creado por / un usuario.
  -Representa elementos vivos o inertes, definidos mediante objetos 3D, 2D, sonidos y efectos.
  -Responde ante la interacción del usuario y cambia según sus acciones.
  -También cambia por su cuenta.
  -Permite al usuario propietario interactuar cómo desee, la interacción de otros usuarios puede estar limitada.
  -Los cambios y la interacción del escenario define un patrón de comportamiento que establece las bases del mismo (psique).
  -Se rige por la psique pero tiene un determinado factor de aleatoriedad.
  -Componentes: Espacio, entidades.
\\

-Espacio: 
  -Terrenos (discutir estático/dinámico, interactivo o no).
  -Sonido ambiental: autogenerado, gramática para generación de composiciones.

-Entidades:
  -Usuarios: avatares.
  -Objetos no interactivos/inertes (estudiar interacción por físicas).
  -Objetos interactivos: vivos/inertes.
  -Sonido de las entidades: acciones (gramática), etc. (autogenerado: gramática).
  -Sonidos de los usuarios: acciones (autogenerado: gramática), captura por micrófono, comunicaciones chat, etc.

-Objetos interactivos:
  -Colección de elementos 3D, 2D, sonidos y efectos.
  -Composición: algoritmo genético que define la creación de un objeto, tanto física (3D, 2D, sonidos, efectos) como de comportamiento.
  -Capacidades de evolución: reproducción, mutación y asimilación.
  -Vivos: Agentes, revisar modelo BDI (Creencias, Deseos, Intenciones), y de Agentes Híbridos (Nivel Reactivo, Conocimiento, Social).
  -No-muertos: Agentes interactivos totalmente reactivos, sin deseos ni intenciones.
\\

\subsubsection{Resumen}
\textsl{Llegados a este punto se observan las siguientes necesidades:}

\begin{itemize}
\item Aplicación que implemente y englobe las funcionalidades.
\item Interfaz gráfica de usuario genérica para la gestión de ventanas y configuración de opciones de aplicación.
\item Modificación de elementos y datos, carga y guardado de los mismos.
\item Base de Datos.
\item Percepción del entorno mediante técnicas de Visión por Computador y Captura de audio.
\item Generación de elementos con los que componer un entorno (elementos 3D, 2D, audio).
\item Análisis y definición del patrón de interacción del usuario y de la evolución del entorno (psique).
\end{itemize}

\subsection{Diseño de la Aplicación}

A partir de esta descripción se pueden diferenciar y extraer los diferentes módulos de los que es necesario que se componga la aplicación. Hay que tener en cuenta además que se desea conseguir una alta modularidad e independencia entre las distintas secciones, que permita extraer e intercambiar módulos con facilidad, p.e para usen distintas librerías o no usen librerías externas en absoluto. Por ello, se sigue un modelo de interfaces, en la que se define el núcleo de la aplicación y las relaciones entre los módulos. Sobre ella, se implementará cada módulo y finalmente se construirá la aplicación final.

\begin{itemize}
\item Core: Conjunto de interfaces de la aplicación.
\begin{itemize}
\item IAplication: Define la interfaz de la aplicación completa. Es además una composición de los distintos módulos de la misma.
\item IGUI: Interfaz gráfica de la aplicación de ventanas, para las opciones básicas de visualización y configuración.
\item IPersistence: Persistencia de la aplicación, encapsula los cambios que se efectúan sobre los datos de la misma.
\item IPercept: Engloba la interfaz de usuario mediante percepción (Visión por Computador, captura de audio).
\item Iprod: Es el módulo referido a la Producción, generación de elementos 3D, 2D, composición de audio, etc.
\item ICog: Para el ánalisis de la interacción del usuario y definición del concepto de Esquema de Comportamiento/Psique de Entorno y de Usuario.
\end{itemize}
\item VOX: Implementación de la aplicación.
\item Monitor: Para la gestión y monitorización de los accesos a la Base de Datos.
\item Base de Datos
\end{itemize}

\begin{figure} [H]
\begin{center}
\includegraphics[width=\textwidth]{recursos_memoria/DiagramadeclasesUML.png}
\end{center}
\caption{ \label{F_DiagramadeClasesUML} Diagrama de Clases UML.}
\end{figure}


\chapter{Etapa 2: Aplicación principal, GUI, Percepción y Producción}

Para el desarrollo de la primera demo se pretende conseguir una aplicación ejecutable que integre el modelo de interfaz y la separación de módulos definida en la etapa anterior, centrándose en implementar las funcionalidades de un subconjunto de módulos básicos. 
\\

Los módulos a abordar son aquellos que aporten la tecnología necesaria para que ésta se ejecute y provea de las herramientas necesarias para posteriormente analizar y generar contenido. Estos es, para capturar y mostrar la información que se manejará en la aplicación. Los módulos son: IGUI, IPercept e IProd. 
\\

La intención es únicamente crear la estructura básica de la aplicación, así como establecer una relación básica de dependencias entre módulos, cargando en cada caso correctamente las librerías utilizadas. 
\\

En este punto no existen los conceptos de usuario ni de entorno. Tampoco se abordará la Persistencia ni, por tanto, la Base de Datos.

\section{Análisis}

\subsection{Análisis de Requisitos de Usuario}
Como se ha comentado estudiaremos un subconjunto básico de los casos de uso para esta primera demo ejecutable. En ella se abordarán las funcionalidades básicas de gestión de aplicación y ventanas que permita su ejecución y mostrar información en distintas ventanas. Además se cargarán los módulos de percepción y de producción. Se mostrarán las imágenes capturadas por las cámaras y el audio grabado, así como un entorno 3D por defecto, con sonido posicional.

\begin{figure} [H]
\begin{center}
\includegraphics[width=\textwidth]{recursos_memoria/casosdeuso_primerademo.png}
\end{center}
\caption{ \label{F_CasosdeUsoPrimeraDemo} Modelo de Casos de Uso.}
\end{figure}

\subsection{Selección de Herramientas}

A partir del estudio de las herramientas disponibles se han seleccionado las más adecuadas, tanto por sus características como por compatibilidades técnicas en el conjunto del proyecto.

\begin{itemize}
\item GUI: wxWidgets
\item Motor gráfico: Panda3D
\item Gestión de Hilos: Boost
\item Captura de Audio y Audio Posicional: SFML
\item Captura de Video y Visión por Computador: OpenCV
\end{itemize}

\section{Diseño}

\subsection{Diseño de la Aplicación}
\subsubsection{Breve descripción de los módulos}
\begin{itemize}
\item core:
\begin{itemize}
\item ICog: Interfaz básica para la creación del módulo.
\item IGui: Interfaz básica para la creación del módulo y registro de ventanas.
\begin{itemize}
\item IGuiWindow: Creación, Mostrar/Ocultar.
\end{itemize}
\item IPercept: Interfaz básica para la creación e inicialización del módulo.
\item IPersistence: Interfaz básica para la creación del módulo.
\item IProd: Interfaz básica para la creación, intervención e inicialización del módulo.
\item Application: Interfaz básica para la creación de la aplicación.
\end{itemize}
\item igui:
\begin{itemize}
\item Crear ventana de aplicación.
\item Operación básicas de ventana: mostrar, mover, cerrar, cambiar contenido.
\item Menú de Aplicación: Archivo, Vista, Herramientas, Ayuda.
\end{itemize}
\item ipercept: 
\begin{itemize}
\item Capacidad para capturar imágenes de n-cámaras.
\item Capturar imágenes de las n-cámaras.
\item Mostrar imágenes capturadas.
\item Capturar Audio.
\end{itemize}
\item iprod:
\begin{itemize}
\item Cargar una escena 3D por defecto.
\item Introducir y reproducir audio posicional 3D.
\item Capacidad para mostrar n-ventanas de render de la misma escena 3D, con vistas independientes.
\end{itemize}
\item vox: Carga y ejecución de los distintos módulos.
\end{itemize}

\subsubsection{Diseño General en UML}

\begin{figure} [H]
\begin{center}
\includegraphics[width=\textwidth]{recursos_memoria/DiagramadeclasesUML_PrimeraDemo.png}
\end{center}
\caption{ \label{F_DiagramadeClasesUML_PrimeraDemo} Diagrama de Clases UML. Resumen}
\end{figure}

En la figura \ref{F_DiagramadeClasesUML_PrimeraDemo} puede verse un esquema general en UML del proyecto completo. Es uns visión simplificada pero que refleja la arquitectura del sistema.
\\

Se distinguen dos grandes bloques: En azul se encuentra el paquete core, que se compone de las interfaces separadas en módulos; en naranja la implementación de los distintos módulos y de la aplicación en sí. Cabe destacar que se persigue intencionadamente una alta modularidad y que en última instancia parte de estos módulos se ejecutarán en hilos independientes, aprovechando la tendencia actual de procesadores de multi-núcleo.
\\

Debe tenerse en cuenta que los módulos implementados sólo podrán comunicarse entre ellos y con la aplicación a través de dicha interfaz. De esta forma se abstraen los detalles de la construcción de cada componente y se asegura su independencia, de forma que cualquier módulo pueda ser reemplazado o reimplementado de forma independiente sin que afecte al resto del proyecto. También permitiría la construcción de forma flexible de distintas aplicaciones, utlizando sólo los módulos necesarios o aprovechando módulos de otras ya creadas.

\subsubsection{Diseño en UML - Núcleo de la Interfaz}

\begin{figure} [H]
\begin{center}
\includegraphics[width=\textwidth]{recursos_memoria/DiagramadeclasesUML_PrimeraDemo_core.png}
\end{center}
\caption{ \label{F_DiagramadeClasesUML_PrimeraDemo_core} Diagrama de Clases UML. Detalle - core}
\end{figure}

La interfaz provee de unas herramientas básicas para la creación de cada núcleo y la comunicación entre ellos. Desde la aplicación y entre los módulos, toda interacción se hará a través de esta interfaz, aislando cada completamente dcada componente e los detalles de implementación de los otros.
\\

Si bien en la fase actual no existe una gran funcionalidad, a medida que avance el proyecto se irán añadiendo nuevas capacidades que permitan, por ejemplo el paso de datos, la generación de contenido o la gestión de objetos.
\\

En este apartado, el trabajo se concentra en los módulos de interfaz gráfica de usuario, percepción y producción. Con ellos se podrá disponer de un entorno con las capacidades básicas para la captura de lso datos necesarios y la visualización de los contenidos a generar.

\subsubsection{Diseño en UML - Módulo de GUI}

\begin{figure} [H]
\begin{center}
\includegraphics[width=\textwidth]{recursos_memoria/DiagramadeclasesUML_PrimeraDemo_igui.png}
\end{center}
\caption{ \label{F_DiagramadeClasesUML_PrimeraDemo_igui} Diagrama de Clases UML. Detalle - igui}
\end{figure}

Este módulo controla gestión de la interfaz gráfica de usuario de tipo ventana de la aplicación. 
\\

La interfaz principal se define en la clase MainFrame, desde la que se gestionaría la aplicación con los menús y paneles principales. Por otro lado, hay que tener en cuenta que la aplicación está destinada a mostrar multitud de ventanas independientes, que podrían mostarse en distintas pantallas o proyectores. Un modelo MDI de ventanas flotantes libres del entorno principal es el más adecuado.
\\
 
Hay que tener en cuenta que varias de las librerías a usar aportan mecanismos propios para la visualización de ventanas. Considerando también la simplicidad del uso de estos mecanismos y que las distintas ventanas visualizarían distintos tipos de datos, que pertencen a distintos módulos que se ejecutan en distintos hilos, se plantea por simplicidad definir en este módulo una clase IGUIWindow a modo de wrapper que englobe las funcionalidades que se requieren de los mismos, y que permita su gestión centralizada.
\\

\subsubsection{Diseño en UML - Módulo de Percepción}

\begin{figure} [H]
\begin{center}
\includegraphics[width=\textwidth]{recursos_memoria/DiagramadeclasesUML_PrimeraDemo_ipercept.png}
\end{center}
\caption{ \label{F_DiagramadeClasesUML_PrimeraDemo_ipercept} Diagrama de Clases UML. Detalle - ipercept}
\end{figure}

El módulo de percepción está destinado a la captura y análisis de los datos de entrada. Enel sistema que se plantea estos datos llegan a través de disntintas cámaras web y un micrófono. Por el momento, en esta primera demo sólo se procede a la captura de datos, dejando el análisis para fases posteriores. 
\\

Debido a la distinta naturaleza de entrada y procesado para video y audio, MainPercept lanza dos módulos que se ejecutan independientemente, cada uno en un hilo: PerceptAudio captura sonido y lo almacena en un buffer, y PerceptVideo captura imágenes. Este último está preparado para gestionar un número configurable de cámaras web y mostrar sus capturas en sus respectivas ventanas. 
\\

Hay que tener en cuenta que se crean las ventanas para visulizar las imágenes utilizando las herramientas de la propia librería. Esto se hace por simplicidad. Sin embargo, debe notarse que se utiliza el wrapper de ventanas IGuiWindow para encapsular las ventanas creadas con de esta forma y permitir su manipulación desde el módulo de interfaz gráfica de usuario.

\subsubsection{Diseño en UML - Módulo de Producción}

\begin{figure} [H]
\begin{center}
\includegraphics[width=\textwidth]{recursos_memoria/DiagramadeclasesUML_PrimeraDemo_iprod.png}
\end{center}
\caption{ \label{F_DiagramadeClasesUML_PrimeraDemo_iprod} Diagrama de Clases UML. Detalle - iprod}
\end{figure}

MainProd es el módulo principal de Producción y también se ejecuta en un hilo independiente. Está destinado no sólo a la visualización del entorno sino a la generación de contenido, tanto gráficos como composición de audio. Sin embargo, en el alcance de esta fase el módulo sólo incorpora el primer apartado, la visualización y reproducción. 
\\

Aunque el módulo se ejecuta en un hilo independiente está preparado para que otros hilos intervengan mediante llamadas a unos métodos determinados. Además, de igual forma que lo hace el módulo de percepción, MainProd esta preparado para manejar un número configurable de ventanas, cuya intención es ser visualizadas en distintas pantallas o proyectores. Estas ventanas también son creadas mediante las capacidades propias de la librería y utilizan IGuiWindow como envoltorio para su manipulación centralizada.
\\

Por otro lado se definen en el espacio las fuentes de sonido y las propiedades del observador (listener) para disponder de sonido posicional en tres dimensiones. 

\section{Implementación}
Se ha escogido como entorno de desarrollo Visual Studio 2008 Express Edition. Esto es debido a que se trata del entorno de desarrollo con que el se tiene mayor experiencia, así como por la comodidad de las herramientas de las que dispone. Se ha escogido la versión Express por ser gratuita y permitir el desarrollo de cualquier tipo de proyectos, tanto comerciales como no comerciales.
\\

El proyecto consiste en una solución o colección de proyectos de VS. Estos proyectos son:
\begin{itemize}
\item core: Núcleo de la interfaz.
\item icog: Proyecto para el Módulo Cognitivo.
\item igui: Proyecto para el Módulo de GUI.
\item ipercept: Proyecto para el Módulo de Percepción.
\item ipersistence: Proyecto para el Módulo de Persistencia.
\item iprod: Proyecto para el Módulo de Producción.
\item vox: Aplicación.
\end{itemize}

El núcleo de la interfaz 'core' se implementa como una librería dinámica y es una dependencia necesaria para todos los proyectos. Por simplicidad los proyectos icog, igui, ipercept, ipersistence e iprod, que correspondería cada uno con un módulo, son librerías estáticas de las que depende la aplicación ejecutable 'vox'.
\\

Hay que tener en cuenta que el IDE elegido no es multiplataforma, por lo que sólo puede ser utilizado bajo el sistema operativo Windows. Sin embargo, todas las librerías utilizadas sí lo son, y el código es C++, por lo que se debería poder crear nuevas soluciones para otros entornos sin grandes cambios. Se propone como alternativa para su futura portabilidad el IDE open source Eclipse o la configuración de una distribución preparada con CMAKE, de forma que se puedan generar proyectos para otros entornos. Sin embargo, esto quedará como trabajo futuro.
\\

Finalmente, comentar que se decide seguir una estructura de ficheros que se corresponda directamente con la jerarquía de los proyectos. Además se generarán los resultados en un directorio común llamado $\backslash$bin y las librerías externas a usar se almacenarán dentro del subdirectorio correspondiente dentro de la carpeta $\backslash$extern. El código de los módulos implementados puede encontrarse en $\backslash$src, y el de la aplicación el $\backslash$app.
\\

Llegados a este punto se procede a revisar la implementación de cada apartado:

\subsubsection{Núcleo de la Interfaz}
$\backslash$src$\backslash$core
\\

Contiene las cabeceras que definen clases virtuales puras, de las cuales heredarán las clases de los módulos que se implementen. Esto es así para asegurar la abstracción e independencia entre los detalles de implementación de cada módulo.
\\

%Como se trata de una librería dinámica hay que tener en cuenta la necesidad del uso de una macro de exportación. 
A continuación puede verse un ejemplo de su uso con la interfaz IPercept:

\begin{lstlisting}[language=C++]
namespace core{
class IPercept 
{ public:
   virtual ~IPercept(){}
   virtual void Delete()=0;
   virtual void Init()=0;
};}
\end{lstlisting}

Este ejemplo es válido para el resto de las interfaces, que incluyen en cada caso los métodos virtuales necesarios. Estos métodos implementados se corresponden directamente con los ilustrados en la figura \ref{F_DiagramadeClasesUML_PrimeraDemo_core}, página \pageref{F_DiagramadeClasesUML_PrimeraDemo_core}. 

%La macro de exportación utilizada es \_COREEXPORT\_ y se muestra en el siguiente cuadro:
%\begin{lstlisting}[language=C++]
%#ifndef _COREEXPORT_
%#define _COREEXPORT_
%
%#if defined(_MSC_VER) || defined(__CYGWIN__) || defined(__MINGW32__) || defined( __BCPLUSPLUS__)  || defined( __MWERKS__)
%    #  if defined( CORE_EXPORTS )
%    #    define COREEXPORT __declspec(dllexport)
%    #  else
%    #    define COREEXPORT __declspec(dllimport)
%    #  endif
%#else
%    #  define COREEXPORT
%#endif
%
%#ifdef _DEBUG
%	#define _CRTDBG_MAP_ALLOC
%	#define _CRTDBG_MAP_ALLOC_NEW
%	#include <stdlib.h>
%	#include <crtdbg.h>
%#endif
%#endif
%\end{lstlisting}


\subsubsection{Módulo de GUI}
$\backslash$src$\backslash$igui
\\

La clase principal del Módulo de GUI y que implementa la interfaz IGUI se llama MainGui. Esta clase es la que se encarga de toda la gestión de la interfaz de ventanas del proyecto y la librería escogida para su implementación es wxWidgets. 
\\

Las instrucciones para descargar y compilar wxWidgets pueden encontrarse en la web oficial \cite{wx09}. Los paquetes descargados vienen preparados para VS2008 y compilan sin necesidad de ningún ajuste. Sólo hay que incluir las cabeceras y las librerías necesarias, que pueden verse en la sección \ref{detallesImp:ModuloGUI}, página \pageref{detallesImp:ModuloGUI}. 
\\

Hay que tener en cuenta que una de las particularidades de wxWidgets es que necesita tomar control de la aplicación principal, mediante la macro IMPLEMENT\_APP. Este detalle puede verse en en profundidad en la sección \ref{sec:AplicacionPrincipal}, página \pageref{sec:AplicacionPrincipal}. De todas formas, eso no afecta a la construcción y gestión de la interfaz, que se realizará completamente en este módulo.
\\
 
Por otro lado, hay que tener en cuenta que distintos módulos tienen la capacidad de crear ventanas para mostrar información y que se desea usar esos mecanismos. Para ello se utiliza la interfaz IGuiWindow para encapsular la creación y la gestión, y se define MainGui como estática para poder acceder a la misma instancia desde cualquier módulo que lo necesite. Para asegurar que el acceso a la instancia sea seguro se utiliza un cerrojo como mecanismo de sincronización, implementado con boost.

\begin{itemize}
\item MainGui: Crea y mantiene los elementos de la interfaz. Se compone de un marco principal de aplicación llamado MainFrame y diversos paneles. Así mismo, también mantiene una lista de las ventanas independientes que se hayan registrado. Se crea la macro IMPLEMENT\_MIIAPP para encapsular la macro de wxWidgets IMPLEMENT\_APP. Un resumen de la clase puede verse en el siguiente cuadro:
\begin{lstlisting}[language=C++]
#define IMPLEMENT_MIIAPP(name) IMPLEMENT_APP(name)
namespace core {namespace igui{
class MainGui : public core::IGui
{ public:    ...
  private:		
    MainGui(const std::string &title = "");
    static MainGui* instance; 
    static MainFrame *main_frame;
    static std::map<IGuiWindow*, int> registered_windows;
    static std::map<IGuiWindow*, int> fullscreenable_windows;
};}}

MainGui* MainGui::GetInstance(const std::string &title)
{ boost::mutex::scoped_lock lock(m_mutex);
  if (instance == NULL) 
   instance = new MainGui(title);
  return instance; }
\end{lstlisting}

\item MainFrame: Crea el marco principal de la aplicación. Contiene el menú y los paneles principales. En esta fase los únicos paneles que existen por el momento son el de Inicio y el de Ayuda. Se ha implementado un mecanismo para la sustitución de contenidos de ventanas, de forma que la ventana principal de la aplicación asumirá el contenido de los paneles que se usen en cada momento de forma dinámica.

\begin{lstlisting}[language=C++]
namespace core { namespace igui	{
class MainFrame : public wxFrame
{ public:    ...
 private:
    wxMenu *file_menu, *view_menu, *tools_menu, *help_menu;
    wxMenuItem *item_file_close, *item_view_fullscreen, *item_view_start, *item_tools_configure, *item_help_about;
    ...
    DECLARE_EVENT_TABLE()
    void OnClose(wxCommandEvent& WXUNUSED(event));
    void OnViewStart(wxCommandEvent& WXUNUSED(event));
    void OnHelpAbout(wxCommandEvent& WXUNUSED(event));
    void DismissPanels();};}}
\end{lstlisting}

\item GUIStart: Es el panel principal de la aplicación que contendrá un acceso rápido a las funciones principales de la aplicación mediante los botones: Login, Inicio y Configuración.
\\

El aspecto más relevante de esta clase son los botones  y la necesidad de capturar el evento de render EVT\_PAINT para tener un acceso directo a cómo se dibuja el contenido de la misma. Esto es necesario para conseguir acabados más interesantes; por ejemplo, dibujar una imagen de fondo o texto con fondo transparente sobre imágenes. Debe tomarse el DC (contexto del dispositivo) con el que se va a dibujar, en este caso la pantalla, y usar las operaciones de dibujo directamente.

\begin{lstlisting}[language=C++]
namespace core { namespace igui { 
class GUIStart : public wxPanel 
{ public:   ...
   void OnPaint(wxPaintEvent &evt);
   void paintNow();	        
   void render(wxDC& dc);
 private:
   wxBitmap background_image;
   wxButton *login_button, *start_button, *configure_button;
};}}

BEGIN_EVENT_TABLE(GUIStart, wxPanel)
   EVT_PAINT (GUIStart::OnPaint)
END_EVENT_TABLE()

GUIStart::GUIStart(...):wxPanel(parent, id, pos, size, style, name)
{ background_image = wxBitmap(...);
  login_button = new wxButton(...); } 
  
void GUIStart::OnPaint(wxPaintEvent & evt)
{ wxPaintDC dc(this);
  render(dc); }
  
void GUIStart::render(wxDC& dc)
{ dc.DrawBitmap(background_image, 0, -20, false ); }
\end{lstlisting}

\item GUIHelp: Panel de información de la aplicación donde puede verse la versión y donde añadirá un enlace a la web del proyecto. Los detalles de implementación son muy similares al panel GUIStart.
\end{itemize}

Para ver más detalles sobre la configuración de la librería, dependencias necesarias y la implementación del módulo se puede consultar la sección \ref{detallesImp:ModuloGUI}, en la página \pageref{detallesImp:ModuloGUI}.

\subsubsection{Módulo de Percepción}
$\backslash$src$\backslash$ipercept
\\

La clase principal que implementa la interfaz IPercept y que está destinada a gestionar el módulo se llama MainPercept. Las tareas que se resuelven aquí son la captura de información del espacio de la instalación y de su interpretación. La entrada de datos del sistema consiste en audio mediante micrófonos, y de video, mediante webcams. En esta fase las tareas iniciales se centran en capturar audio y almacenarlo en un buffer, y capturar imágenes de las cámaras para mostarlas. Más adelante, se usará esta información para calibrar los puntos de vista o localizar al usuario dentro del espacio de la instalación para posicionarlo dentro del entorno virtual, entre otras funcionalidades.
\\

Puede apreciarse que la captura de información y su procesado son de naturaleza distinta y, de hecho, independiente; no sólo del resto de la aplicación, sino entre sí. Además hay que tener en cuenta que los accesos a los periféricos son tareas costosas en tiempo. Por ello, la mejor opción es mantener estas tareas de forma independiente, ejecutándose en hilos separados. Cuando el sistema necesite alguna información, solicitará al módulo la más reciente, pero no será necesaria la espera para que éste termine de acceder a los dispositivos o de realizar sus tareas.
\\

Las librerías utilizadas son SFML para la captura de audio, y OpenCV para la captura de video y su posterior proceso. Son librerías que han requerido ajustes importantes para su funcionamiento en el proyecto. Pueden verse los detalles en el anexo \ref{detallesImp:ThirParties} página \pageref{detallesImp:ThirParties}.

\begin{itemize}
\item MainPercept: Implementa los mecanismos necesarios para la gestión global del módulo y de sus componentes, de tal forma que se pueda controlar la entrada de datos y su procesado. Por ahora sólo instancia los módulos necesarios y los inicializa.

\begin{lstlisting}[language=C++]
namespace ipercept { 
class MainPercept : public core::IPercept
{ public:   ...
  private:
   static int num_cam;
   static PerceptAudio* perceptAudio_module;
   static PerceptVideo* perceptVideo_module;
};}}

MainPercept::MainPercept()
{ perceptAudio_module = new PerceptAudio();
  perceptVideo_module = new PerceptVideo(); }

void MainPercept::Init()
{ perceptAudio_module->Init();
  perceptVideo_module->Init(); }
\end{lstlisting}

\item PerceptAudio: Esta clase implementa la interfaz IPerceptAudio y se encargará de ejecutar la captura y procesado de audio. Por ahora sólo captura y almacena el sonido en un buffer. Las librerías usadas son SFML para el acceso a los dispositivos de audio y grabación, y Boost para la gestión de hilos.
\\

Por coherencia se decide seguir un mismo esquema para los módulos de este tipo. Se tratan de clases con métodos y atributos estáticos que internamente lanzan un hilo independiente para la ejecución de su código principal. Todas tienen un método llamado Init(), que internamente llama a DoInit() para inicializar el módulo y ejecutar la llamada a DoMainloop(), el bucle principal, en un hilo aparte. Internamente Iterate() recoge el código destinado a ejecutarse para cada iteración, mientras que Capture() realiza la captura de datos. Se hace uso de cerrojos no bloqueantes definidos en contexto para el acceso a los atributos. Cuando la ejecución de hilo llega a este cerrojo se permite saltar el código bloqueante a la espera de que en la siguietne iteración el cerrojo esté disponible, por lo que el hilo no llega a bloquearse nunca.
\\

\begin{lstlisting}[language=C++]
class PerceptAudio : public core::IPerceptAudio
{ public:    ...
  private:
    static void DoInit();
    static void DoMainLoop();
    static void Iterate();
    static void Capture();
    
    static boost::shared_ptr<boost::thread> m_thread;
    static boost::try_mutex m_mutex;
    static bool initialized, stop_requested;
    
    static sf::SoundBufferRecorder Recorder;
    static sf::SoundBuffer recordingBuffer;};}}
\end{lstlisting}

\item PerceptVideo: Esta clase implementa la interfaz IPerceptVideo y se encarga de ejecutar la captura y procesado de información visual. Por ahora la tarea consiste en capturar imágenes de un número configurable de cámaras web y mostrarlas en ventanas independientes. Como estás tareas son costosas en tiempo es altamente relevante que este módulo se ejecute en un hilo aparte. Las librerias a usar son Boost (\ref{detallesImp:Boost}), para la gestión de hilos, y OpenCV (\ref{detallesImp:OpenCV}), librería de Visión por Computador, para la captura de imágenes y su posterior procesado.
\\

En la construcción del módulo se sigue el mismo esquema que se ha visto en casos anteriores para mantener la coherencia. Así, se dispone de métodos para la inicialización y se separa la ejecución del bucle principal, que es lanzando en un hilo independiente, con cerrojos no bloqueantes. Así mismo, se distingue la ejecución de cada iteración, donde se incluye un método para la captura de datos de entrada. Se dispone de un vector de cámaras que permita la flexibildiad del módulo para recoger datos de un número configurable de fuentes.
\\
A continuación se muestran algunos detalles relevantes. 
\begin{lstlisting}[language=C++]
class PerceptVideo : public core::IPerceptVideo
{ public:   ...
  private:
   static void DoInit();
   static void DoMainLoop();
   static void Iterate();
   static void Capture();
   
   static int num_cam;
   static std::map< int, CvCapture* > capture_cam_array;
   static std::map< std::string, CamWindow* > camWindow_array;};}}
\end{lstlisting}

A continuación se muestra un cuadro de código de resumen que ilustra el proceso de inicialización, creación del nuevo hilo de ejecución y el bucle principal del mismo, donde se capturan los datos de entrada. 

\begin{lstlisting}[language=C++]
PerceptVideo::PerceptVideo()
{ capture_cam_array[i] = cvCaptureFromCAM(i);
  camWindow_array[window_name] = new CamWindow(window_name);}}}

void PerceptVideo::DoInit()
{ assert(!m_thread);
  m_thread = boost::shared_ptr<boost::thread>(new boost::thread(boost::function0<void>(&PerceptVideo::DoMainLoop)));}}

void PerceptVideo::DoMainLoop()
{ while(!stop_requested)
  { Iterate();
    m_thread->sleep(system_time()+milliseconds(10));}}

void PerceptVideo::Iterate()
{  boost::try_mutex::scoped_try_lock lock(m_mutex);
   if (lock) {Capture();}}

void PerceptVideo::Capture()
{ for (...)
  { capture_img = cvQueryFrame(iter->second);
    std::map<...>::iterator cam_iter = camWindow_array.find(window_name);
    cam_iter->second->ShowImage(capture_img);}}
\end{lstlisting}

Para más información se puede consultar la sección \ref{detallesImp:ModuloPercepcion}, página \pageref{detallesImp:ModuloPercepcion}.

\item CamWindow: Esta clase es utilizada para encapsular la creación de ventanas mediante las herramientas que provee OpenCV, de forma que se adapten a la interfaz IGUIWindows. Esto permitirá su acceso y gestión desde el módulo de GUI. Se elige usar los mecanismos que ofrece OpenCV para la creación de ventanas para simplificar el uso de las mismas y permitir su actualización a partir de las herramientas propias de la librería, sin necesidad de estar delegando ni transmitiendo información innecesariamente entre módulos. 
\begin{lstlisting}[language=C++]
namespace core { namespace ipercept {	
class CamWindow : public core::IGuiWindow
{ public:   ...
  private:
   std::string window_name;
   bool isShown;
};}}

CamWindow::CamWindow(const std::string &_window_name)
{ cvNamedWindow(window_name),1);
  core::igui::MainGui::GetInstance()->RegisterWindow(((core::IGuiWindow*)this)); }

void CamWindow::ShowImage(const IplImage *image)
{ if (isShown) cvShowImage(window_name, image);}
\end{lstlisting}

\end{itemize}

\subsubsection{Módulo de Producción}
$\backslash$src$\backslash$iprod
\\

Siguiendo el mismo modelo que en los módulos comentados anteriormente, la clase principal que implementa la interfaz IProd recibe el nombre de MainProd. Es a través de esta interfaz como se manejará el contenido a generar para construir y exponer el entorno. En esta primera demo el obejtivo es integrar un motor gráfico que sea capaz de visualizar una escena 3D por defecto, con sonido 3D en un sistema envolvente, mostrando una cantidad configurable de ventanas.
\\

De la misma forma que en el resto de los casos, este módulo se ejecuta en un hilo independiente, utilizando los mecanismos de sincronización necesarios para el manejo de hilos gracias a la librería Boost (\ref{detallesImp:Boost}). Por otro lado, el motor gráfico integrado es Panda3D. Sin embargo, es necesario destacar que fueron necesarios ajustes en las opciones de compilación del mismo para que las librerias generadas pudieran funcionar correctamente dentro del proyecto. También impone algunas limitaciones como una política restrictiva en el nombrado y jerarquía de directorios, así como algunas modificaciones en los fuentes poco comunes pero que fueron necesarias realizar y aceptadas en la revisión oficial. Para más detalles, consultar \ref{detallesImp:Panda3D}, página \pageref{detallesImp:Panda3D}. 
\\

Finalmente para la localización de las fuentes de sonido y del oyente en el espacio 3D, se ha hecho uso de la librería SFML. De nuevo, es necesario destacar la necesidad de realizar modificaciones en el código fuente de la libreria para que ésta funcione correctamente. Esto es debido que existen errores en el diseño de la API que impide que pueda situarse libremente al oyente en el espacio 3D. Para ver más detalles sobre la integración de esta librería y las modificaciones necesarias se puede consultar la sección \ref{detallesImp:SFML}, página \pageref{detallesImp:SFML}.

\begin{itemize}
\item MainProd: Implementa la interfaz IProd y provee los mecanismos para cargar una escena 3D y mostrarla en una cantidad de ventanas configurable. También carga y localiza en el espacio sonidos y el oyente.

\begin{lstlisting}[language=C++]
namespace core { namespace iprod {
class MainProd : public core::IProd
{ public: ...
  private:
   static void CreateDefaultWindows(int numWindows);
   static void LoadDefaultScene();

   static PandaFramework framework;
   static std::map<int, WindowFramework*> pandawindows_array;
   static std::map<int, NodePath>         windowcamera_array;
   static NodePath cam_viewpoint, origin, up;
   static double listener_position[],listener_target[],sound_pos[];
   static sf::Sound Sound;
};}}
\end{lstlisting}

Las secciones más relevantes son la carga de la escena y el render de las distintas vistas. Por otro lado, se tienen en cuenta políticas de rendimiento y se trata que la escena sea ligera. Por ejemplo, los objetos se cargan una sóla vez para el marco principal y se instancian como referencias en los grafos de escena del resto de vistas, sin necesidad de cargar varias veces el mismo modelo.
\\

Para poder realizar pruebas para comprobar el buen funcionamiento y para preparar trabajo futuro, se añade un mecanismo para el acceso externo a la escena, donde realizar operaciones DoStuff(). En este caso, rotar la cámara. Así mismo, se habilita la navegación libre en la segunda ventana de visualización mediante el uso del ratón (para comprobar que el correcto funcionamiento de la localización 3D tanto de oyente como de sonidos posicionados). 
\\

Gran parte del código se asemeja a los módulos explicados anteriormente, siguiendo por coherencia la misma política de incialización, ejecución del hilo independiente, y bloques de codigo a ejecutar en cada iteración. por lo que sólo se detallanA continuación se muestran las secciones de código más relevantes:
\begin{lstlisting}[language=C++]
void MainProd::DoMainLoop()
{ framework.open_framework(m_argc,m_argv);
  CreateDefaultWindows(DEFAULT_NUM_WINDOWS);
  LoadDefaultScene();
  sf::SoundBuffer Buffer;
  Sound.SetBuffer(Buffer);
  
  while(!stop_requested) 
  { Iterate();
    m_thread->sleep(get_system_time()+milliseconds(10)); }

  framework.close_all_windows();
  framework.close_framework();}
\end{lstlisting}

Algo a destacar es la función Iterate(). Por lo general, los motores gráficos y de juego toman posesión del bucle principal de la aplicación. Este también es el caso del motor de juego elegido, Panda3D. Esta peculiaridad limita el número de actividad y la facilidad con la que nuevas tareas pueden ser añadidas, o no sólo añadidas, sino generadas mientras se ejecuta la aplicación. Sin embargo, la flexibilidad del motor escogido permite abstraerse de las secciones de inicialización y del bucle principal, de forma que se pueden ejecutar las tareas de cada iteración mediante el método step(). Gracias a este mecanismo podemos disponer de la ejecución del bucle principal en un hilo aparte, mientras se ejecutan o generan tareas y objetos dinámicamente y de forma sincronizada, desde el mismo u otros hilos.

\begin{lstlisting}[language=C++]
void MainProd::Iterate()
{ boost::try_mutex::scoped_try_lock lock(m_mutex);
  if (lock)
  { framework.do_frame(graphic_thread);
    CIntervalManager::get_global_ptr()->step();}}

void MainProd::DoInit()
{ if (!initialized)
	{ assert(!m_thread);
      m_thread = boost::shared_ptr<boost::thread>(new boost::thread(boost::function0<void>(&MainProd::DoMainLoop)));}}
\end{lstlisting}
Como se comentaba, el siguiente fragmento de código muestra la forma en que, desde la ejecución de otro hilo puede solicitarse a la clase realizar determinadas tareas. En este caso, se rota la cámara de la primera vista para que gire entorno al centro de la escena, a la vez que se actualiza la posición del oyente en el espacio 3D según la posición de la cámara, con navegación mediante el movimiento del ratón, de la vista2. 
\\

Es necesario tener en cuenta dos puntos en relación al sonido 3D en la aplicación para un sistema envolvente. Por un lado los sistemas de referencia espacial del motor gráfico y del motor de audio no coinciden, por lo que es necesario realizar las transformaciones pertinentes. Por otro lado, la librería de audio utilizada comete errores importantes que deben ser solucionados para poder disponer de un posicionamiento y orientación correctos de las fuentes de sonido y del oyente. Estos detallen pueden verse con mayor profundidad en la sección \ref{detallesImp:SFML}, página \pageref{detallesImp:SFML}.

\begin{lstlisting}[language=C++]
void MainProd::DoDoStuff()
{ boost::try_mutex::scoped_try_lock lock(m_mutex);
  if (lock && initialized)
  { //rotar la cámara en vista 1
    windowcamera_array[1].set_pos(20*sin(angleradians),-20.0*cos(angleradians),3);
    windowcamera_array[1].set_hpr(angledegrees, 0, 0);
    //actualizar oyente según navegación en vista 2
    sf::Listener::SetPosition(new_pos.get_x(), new_pos.get_y(), new_pos.get_z());
    sf::Listener::SetTarget(new_at.get_x(), new_at.get_y(), new_at.get_z() , new_up.get_x(), new_up.get_y(), new_up.get_z());
   }
   else 
   { //no se pudo coger el cerrojo, pero no se bloquea  }
}
\end{lstlisting}
Finalmente se muestra fragmentos que ilustran la carga de la escena y cómo se enlazan a los disintos renderers. Como se comentaba inicialmente, y como es lógico, se ha tenido en cuenta cuestiones de eficiencia para visualización en múltiples vistas. Como en el problema al que nos enfrentamos la escena a visualizar es la misma para todas las vistas, se sigue la política de cargar una única vez los elementos en la escena, ligarlos al render principal e instanciarlos para el resto, de forma que sólo se cargan una vez y no existen copias del mismo objeto en los distintos grafos de la escena.
\begin{lstlisting}[language=C++]
void MainProd::LoadDefaultScene()
{ if (pandawindows_array.begin() != pandawindows_array.end())
  { NodePath environment = pandawindows_array[1]->load_model(framework.get_models(),"environment");
    environment.reparent_to(pandawindows_array[1]->get_render());
    NodePath pandaActor = pandawindows_array[1]->load_model(framework.get_models(), "panda-model");
    pandaActor.reparent_to(pandawindows_array[1]->get_render());
    pandawindows_array[1]->load_model(pandaActor, "panda-walk4");
    pandawindows_array[1]->loop_animations(0);

    std::map<...>::iterator iter = pandawindows_array.begin(); iter++;
    while(iter != pandawindows_array.end())
    { environment.instance_to(iter->second->get_render());
      iter->second->setup_trackball();
      iter++;}}}
\end{lstlisting}

\item Prod3DWindow: Esta clase es utilizada para encapsular la creación de ventanas mediante las herramientas que provee Panda3D, de forma que se adapten a la interfaz IGUIWindows. Esto permitiría su acceso y gestión desde el módulo de GUI. De la misma forma que sucede en el módulo de Percepción para la visualización de la entrada de datos en distintas ventanas, se utiliza por simplicidad las herramientas propias de la librería para la creación de las mismas y la actualización de su contenido.
\begin{lstlisting}[language=C++]
namespace core { namespace iprod {
class Prod3DWindow : public core::IGuiWindow
{ public:
   WindowFramework *GetWindowFrameWork() {return m_windowFramework;}
  private:
   bool isShown;
   WindowFramework *m_windowFramework;};}}
\end{lstlisting}
\end{itemize}

\subsubsection{Aplicación Principal}\label{sec:AplicacionPrincipal}
$\backslash$apps$\backslash$vox
\\

Finalmente se muestra la sección correspondiente a la aplicación principal. Su objetivo es enmarcar los múltiples módulos, gestionar la ejecución de la misma y de sus componentes.
\\

Algo a tener en cuenta es que al usar wxWidgets como librería para crear la interfaz de usuario de la aplicación, se impone un requisito incómodo: wxwidgets necesita tomar control de la aplicación principal. Esto impide la completa independencia entre la aplicación y la librería usada para la GUI. Sin embargo, hay que tener en cuenta que la Aplicación principal no hará nada: esta sección está únicamente destinada la carga de los distinto módulos. Por ello, su complejidad y contenido son mínimos. Es por ello que se decide proseguir.
\\
En el caso de desear cambiar el módulo de GUI, son dos los cambios necesarios en la aplicación: eliminar la herencia de la clase wxApp, y sustituir la macro IMPLEMENT\_MIIAPP(Application) por un cuerpo main() donde se cree una instancia de la clase Application.
\\

A continuación se muestran algunos detalles relevantes:

\begin{itemize}
\item Application: Implementa la interfaz IApplication que se usa para la creación de la aplicación. Su cometido es cargar los distintos módulos y proveer herramientas para su gestión. En caso de no desear usar wxWidgets como librería para la GUI, es necesario eliminar la herencia de la clase a wxApp.
\\

También hay que tener en cuenta que, en Windows, por motivos de incompitibilidades entre librerias, es necesario incluir la cabecera winsock2.h al inicio del fichero. Para más detalles se puede consultar la sección \ref{detallesImp:Incompatibilidades}, página \pageref{detallesImp:Incompatibilidades}

\begin{lstlisting}[language=C++]
#ifdef _WINDOWS
#include <winsock2.h>
#endif
class Application : public wxApp, public core::IApplication
{ public:    ...
  private:
   core::IGui		*app_maingui;
   core::IPercept	*app_mainpercept;
   core::IProd		*app_mainprod;};

bool Application::OnInit()
{ app_maingui = MainGui::GetInstance("VOX");
  app_mainpercept=(core::IPercept*)new core::ipercept::MainPercept(); 
  app_mainprod=(core::IProd*)new core::iprod::MainProd(argc, argv); 
  app_mainpercept->Init();
  app_mainprod->Init();
  return true; }
\end{lstlisting}

\item Main: Fuente en el que se define el punto de entrada de la aplicación. En caso de no desear usar wxWidgets es necesario sustituir la línea IMPLEMENT\_MIIAPP(Application) por la definición de una función main(), donde crear una instancia de la clase Application.

\begin{lstlisting}[language=C++]
#define _WINSOCKAPI_
#include "Application.h"
IMPLEMENT_MIIAPP(Application)
\end{lstlisting}
\end{itemize}


\section{Validación y Publicidad}
\subsection{Validación}
Se sigue una filosofia de pruebas continuas para resolver en el momento en que aparecen los incidentes que puedan surgir al hacer cambios. Así mismo, cuando se añade una nueva funcionalidad, se usan mecanismos para comprobar que que las capacidades incorporadas funcionan correctamente y se mantiene un buen rendimiento.

\begin{itemize}
\item Comprobación de uso de recursos de la máquina mediante las herramientas del sistema. En la máquina en la que se desarrolla la aplicación muestra consumir un 5\% de CPU y 75Mb de memoria mantenidos. Hay que destacar la posibilidiad de que la aplicación consuma mayor CPU en máquinas con menor cantidad de procesadores debido al overhead introducido por la gestión de hilos. Sin embargo, la tendencia actual se mueve hacia el aumento de número de procesadores.
\item Comprobración de la ejecución y cierre correctos, sin salidas de la aplicación inesperadas ni memory leaks.
\item Uso de herramientas para medición de frames por segundo para comprobar el rendimiento de la ventana de render. Se comprueba que se mantiene siempre a 60fps para dos ventanas, y 30fps con hasta 10 ventanas de render. Hay que tener en cuenta que 60 es el límite máximo impuesto por la sincronización vertical del monitor.
\item Uso de distintas opciones de configuración para comprobar las variantes del uso de los módulos, por ahora mediante macros: Abrir distinto número de ventanas de render (entre 1 y 10) y captura desde distintas cantidades de cámaras web (entre 1 y 2).
\end{itemize}

Las características de la máquina de referencia son las siguientes:

\begin{itemize}
\item Procesador Intel Core i7 CPU 870 2.92Ghz (4 núcleos reales con hyperthreading, símil 8 núcleos).
\item 6Gb de Memoria Principal.
\item Sistema Operativo Windows 7 64 bits
\item Tarjeta gráfica GeForce GTS 240
\end{itemize}

Finalmente, se muestran capturas de ejemplo del estado actual de la aplicación, como pueden verse en las siguientes imágenes:

\begin{figure} [H]
\begin{center}
\includegraphics[width=\textwidth]{recursos_memoria/screenshot_20100214_p.jpg}
\end{center}
\caption{ \label{F_CapturaFase2PrimeraDemo_Fig1} Captura 1 - Fase2: Primera Demo}
\end{figure}
\begin{figure} [H]
\begin{center}
\includegraphics[width=\textwidth]{recursos_memoria/6windows_30fps_release_01_p.jpg}
\end{center}
\caption{ \label{F_CapturaFase2PrimeraDemo_Fig2} Captura 2 - Fase2: Primera Demo}
\end{figure}

\subsection{Publicidad}
Aunque el desarrollo del proyecto se encuentra aún en sus inicios se considera interesante tener una visión del panorama actual y valorar distintas opciones de publicidad e incluso posibles destinos para la exposición de la instalación. Además, se considera la creación de un portal web para la iniciativa, donde alojar el el entorno de trabajo resultante, asi como el proyecto. 
\\

Se valora establecer contacto con las siguientes instituciones:
\begin{itemize}
\item ULPGC.
\item CAAM: Centro Atlántico de Arte Moderno.
\item Gran Canaria Espacio Digital.
\item Museo Elder de la Ciencia y la Tecnología.
\item La Casa Encendida.
\end{itemize}
Posibles festivales:
\begin{itemize}
\item Artfutura
\item Arco
\item Estampa
\item Sónar
\end{itemize}

\chapter{Etapa 3: Usuario, Entorno, Configuración y Persistencia}
Partiendo de la primera demo estable, se desea añadir añadir nuevas funcionalidades para completar la aplicación. En este punto se dispone de la estructura básica de la aplicación y de las herramientas necesarias para la captura de información y la reproducción de las vistas. Ahora se abordará el problema de la creación de usuarios, proyectos, escenas y su gestión. También se trabajará en las opciones de configuración del sistema básicas.
\\

El punto más relevante en esta etapa consiste en el modelo de persistencia a seguir. Para ello, se propone hacer uso de una base de datos para guardar a los usuarios y sus escenarios, teniendo en mente la posibilidad de implementar en un futuro un sistema multiusuario persistente. Para este tipo de aplicación, convendría conseguir una Base de Datos Orientada a Objetos, a ser posible en Tiempo Real o con un buen tiempo de respuesta. 
\\

Entre otras ventajas, las OODBMS permiten eliminar la necesidad de un doble modelado de la información. El modelo de la base de datos se corresponde directamente con el modelo de datos de la aplicación. De esta forma se ahorra tiempo de diseño y se evita el problema del desajuste por impedancia. Además no es necesaria ninguna transformación explícita del modelo de datos. Por otro lado, se observan mejores respuestas en estos tipos de bases de datos, especialmente en el caso de accesos de tipo navigacional, es decir, aquellos en los que se accede a objetos a partir de relaciones con otros objetos, caso de esta aplicación.
\\

Sin embargo, tras el estudio realizado no ha sido posible encontrar una herramienta que encaje con los requisitos software del proyecto. De entre las candidatas, EyeDB destacaba por ser la más prometedora; sin embargo, actualmente sólo está disponible para sistemas Linux. Del resto, o no disponían de licencias gratuitas, éstas eran muy limitadas, no disponían de APIs para C++ o las librerías eran antiguas y estaban abandonadas. Finalmente, se decidió apostar por usar una opción intermedia. 
\\

Finalmente, se usará una BBDD relacional (PostgreSQL), con un mapper objeto-relacional (Debea). Aunque no se disponga de las ventajas de tener una base de datos directamente implementada como Orientada a Objetos, Postgre es actualmente consideraba la mejor opción libre para Bases de Datos Relacionales: potente, veloz y con un buen soporte de transacciones. Por otro lado, con el mapper objeto-relacional Debea se conservarán los beneficios para el desarrollo al eliminar la traducción del modelo OO al modelo relacional y simplificar la capa de persistencia. De esta forma se relega el problema del desajuste por impedancia al mapper. Con esto se espera reducir significativamente el tiempo de desarrollo y mantener un modelo fácil de mantener y flexible frente a cambios futuros.

\section{Análisis}
\subsection{Análisis de Requisitos de Usuario}

El subconjunto de funcionalidades añadidas se centran en la gestión de usuarios y de escenas con sus Entidades, además del equema de persistencia y la configuración de la aplicación. 
\\

En el apartado de Gestión, la aplicación permitirá dar de alta nuevos usuarios, crear o cargar entornos con entidades asociadas y editar sus propiedades. 
\\

De esta forma se permite la creación y borrado de usuarios, la modificación de permisos y que éste haga login en la aplicación. Un usuario registrado puede crear nuevos escenarios, modificar sus permisos, cargarlos o eliminarlos del sistema. Finalmente, esta información será guardada y cargada en futuras sesiones siguiendo el esquema de persistencia discutido. Sin embargo, las escenas y elementos serán objetos de prueba generados manualmente. Tampoco existirá interacción en esta fase.
\\

En relación a la configuración de la aplicación se permitirá guardar datos relacionados a la configuración del sistema instalado en el equipo. Se utilizará para obtener directorios de uso común por los distintos módulos. También se usará para guardar y recuperar la configuración de las cámaras (número, orientación), así como de las ventanas de render (número, resolución, orientación). Se incluye de la misma forma una ventana de log donde los distintos módulos puedan volcar información útil.

\begin{figure} [H]
\begin{center}
\includegraphics[width=\textwidth]{recursos_memoria/casosdeuso_segundademo.png}
\end{center}
\caption{ \label{F_Casos_de_Uso_Etapa3} Diagrama de Casos de Uso. Usuario, Entorno, Configuración y Persistencia}
\end{figure}


\subsection{Selección de Herramientas}

A partir del estudio de las herramientas disponibles se han seleccionado las más adecuadas, tanto por sus características como por compatibilidades técnicas en el conjunto del proyecto.

\begin{itemize}
\item BBDD: PostgreSQL
\item Mapper O-R: Debea
\end{itemize}

\section{Diseño}
\subsection{Diseño de la Aplicación}

Se añaden elementos al módulo IAplication para manejar los conceptos de ususario y proyecto, y se describe el módulo IPersistence. 

\begin{itemize}
\item Core: Conjunto de interfaces de la aplicación.
\begin{itemize}
\item IAplicationConfiguration: Se añade interfaz para la configuración de la aplicación.
\item IPersistence: Interfaz de la capa de Persistencia para el guardado y recuperación de los datos de la aplicación.
\begin{itemize}
\item IUserPersistence: Interfaz que refleja del modelo de datos y persistencia del objeto Usuario. 
\item IWorldPersistence: Interfaz que refleja del modelo de datos y persistencia del objeto Mundo (escenario). 
\item IEntityPersistence: Interfaz que refleja del modelo de datos y persistencia del objeto Entidad. Una entidad es una elemento contenido en un escenario.
\end{itemize}
\end{itemize}
\item igui: Interfaz básica para la creación del módulo y registro de ventanas. Modificaciones para soporte de opciones de configuración. Login, inicio y cierre de sesión de usuarios.
\begin{itemize}
\item GUIConfiguration: Paneles de Configuración de la aplicación.
\item GUILogPanel: Panel de log donde se muestra información de la aplicación de los módulos que vuelquen datos en él.
\item GUIUser: Panel de login y de creación de nuevos usuarios.
\item GUIUserInfo: Panel de gestión de usuarios y creación y gestión de escenarios.
\end{itemize}
\item ipersistence: Módulo de persistencia
\begin{itemize}
\item EntityPersistence: Refleja el modelo de datos y la persistencia del objeto Entidad.
\item WorldPersistence: Refleja el modelo de datos y la persistencia del objeto Mundo.
\item UserPersistence: Refleja el modelo de datos y la persistencia del objeto Usuario.
\end{itemize}
\item iprod: Módulo de producción
\begin{itemize}
\item Prod3DEntity: Encapsula el modelo de datos del objeto Entidad y gestiona las características particulares relativas al módulo de producción.
\end{itemize}
\item vox: 
\begin{itemize}
\item ApplicationConfiguration: Implementación de los mecanismos para guardar y cargar las opciones de configuración de la aplicación.
\end{itemize}
\end{itemize}

\subsubsection{Breve descripción de los módulos}
Los cambios principales se realizan en los módulos de Aplicación, GUI y Persistencia.\\

En el primero se introducen los controladores de sesión y de configuración y la API necesaria para su uso desde otros módulos. En GUI, se añade un controlador genérico y las interfaces gráficas necesarias para la configuración del sistema y para el inicio de sesión en la misma por parte de usuario. Finalmente, en el módulo de Persistencia se modelan los objetos a conservar y los mecanismos para poder guardarlos y recuperarlos en la base de datos. \\

Por otro lado, tanto el módulo de persistencia como el de GUI, así como el de percepción y producción reciben ajustes para poder usar las opciones de configuración. \\

Como modelo, recordar que cada módulo es responsable de las tareas a su cargo y las comunicaciones se establecen a través de los módulos principales. Ellos disponen de todos los mecanismos necesarios para realizarlas, delegando en su caso en controladores, y ofreciendo una API sencilla de usar. I.e., cuando el usuario introduce los datos de inicio de sesión el controlador de GUI recibe los datos desde el panel de la interfaz, que termina accediendo al módulo principal de GUI para que llame al módulo principal de aplicación, que es el responsable de gestionar la sesión. En este punto, la aplicación hace uso del controlador de sesión que terminará accediendo al módulo de persistencia para recuperar los datos.
\newpage

\subsubsection{Diseño General en UML}
\begin{figure} [H]
\begin{center}
\includegraphics[width=\textwidth]{recursos_memoria/DiagramadeclasesUML_SegundaDemo.png}
\end{center}
\caption{ \label{F_DiagramadeClasesUML_SegundaDemo} Diagrama de Clases UML, Segunda Demo. Resumen.}
\end{figure}

En este momento se aborda de lleno el módulo de persistencia, añadiendo los elementos Usuario, Mundo (Escenario) y Entidad. Este módulo será accedido para cargar o guardar los datos que se desean conservar. Por otro lado, también se da la posibilidad de configurar elementos de la aplicación, como pueden ser características relacionadas a los dispositivos de entrada o salida del sistema. Además se añade la capacidad de hacer login en la aplicación para cargar los mundos que tenga asociados un usuario, crear escenarios nuevos o editar propiedades del mismo.\\
 
Por simplicidad, en el diagrama se muestran sólo los detalles principales. Para ver los detalles se puede consultar las secciones siguientes.

\subsubsection{Diseño en UML - Núcleo de la Interfaz}

\begin{figure} [H]
\begin{center}
\includegraphics[width=\textwidth]{recursos_memoria/DiagramadeclasesUML_SegundaDemo_core.png}
\end{center}
\caption{ \label{F_DiagramadeClasesUML_SegundaDemo_Core} Diagrama de Clases UML, Segunda Demo. Núcleo de la Interfaz.}
\end{figure}

Se introducen cambios de relevancia en la mayoría de las clases, especialmente debido al uso de la interfaz de configuración que usarán los módulos. También cabe destacar el desarrollo de la interfaz de Persistencia que usarán aquéllos módulos que requieran acceder o guardar datos que se deseen conservar.\\

IApplicationConfiguration está destinada a sevir de interfaz para conservar datos de directorios de relevancia, como pueden ser el de datos genéricos, recursos de la aplicación, modelos 3D, sonidos o imágenes, lenguaje, datos de conexión con el dispositivo de almacenamiento, el número de cámaras, el número de displays, además de la configuración particular de los mismos (localización en el espacio de la instalación, orientación y resolución).\\

Por otro lado tenemos las interfaces de persistencia. Es interesante recordar que se tiene como objetivo independizar los detalles de implementación de los módulos entre sí, de forma que sean fácilmente sustituíbles por otros nuevos, sin necesidad de realizar modificaciones en los demás. También se ha optado por un diseño de persistencia en el que existe una correspondencia directa entre el modelo OO y el modelo de datos a persistir. Por ello el modelo fundamental de los datos recae en el mismo módulo de persistencia. Como puede verse, es un esquema bastante simple en el que existen tres objetos: usuarios, mundos y entidades. \\

Los usuarios tienen los datos clásicos de conexión, para hacer login en el sistema pero también datos relativos a su experiencia dentro del mismo, como pueden ser desde la localización o permisos, hasta el término nombrado como psique. Psique es una codificación de la conducta y actividades que realiza el usuario en el sistema que será abordada más adelante. Para más detalles al respecto, consultar sección ?? página ??.\\

Las entidades son los elementos componentes de un mundo. Hasta este punto sólo se ha tenido en cuenta que sean elementos 3D posicionados en el espacio. Estas entidades también actúan y sufren experiencias que se conservará en la codificación psique, que a su vez influirá en sus acciones siguientes.\\

Finalmente, los mundos son espacios creados por un usuario y que contendrán colecciones de entidades conservando una visión global de la experiencia en su atributo psique. Como es razonable desear que un escenario permanezca inalterable, o poder acceder sólo a determinadas opciones en él, el usuario puede definir unos permisos sobre cada mundo. 
\newpage

\subsubsection{Diseño en UML - Módulo de Aplicación}

\begin{figure} [H]
\begin{center}
\includegraphics[width=\textwidth]{recursos_memoria/DiagramadeclasesUML_SegundaDemo_vox.png}
\end{center}
\caption{ \label{F_DiagramadeClasesUML_SegundaDemo_Vox} Diagrama de Clases UML, Segunda Demo. Módulo Principal de la Aplicación.}
\end{figure}

El módulo principal de la aplicación es el responsable de todas las acciones fundamentales del mismo. Es el responsable de instanciar y gestionar los módulos necesarios y suministrar métodos para la manipulación de la aplicación. \\

De esta forma, es ahora también responsable de la configuración de la aplicación, que realiza mediante el controlador ConfigurationController, así como de la sesión mediante SessionController.\\

SessionController da capacidades para cargar los datos de un usuario y permitir su entrada en el sistema, así como su salida, además de capacidades para saber cuál es el usuario y escenario actuales, o si un determinado usuario o escenario es el actual. Se entiende como sesión el estado en el cual un usuario que accede al sistema carga de un escenario para comenzar el uso del mismo. Esto es, se establece una sesión cuando se asigna un usuario y un escenario en el sistema.\\

Por su lado, ConfigurationController es usado fundamentalmente al comienzo y final de la aplicación para cargar y guardar datos relativos al funcionamiento de la misma. Por ello, sus métodos principales son Load y Save.

\subsubsection{Diseño en UML - Módulo de Persistencia}

\begin{figure} [H]
\begin{center}
\includegraphics[width=\textwidth]{recursos_memoria/DiagramadeclasesUML_SegundaDemo_ipersistence.png}
\end{center}
\caption{ \label{F_DiagramadeClasesUML_SegundaDemo_IPersistence} Diagrama de Clases UML, Segunda Demo. Módulo de Persistencia.}
\end{figure}

En este módulo se implementan las interfaces definidas referentes a persistencia en el núcleo de la interfaz y son un reflejo del mismo adaptado a la implementación final. Como se ha comentado se ha optado por fusionar los conceptos del modelo de objetos y modelo de persistencia. Siendo así la gestión de la persistencia de un objeto recae sobre él mismo (pe. para crear un objeto basta instanciarlo, y para guardar sus datos basta con llamar a su método 'Save'). Esta fusión podrá verse en mayor detalle en la sección de Implementación.\\

Como con el resto de módulos independientes existe un núcleo principal que será el encargado de iniciar el dispositivo de almacenamiento y de atender peticiones de otros módulos. Estas peticiones son consultas que pueden hacerse sin necesidad de instanciar el objeto, por ejemplo, para saber si un usuario determinado o un mundo existe u obtener la lista de mundos que un usuario puede ver. 

\subsubsection{Diseño en UML - Módulo de GUI}

\begin{figure} [H]
\begin{center}
\includegraphics[width=\textwidth]{recursos_memoria/DiagramadeclasesUML_SegundaDemo_igui.png}
\end{center}
\caption{ \label{F_DiagramadeClasesUML_SegundaDemo_IGUI} Diagrama de Clases UML, Segunda Demo. Módulo de Persistencia.}
\end{figure}

Una de las primeras consecuencias lógicas con la entrada de la capacidad para gestionar la configuración de la aplicación es su impacto sobre la interfaz gráfica de usuario. Este impacto se debe, por un lado, a la necesidad de localizar recursos estéticos como las imágenes de los botones, siendo el caso más común y básicamente el que sucede sobre las clases previamente existentes. Por otro lado, es también a través de la interfaz de usuario como éste va a editar los parámetros de configuración del sistema, mediante el panel de configuración. Además puede verse cambios relativos al uso del sistema, como son los paneles de login, de gestión de la información del usuario, y de log del sistema.\\

De esta forma, tenemos por un lado el panel GUIConfiguration. Este panel permitirá al usuario cambiar la cantidad de cámaras de las que se alimentará el módulo de Percepción, así como los parámetros de las mismas. De igual forma, podrá establecer la cantidad de displays que se mostrarán y su configuración, administrando vistas independientes de la escena. Gracias a esta posibilidad se dota de una gran flexibilidad al sistema para establecer modelos de instalaciones distintos: posibilidad de vision estéreo, frontal-cenital, etc. o espacios de escritorio, proyecciones frontales o sistemas Cave que envuelven al usuario con pantallas.\\

Por otro lado, tenemos el panel GUIUser, desde el cual un usuario podrá hacer login en el sistema o registrarse en el mismo como nuevo usuario. Este panel está estrechamente relacionado con GUIUSerInfo, que muestra al usuario actual la lista de mundos que ha creado y donde le permite modificar sus atributos, así como crear nuevos usuarios, destruirlos o borrarse él mismo del sistema.\\

Finalmente, se ha añadido un panel de log en el cual se mostrará información de interés del funcionamiento del sistema.\\

Hay que tener en cuenta que estas interfaces son sólo componentes que muestran y capturan información. No contienen ninguna lógica relevante de aplicación. Para estas tareas se hace uso, como es lógico, de un controlador. Sin embargo, las necesidades son mínimas y en su mayor parte este controlador sólo derivará las acciones hacia sus responsables. Por ello y por simplicidad, se ha decidido usar un controlador genérico para todo el módulo. Este controlador responderá a las necesidades de gestión de los paneles, para mostrar unos u otros. Pero a su vez, también encauzará las peticiones del usuario al interactuar con la interfaz, hacia el responsable de su gestión (pe. para crear un usuario nuevo o cargar un escenario).

\subsubsection{Diseño en UML - Módulo de Producción}

\begin{figure} [H]
\begin{center}
\includegraphics[width=\textwidth]{recursos_memoria/DiagramadeclasesUML_SegundaDemo_iprod.png}
\end{center}
\caption{ \label{F_DiagramadeClasesUML_SegundaDemo_IProd} Diagrama de Clases UML, Segunda Demo. Módulo de Producción.}
\end{figure}

Durante esta fase los cambios en el Módulo de Producción son moderados. Por lado, usará la información de los parámetros de configuración para los displays que mostrará; por otro, se le ha añadido capacidad para limpiar y cargar datos en la escena. Estos datos serán los relativos al mundo que el usuario desee cargar.\\

De esta forma, destacan los métodos RunWorld() y CloseWorld(), que cargan un escenario y libera la escena respectivamente. También LoadEntityIntoScene() que carga una entidad persistida dentro de la escena, o LoadDefaultScene() que carga una escena sencilla por defecto, que se usará con carácter estético cuando no hay cargado ningún escenario.\\ 

Por otro lado, se puede ver que aparece una nueva clase llamada Prod3DEntity. Esta nueva clase representa las entidades 3D cargadas en la escena, que efectivamente se corresponderán con las Entidades persistidas que forman un escenario. Prod3Dentity encapsula los datos de EntityPersistence y añade información concreta dependiente de la implementación, relacioanda con el motor gráfico. En este punto, esta información es concretamente el nodo del grafo de la escena.

\subsubsection{Diseño en UML - Módulo de Percepción}

\begin{figure} [H]
\begin{center}
\includegraphics[width=\textwidth]{recursos_memoria/DiagramadeclasesUML_SegundaDemo_ipercept.png}
\end{center}
\caption{ \label{F_DiagramadeClasesUML_SegundaDemo_IPercept} Diagrama de Clases UML, Segunda Demo. Módulo de Percepción.}
\end{figure}

Al igual que en el caso del módulo de Producción, este módulo sufre pocos cambios. En realidad incluso menos, ya que en esta fase del desarrollo no se abordarán funcionalidades nuevas en la percepción. Sin embargo, el módulo sí se ve afectado por los parámetros de configuración de la aplicación, permitiendo establecer el número de cámaras desde las que se capturan imágenes y los parámetros de las mismas.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementación}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Los módulos afectados en la presente fase son los siguiente:

\begin{itemize}
\item core: Añadida interfaz de configuración de aplicación IApplicationConfiguration.
\item igui: añadidas interfaces gráficas para la gestión de usuarios, escenas y paneles de configuración de la aplicación.
\item ipercept: Configuración del módulo.
\item ipersistence: Persistencia de los objetos usuario, mundo y entidad.
\item iprod: Configuración del módulo.
\item vox: Controlador de la configuración de la Aplicación.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Núcleo de la Interfaz}
$\backslash$src$\backslash$core
\begin{itemize}
\item IApplicationConfiguration: Interfaz destinada a la configuración de la aplicación y que puede ser usada por parte de los módulos con independencia de la implementación final. 
\\
Algunas características son, sin embargo, inherentes a la naturaleza de los módulos y los dispositivos genéricos. Hablamos del caso de las propiedades clásicas de los dispositivos de entrada como son las cámaras y de salida como las ventanas de visualización. Algunas de estas opciones son la resolución y orientación de los mismos. De esta forma, se añaden las clases CameraData y DisplayData.
%\\

\begin{lstlisting}[language=C++]
class DisplayData
{ public:
   DisplayData() : x(0),y(0),z(0),flip_h(false),flip_v(false), resolution_x(800),resolution_y(600){}
   ~DisplayData() {}
   double x, y, z;
   bool flip_h, flip_v;
   unsigned int resolution_x, resolution_y; };
\end{lstlisting}

Finalmente, se añaden los métodos a utilizar para acceder y modificar las opciones de configuración de la aplicación. Se muestran algunas de las principales. Para ver más detalles consultar la sección \ref{detallesImp:InterfacesCore}, página \pageref{detallesImp:InterfacesCore}.  

\begin{lstlisting}[language=C++]
class IApplicationConfiguration
{ public:
   virtual unsigned int GetNumCams()     = 0;
   virtual unsigned int GetNumDisplays() = 0;   
   virtual core::CameraData  GetCameraData(const int &id)=0;
   virtual core::DisplayData GetDisplayData(const int &id)=0;	
   virtual std::string GetSDHost() = 0;
   virtual std::string GetSDPort() = 0;
   virtual std::string GetSDPassword()          = 0;
   virtual std::string GetUIResourceDirectory() = 0;			
\end{lstlisting}

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Aplicación Principal}
$\backslash$apps$\backslash$vox

Se añade la clase ApplicationConfiguration que representa el modelo de datos de la configuración del sistema, y los controladores ConfigurationController y SessionController. Se describen a continuación:

\begin{itemize}
\item $\backslash$apps$\backslash$ApplicationConfiguration: Implementa la interfaz IApplicationConfiguration que peude verse en el apartado anterior, disponiendo de los mismo métodos para obtener y asignar valores.
\item $\backslash$apps$\backslash$controllers$\backslash$ConfigurationController: Controllador destinado a la gestión de la configuración. Carga y guarda los parámetros mediate los métodos Load() y Save() de forma estructurada en un archivo de configuración en texto plano llamado config.ini. Como puede verse, para esta tarea se buscan las etiquetas asociadas a cada atributo y toma o guarda directamente su valor. 
\begin{lstlisting}[language=C++]
bool ConfigurationController::Load()
{   if ( config_file.is_open() )
    { while (!config_file.eof())
      { if ( tag == "[DATA_DIRECTORY]" )
        { config_file.getline(str, size);
          app_config->SetDataDirectory(str); }
\end{lstlisting}
Hay que tener en cuenta que la mayoría de los datos son atómicos, es decir, un atributo está asociado sólo con un único valor indivisible. Sin embargo, existen atributos compuestos de múltiples valores que requieren parsing para su lectura y escritura. Este es el caso de la configuración particular de las distintas cámaras y displays. Para ellos se usan etiquetas a modo de separadores para distinguir cada dispositivo y sus atributos.
\begin{lstlisting}[language=c++]
std::string ConfigurationController::ParseDisplayConfig()
{ ...
  unsigned int win_num = app_config->GetNumDisplays();
  for (unsigned int i = 1; i <= win_num; i++)
  { core::DisplayData data = app_config->GetDisplayData(i);
    wop << "::ID::" << i 
    << "::X::" << data.x << "::Y::" << data.y << "::Z::" << data.z 
    << "::FLIPH::" << data.flip_h << "::FLIPV::" << data.flip_v
    << "::RES_X::" << data.resolution_x 
    << "::RES_Y::" << data.resolution_y;	}
  ... }
\end{lstlisting}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Módulo de Persistencia}
$\backslash$src$\backslash$ipersistence\\

La clase principal del Módulo de Persistencia y que implementa la interfaz IPersistence es MainPersistence. Esta clase se encarga de la inicialización del módulo y del dispositivo de almacenamiento. La verdadera intención era hacer uso de una libería que permitiera hacer uso de un esquema de persistencia Orientado a Objetos. Sin embargo, no fue posible encontrar una que cumpliera los requisitos software de la aplicación. Por ello, se decidió adoptar una solución intermedia. De esta forma se decide utilizar una base de datos relacional, PostGreSQL, y un mapper objeto-relacional, Debea. Para ver los detalles de implementación necesarios para configurar el módulo con estas librerías se puede consultar la sección ?? página ??. De esta forma, el mapper permite fusionar el modelo de objeto y el modelo de persistencia en uno. Sin embargo, es interesante saber que, en el fondo, al tratarse el dispositivo de almacenamiento de una base de datos SQL, también se permiten realizar consultas de forma manual.

\begin{itemize}
\item $\backslash$apps$\backslash$MainPersistence: Inicializa la conexión con la base de datos y en caso de no existir contenido, es la responsable de crear las tablas de las entidades e introducir datos por defecto. Para crear las tablas, solicita los esquemas de traducción a las clases de los objetos a persistir. 
\begin{lstlisting}[language=C++]
MainPersistence::MainPersistence(IApplicationConfiguration *app_cfg)
{ std::string db_name = app_cfg->GetSDName();
  std::string db_user = app_cfg->GetSDUser();
  std::string db_passwd = app_cfg->GetSDPassword();
  std::stringstream connect;
  connect << "dbname=" << db_name << " user=" 
          << db_user << " password=" << db_passwd;
  ar.setIdFetcher(new dba::GenericFetcher()); 
  unlink(db_name.c_str());
  ar.open("dbapgsql-static", connect.str().c_str());
  //create needed tables
  ar.getOStream().sendUpdate(counter_create);
  ar.getOStream().sendUpdate((*(UserPersistence::GetSchema())));
  ar.getOStream().sendUpdate((*(EntityPersistence::GetSchema())));
  ar.getOStream().sendUpdate((*(WorldPersistence::GetSchema())));
  //first id //
  ar.getOStream().sendUpdate(dba::SQL("INSERT INTO debea_object_count VALUES (:d)") << 1);
...
\end{lstlisting}
Los modelos de los objetos están ligados directamente a su persistencia, por lo que MainPersistence no tiene responsabilidad explícita sobre la gestión particular de cada uno de ellos. Sin embargo, dispone de mecanismos para consultar la base de datos y obtener información de interés, como puede ser consultar si un usuario o un mundo existe, o recuperar la lista de mundos de los que un usuario es propietario. También permite borrar un escenario o un usuario, sin necesidad de cargarlo en el sistema, o modificar las propiedades de un escenario.\\

\item $\backslash$apps$\backslash$UserPersistence: Representa al objeto usuario y contiene sus datos y métodos para guardarlos y recuperarlos. Como puede verse, la clase hereda de dba::Storeable lo que permitirá hacer uso de los mecanismos de persistencia. Aunque el mapper tiene una API suficiente posee algunas carencias. Por un lado es necesario establecer el esquema de la clase (definición de la tabla en la base de datos) y la relación de las variables con las mismas. 
\begin{lstlisting}[language=C++]
//::MAPPING:: Class name, parent class name and relation name
BEGIN_STORE_TABLE(UserPersistence, dba::Storeable, "user_table")
 BIND_STR(UserPersistence::name,     dba::String, "name"    )
 BIND_STR(UserPersistence::password, dba::String, "password")
 BIND_INT(UserPersistence::psique,   dba::Int,    "psique"  )
 ...
END_STORE_TABLE()
//SQL schema
dba::SQL UserPersistence::schema(
"CREATE TABLE user_table ("
"  id INT PRIMARY KEY,"
"  name VARCHAR,"
"  password VARCHAR,"
"  psique INT,"
...
\end{lstlisting}
Una vez mapeado se pueden crear instancias de la clase que ya tienen capacidad directa de persistencia. Sin embargo, se desea una abstracción completa de la implementación de estos mecanismos, además de un mejor diseño para ofrecer una mejor interfaz de uso. Para ello, se encapsulan los métodos básicos de carga, almacenamiento y borrado en los métodos Load(), Save() y Delete().
\begin{lstlisting}[language=C++]
bool UserPersistence::Load(const int &id)
{ try 
  { boost::mutex::scoped_lock lock(m_mutex);
    UserPersistence new_object;
    dba::SQLIStream istream = ar->getIStream();
    istream.setWhereId(id);
    bool success = istream.get(&new_object);
    this->operator =(new_object);
    return success; } 
  catch (const dba::SQLException& pEx){ ProcessException(pEx); }
  catch (const dba::Exception& pEx)   { ProcessException(pEx); }
  return false;
} 
void UserPersistence::Save()
{ try 
  { boost::mutex::scoped_lock lock(m_mutex);
    ar->getOStream().put(this);	} 
  catch (const dba::SQLException& pEx){ ProcessException(pEx); }
  catch (const dba::Exception& pEx)   { ProcessException(pEx); }
} 
void UserPersistence::Delete()
{ try 
  { boost::mutex::scoped_lock lock(m_mutex);
    this->setState(dba::Storeable::stState(DELETED));
    ar->getOStream().put(this); } 
  catch (const dba::SQLException& pEx){ ProcessException(pEx); }
  catch (const dba::Exception& pEx)   { ProcessException(pEx); }
}
\end{lstlisting}
Hay que tener en cuenta que los objetos puedes ser accedidos desde distintos módulos que se ejecutan en hilos en paralelo, por lo que es necesario el uso de cerrojos para sincronizar los accesos. Se utiliza para ello los cerrojos de ámbito que ofrece boost.\\

\item $\backslash$apps$\backslash$EntityPersistence: Es la clase que implementa la interfaz IEntityPersistence que modela el objeto Entidad. Una entidad es un elemento básico de los cuales se compone una escena. Su implementación sigue exactamente el mismo esquema que el caso anterior: un mapeo de variables, una definición de esquema, y métodos que encapsulan la API de Debea para las operaciones de persistencia.\\

Otro detalle a tener en cuenta es la necesidad de un filtro para mapear las variables de tipo Float o Double correctamente, ya que la librería demostraba problemas en sistemas de localización no inglesa, debido a los separadores usados como punto decimal. Estudiado el problema se corrigió y se añadió un filtro adecuado vFloat. Los cambios fueron remitidos y pendientes de admisión en revisión.\\

Finalmente, para reflejar la relación de pertenencia que tienen los escenarios con las entidades, es necesario incluir en el esquema de la tabla de la base de datos una entrada que es la clave ajena de mundo al que pertence.

\begin{lstlisting}[language=C++]
//::MAPPING:: Class name, parent class name and relation name
BEGIN_STORE_TABLE(EntityPersistence, dba::Storeable, "entity_table")
 BIND_STR(EntityPersistence::name,       dba::String, "name"       )
 BIND_FLT(EntityPersistence::position_x, dba::vFloat, "position_x" )
END_STORE_TABLE()
//SQL schema
dba::SQL EntityPersistence::schema(
"CREATE TABLE entity_table ("
"  id INT PRIMARY KEY,"
"  name VARCHAR,"
"  position_x FLOAT,"
"  fk_world INT",
...
\end{lstlisting}

\item $\backslash$apps$\backslash$WorldPersistence: El último modelo de objeto a persistir es el Mundo o escenario. Simplemente define una colección de Entidades y algunos atributos como nombre, permisos o el usuario que creó dicho mundo.\\

Para mapear la lista de entidades que contiene un Mundo se usa la macro BIND\_COL, que establece una relación de cada elemento con la tabla correspondiente y que implica la necesidad de que exista una clave ajena en el esquema de la otra clase.\\

Puede apreciarse que existe una relación similar entre Usuario y Mundo, pero en ese caso no se lleva a cabo por dos motivos: Primero, porque conceptualmente el objeto usuario no se compone de Mundos, y segundo porque, aunque en el desarrollo de este proyecto un usuario sólo puede acceder a los mundos que ha creado, se mantiene una perspectiva abierta para trabajo futuro en la que otros usuarios conectados puedan acceder o compartir cualquier mundo, siendo sus acciones limitadas por los permisos que el creador definiera para el mismo.
\begin{lstlisting}[language=C++]
//::MAPPING:: Class name, parent class name and relation name
BEGIN_STORE_TABLE(WorldPersistence, dba::Storeable, "world_table")
 BIND_STR (WorldPersistence::name,        dba::String, "name")
 BIND_STR (WorldPersistence::owner,       dba::String, "owner")
 BIND_INT (WorldPersistence::permissions, dba::Int,    "permissions")
 BIND_COL (WorldPersistence::entities,    
           dba::stdList<EntityPersistence>, "fk_world")
END_STORE_TABLE()
//SQL schema
dba::SQL WorldPersistence::schema(
"CREATE TABLE world_table ("
"  id INT PRIMARY KEY,"
"  name VARCHAR,"
"  owner VARCHAR,"
"  permissions INT"
\end{lstlisting}

\end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Módulo de GUI}
$\backslash$src$\backslash$igui

\begin{itemize}
\item $\backslash$src$\backslash$igui$\backslash$controllers$\backslash$GUIGenericController: Dado que la lógica asociada al módulo de GUI es simple y con pocas opciones, que además son comunes, se ha incluido un controlador genérico. Este controlador es utilizado para alternar entre la visualización de distintos paneles de GUI, así como para gestionar los accesos a funcionalidades del núcleo principal del módulo, maingui. 

\begin{lstlisting}[language=C++]
class GUIGenericController
{public:
  static GUIGenericController* GetInstance() {return instance;}
  bool CreateUser(const string &name,const string &passwd);
  bool LoginUser(const string &name,const string &passwd);
  bool DeleteUser(const string &name);
  bool DeleteWorld(const string &name);
  void LogOut();
  void ViewUserInfoPanel();
  void ViewLogPanel();
  void ViewConfigurePanel();
  private:
  static GUIGenericController *instance; 
  ... };
\end{lstlisting}

\item $\backslash$src$\backslash$igui$\backslash$GUIUser: Interfaz destinada al acceso de los usuarios, mediante nombre y contraseña, y para la creación de nuevas cuentas de usuario. La lógica relacionada al login y a la creación de nuevos usuarios se realiza a través del controlador GUIGenericController. Sin embargo, si las acciones no son responsabilidad de este módulo lo único que hace GUIGenericController es derivarlas al responsable.

\begin{figure} [H]
\begin{center}
\includegraphics[width=\textwidth]{recursos_memoria/gui_user.png}
\end{center}
\caption{ \label{F_CapturaFase3SegundaDemo_GUIUSer} GUI: User login}
\end{figure}

El código de la interfaz es simple y común a las mostradas anteriormente. De forma ilustrativa se muestra el caso de la operación de login. Primero, Se recuperan los valores introducidos por el usuario en los controles, luego se usa el controlador, que relegará la consulta. En caso de no tener éxito la petición se muestran los mensajes de error.

\begin{lstlisting}[language=C++]
BEGIN_EVENT_TABLE(GUIUser, wxPanel)
   EVT_PAINT   (                 OnPaint         )
   EVT_BUTTON  ( wxID_LOGIN    , OnLoginButton   )
   EVT_BUTTON  ( wxID_REGISTER , OnNewUserButton )
END_EVENT_TABLE()

void GUIUser::OnLoginButton(wxCommandEvent& WXUNUSED(event))
{ s_user_name = user_name->GetValue();
  s_user_password = user_passwd->GetValue();
  DoLogin(s_user_name, s_user_password);   }

void GUIUser::DoLogin(const string &name, const string &passwd)
{ GUIGenericController *guiGc = GUIGenericController::GetInstance();
  if (guiGc != NULL) login = guiGc->LoginUser(name, passwd);
  if (login)
  { user_logged_in = true;
    guiGc->ViewUserInfoPanel(); }
  else
  { user_logged_in = false;
    wxMessageDialog message_dialog(this, _("User or password incorrect"), "Message box", wxOK \| wxICON_EXCLAMATION \| wxSTAY_ON_TOP);
    message_dialog.ShowModal(); } }
\end{lstlisting}

\item $\backslash$src$\backslash$igui$\backslash$GUIUserInfo: Interfaz destinada a la gestión del usuario y de sus datos. Desde este panel el usuario puede ver la lista de Entornos que tiene, crear nuevos entornos, borrarlos, modificar sus permisos o lanzarlos para su ejecución en la sesión. Estas acciones se realizan a través del controlador GUIGenericController. 
\\

Como se comentaba en el punto anterior, no es el controlador GUIGenericController el que realiza directamente las acciones de login en el sistema, y tampoco el núcleo principal del módulo de gui. De hecho, sólo derivan las peticiones a los módulos responsables. En este caso, la responsabilidad de gestionar la sesión, así como todas las acciones sobre el sistema caen sobre el módulo principal de la Aplicación, que en este caso, a su vez, relegará en en el controlador de la sesión SessionController, que hará uso finalmente del módulo de Persistencia. Para más detalles a este respecto puede verse ??

\begin{figure} [H]
\begin{center}
\includegraphics[width=\textwidth]{recursos_memoria/gui_userinfo.png}
\end{center}
\caption{ \label{F_CapturaFase3SegundaDemo_GUIUserInfo} GUI: User info}
\end{figure}

\item $\backslash$src$\backslash$igui$\backslash$GUIConfiguration: Este panel de la interfaz está destinado a la configuración de la aplicación. En el puede establecerse el número de cámaras que se van a conectar y el número de ventantas de render que se quieren ver. Además por cada cámara o display se pueden establecer parámetros de configuración, como puede ser su orientación o resolución. Debido a limitaciones de las librerías y a la relevancia de algunos cambios, algunos de éstos requieren el reinicio de la aplicación y de tal forma es notificado al usuario. Por otro lado, hay que tener en cuenta que algunos parámetros, como el calibrado posicional de las cámaras en el espacio, no son usados todavía aunque ya se almacenan y se permite su gestión.

\begin{figure} [H]
\begin{center}
\includegraphics[width=\textwidth]{recursos_memoria/gui_configure.png}
\end{center}
\caption{ \label{F_CapturaFase3SegundaDemo_GUIConfiguration} GUI: Panel de configuración}
\end{figure}

\item $\backslash$src$\backslash$igui$\backslash$GUILogPanel: La última de las interfaces añadidas muestra una ventana donde aparecerán mensajes que puedan resultar de interés enviados desde cualquier módulo de la aplicación. No pretende ser un log exhaustivo del funcionamiento de la aplicación sino una forma de ofrecer información a modo de curiosidad. En el gráfico pueden verse mensajes de incialización, así como la entrada y salida de usuarios en el sistema.

\begin{figure} [H]
\begin{center}
\includegraphics[width=\textwidth]{recursos_memoria/gui_logpanel.png}
\end{center}
\caption{ \label{F_CapturaFase3SegundaDemo_GUILogPanel} GUI: Panel de log}
\end{figure}
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Módulo de Producción}
$\backslash$src$\backslash$iprod
En esta fase el módulo de Producción sufre pocos cambios. Se añade la clase Prod3DEntity que encapsula el objeto entidad añadiendo particularidades propias del motor gráfico y métodos a MainProd que permiten cargar y limpiar la escena.
\begin{itemize}
\item $\backslash$src$\backslash$iprod$\backslash$Prod3DEntity: Como se ha comentado encapsula el objeto EntityPersistence y añade particularidades relacionadas con la implementación del módulo de aplicación. En este caso se añade un puntero al nodo del grafo de la escena que se corresponde con el objeto 3D asociando.
\begin{lstlisting}[language=C++]
class Prod3DEntity
{ public:
  Prod3DEntity(core::IEntityPersistence* ent);
  virtual ~Prod3DEntity();
  std::string GetData()               { return data;     }
  NodePath*	GetNodePath()             { return nodepath; }
  core::IEntityPersistence* GetEntity(){return entity;   }
  void SetData(const std::string &value){data = value;   }
  void SetNodePath(NodePath *value);
 private:
  std::string data;
  core::IEntityPersistence* entity;
  NodePath *nodepath; };
  
Prod3DEntity::Prod3DEntity(core::IEntityPersistence* ent)
{ if (entity != NULL ) data = entity->GetModelData(); }

void Prod3DEntity::SetNodePath(NodePath *value)		
{ nodepath = value; 
  if ( (entity != NULL) && (nodepath != NULL) )
  { float posx, posy, posz, rotx, roty, rotz, scale;
    entity->GetPosition(posx, posy, posz);
    entity->GetOrientation(rotx, roty, rotz);
    entity->GetScale(scale);
    nodepath->set_pos(posx,posy,posz);
    nodepath->set_hpr(rotx, roty, rotz);
    nodepath->set_scale(scale,scale,scale);	} }  
\end{lstlisting}

\item $\backslash$src$\backslash$iprod$\backslash$MainProd: Durante esta fase el módulo de Producción sufre algunos cambios leves, aunque ha tenido que hacerse frente a ciertas dificultades del motor gráfico. Se hace uso de la configuración de la aplicación para mostrar las ventanas de render y se dota de capacidad para cargar y cerrar escenarios. Por ello, cabe destacar los métodos RunWorld(), que lee los datos de un objeto Mundo, extrae sus entidades y las carga en escena, y CloseWorld(), que vacía la escena y limpia los datos internos.

\begin{lstlisting}[language=C++]
void MainProd::CloseWorld()
{ ClearScene();
  { boost::mutex::scoped_lock lock(m_mutex);
    current_user  = NULL;
    current_world = NULL;
    for (unsigned int i = 0; i < scene_entities.size(); i++)
     delete scene_entities[i];
    scene_entities.clear(); } }
bool MainProd::RunWorld(core::IUserPersistence *user, core::IWorldPersistence *world)
{ boost::mutex::scoped_lock lock(m_mutex);
  current_user  = user;
  current_world = world;	
  for (int i=0; i < current_world->GetNumEntities(); i++)
  { IEntityPersistence *ient = current_world->GetEntity(i);
    Prod3DEntity *new_entity = new Prod3DEntity(ient);
    scene_entities.push_back(new_entity);
    LoadEntityIntoScene(new_entity); }
  initialized = true;
\end{lstlisting}

Dentro de RunWorld es usado el método LoadEntityIntoScene() que es usado para cargar las entidades leídas en la escena 3D. Se recuerda que por motivos de eficiencia el modelo 3D leído es cargado sólo en el primer framework, correspondiente a la primera vista, y posteriormente se instancian en el resto.

\begin{lstlisting}[language=C++]
void MainProd::LoadEntityIntoScene(Prod3DEntity * entity)
{ std::string data = entity->GetData();
  scene_nodepaths[entity] = pandawindows_array[1]->load_model(framework.get_models(),data);
  entity->SetNodePath(&(scene_nodepaths[entity]));
  scene_nodepaths[entity].reparent_to(pandawindows_array[1]->get_render());
  std::map<int, WindowFramework*>::iterator iter = pandawindows_array.begin(); iter++;
  while(iter != pandawindows_array.end())
  { scene_nodepaths[entity].instance_to(iter->second->get_render());
    iter++; } }
\end{lstlisting}
Las últimas modificaciones afectan a la configuración de las ventanas de render. Por un lado se cargan los valores de la resolución de cada ventana de render y por otro se realiza una transformación horizontal o vertical de la imagen renderizada. De hecho, por eficiencia lo que se hace es escalar la cámara por el valor -1 en los ejes horizontal o vertical según corresponda. De esta forma no será necesario transformar la imagen después de ser renderizada. Un detalle a tener en cuenta es que al realizar el escalado en uno de los ejes del plano de render, el vector normal se invierte, por lo que la ocultación de caras usada en la escena (cull facing) también debe ser invertido o se verán las caras de los polígonos contrarias a las deseadas.
\begin{lstlisting}[language=C++]
for (unsigned int i = 1; lock && (i <= num_windows); i++)
{ int flip_me_x = (app_config->GetDisplayData(i).flip_h) ? -1 : 1;
  int flip_me_y = (app_config->GetDisplayData(i).flip_v) ? -1 : 1;
  windowcamera_array[i].set_sx(flip_me_x);
  windowcamera_array[i].set_sz(flip_me_y);
  if ( (flip_me_x == -1) ^ (flip_me_y == -1) )
   pandawindows_array[i]->get_render().set_attrib(CullFaceAttrib::make_reverse());
  else
   pandawindows_array[i]->get_render().set_attrib(CullFaceAttrib::make_default()); } }
\end{lstlisting}

\end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Módulo de Percepción}
$\backslash$src$\backslash$ipercept$\backslash$PerceptVideo: Los cambios en este módulo son mínimos y afectan sólamente al establecimiento de los parámetros de configuración. En este caso se aplica una transformación de reflejo horizontal o vertical según se haya especificado en la configuración.
\begin{lstlisting}[language=C++]
if ( app_config != NULL )
{ flip_me_x = app_config->GetCameraData(iter->first).flip_h;
  flip_me_y = app_config->GetCameraData(iter->first).flip_v;  
  if(flip_me_x && !flip_me_y) //Flip Horizontally
  {	IplImage *aux = capture_img;
    cvFlip(capture_img, capture_img, 1); }
  else if(!flip_me_x && flip_me_y) //Flip Vertically
  { IplImage *aux = capture_img;
    cvFlip(capture_img, capture_img, 0); }
  else if(flip_me_x && flip_me_y) //Flip Both
  { IplImage *aux = capture_img;
    cvFlip(capture_img, capture_img, -1); }
\end{lstlisting}

\section{Validación y Publicidad}
\subsection{Validación}
\begin{itemize}
\item Comprobación de uso de recursos de la máquina mediante las herramientas del sistema. En la máquina en la que se desarrolla la aplicación muestra consumir un 4 y un 6\% de CPU, con 21 subprocesos asociados y 85Mb de memoria mantenidos con el escenario por defecto de prueba. Al cargar los distintos escenarios se ven cambios dependiendo de la complegidad de los mismos, lo cual es esperado. 
\item Comprobración de la ejecución y cierre correctos, sin salidas de la aplicación inesperadas ni memory leaks.
\item Uso de herramientas para medición de frames por segundo para comprobar el rendimiento de la ventana de render. No se aprecian cambios en la tasa de frames por segundo que se mantiene a 60fps para dos ventanas de render. Teniendo en cuenta que 60 es el límite máximo impuesto por la sincronización vertical del monitor.
\end{itemize}
Se muestran algunas capturas del estado actual de la aplicación:
\begin{figure} [H]
\begin{center}
\includegraphics[width=\textwidth]{recursos_memoria/screenshot_20100717_o.jpg}
\end{center}
\caption{ \label{F_CapturaFase3SegundaDemo_20100717} Fase 3: Segunda Demo}
\end{figure}

\begin{figure} [H]
\begin{center}
\includegraphics[width=\textwidth]{recursos_memoria/screenshot_20100717_p.jpg}
\end{center}
\caption{ \label{F_CapturaFase3SegundaDemo_20100717} Fase 3: Segunda Demo}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\chapter{Etapa 3+i: Funcionalidades Añadidas}
\section{Análisis}
\section{Diseño}
\subsubsection{Diseño en UML - Resumen}
\subsubsection{Diseño en UML - Núcleo de la Interfaz}
\subsubsection{Diseño en UML - Módulo de Aplicación}
\subsubsection{Diseño en UML - Módulo de Persistencia}
\subsubsection{Diseño en UML - Módulo de GUI}
\subsubsection{Diseño en UML - Módulo de Producción}
\subsubsection{Diseño en UML - Módulo de Percepción}
\section{Implementación}
\section{Validación y Publicidad}

\chapter{Etapa n: Revisión Final}
\section{Implementación}
\section{Validación y Publicidad}

\chapter{Etapa n+1: Publicidad}
\section{Análisis}
\section{Diseño}
\section{Implementación}
\section{Validación y Publicidad}

\chapter{Etapa n+2: Implantación Final}
\section{Análisis}
\section{Diseño}
\section{Implementación}
\section{Validación y Publicidad}

\chapter{Resultados y conclusiones}
 Desarrollo de los resultados y conclusiones del proyecto. Se debe intentar resaltar el interés del proyecto
 y la calidad del trabajo realizado. Ha llegado el momento de "vender" nuestro trabajo. Se deben incluir aspectos como:

\begin{itemize}
\item Calidad, dificultad y amplitud del trabajo desarrollado que justifique el tiempo de dedicación al proyecto.
\item Aspectos integradores de las disciplinas de la titulación de Ingeniero en Informática.
\item Impacto social. Utilidad del proyecto en el ámbito social
\item Facilidad de utilización de los resultados del proyecto por terceras personas.
\item Publicidad de los resultados del proyecto a través de páginas web, etc.. Cuando de los resultados del proyecto 
 se derive un prototipo o programa de utilización se debe poner a disposición del público en general una versión 
 de demostración de dicho prototipo.
\item Cualquier otro mérito.
\end{itemize}

\chapter{Trabajo Futuro}
 Continuidad del trabajo realizado a través de una implementación, o utilidad real del proyecto,
 o a través de otros proyectos fin de carrera.
 \\
 -Esquema multiusuario online.
 -Base de Datos Orientada a Objetos, Tiempo Real.
 


% EMPIEZAN LOS APENDICES DEL PROYECTO
\appendix

\chapter{Manuales de usuario}

 En el caso de que el desarrollo (y/o naturaleza del proyecto haya dado lugar a la creación de manuales
 de usuario, habrá que ponerlo aquí).

\chapter[Detalles Implementación]{Detalles técnicos sobre la implementación del proyecto}

En este apéndice se detallan los aspectos técnicos relacionados con la implementación del proyecto de forma más concreta. 
\\

\section{Incompatibilidades}\label{detallesImp:Incompatibilidades}
Uno de los aspectos a tener en cuenta es que al usar una cantidad considerable de librerías externas aparecen con frecuencia incompatibilidades que deben ser resueltas. Algunas de estas incompatibilidades pueden afectar sólo a los proyectos de los que dependa un módulo concreto o a la totalidad del proyecto.
\\
\subsection{winsock}
Uno de los problemas más comunes fue la incompatibilidad entre librerías relacionado con librerías del sistema operativo, como fue el caso con winsock. Varias de las librerías usan módulos relacionados incompatibles, por ejemplo Panda3D utiliza winsock, mientras OpenCV usa ws2def, ambas son incompatibles entre sí. Para resolver estos problemas se añaden al inicio de la cabecera de la aplicación las siguientes líneas:
\begin{lstlisting}[language=C++]
#ifdef _WINDOWS
#include <winsock2.h>
#endif
\end{lstlisting}
Estos problemas están ligados a las librerías del sistema operativo que utilizan las librerías externas y la inclusión sólo es necesaria para el sistema operativo Windows y se realizaría la inclusión si la macro está definida.
\\
\subsection{CLR}
Otra de las incompatibilidades más comunes fue la necesidad de desactivar el CLR, Common language runtime support. Debe ser puesto a  No Common language runtime support.

\subsection{NDEBUG}
Panda3D presenta graves problemas si se utiliza la macro \_NDEBUG en Release, por lo que debe quitarse de todo el proyecto.

\section{Third Parties}\label{detallesImp:ThirdParties}

Todas las librerías externas utilizadas se encuentran dentro de la rama $backslash$extern. 

\subsection{wxWidgets}\label{detallesImp:wxWidgets}
Las instrucciones para descargar y compilar wxWidgets pueden encontrarse en la web oficial \cite{wx09}. La distribución viene proyectos preparados para Visual Studio 2008. Sólo es necesario descargar la distribución, abrir la solución y compilarlo en Debug y Release, para obtener las librerías, sin necesidad de ningún ajuste en la compilación.

\subsection{Boost}\label{detallesImp:Boost}

La integración de Boost en el proyecto dio algunos problemas. Se obtuvo la distribución a partir del svn y se siguieron los pasos descritos en la documentación. Sin embargo, para poder añadir correctamente la librería a la solución son necesarias algunas opciones extras al compilarla. Estas opciones son la especificación de multi-threading y el uso de librerías estáticas. El comando final para compilar la librería se muestra a continuación:

\begin{listing}[style=consola, numbers=none]
>.\bjam link=static threading=multi threading=single variant=release variant=debug runtime-link=static
\end{listing}

Hay que tener en cuenta que es necesario desactivar el CLR para evitar incompatibilidades.

\subsection{SFML}\label{detallesImp:SFML}

Puede obtenerse desde svn o descargando algunos de los paquetes que existen, con proyectos preparados para distintos IDEs. La compilación es sencilla y directa.
\\

Sin embargo, es importante destacar que la documentación acerca del paquete de sonido es confusa y en ocasiones errónea. Sin embargo, es útil para conocer las herramientas que dispone. 
\\

Se describen los detalles a tener en cuenta, especialmente en relación a la localización del espacio 3D. En concreto:

\begin{itemize}
\item El eje X es creciente hacia la derecha.
\item El eje Y es creciente hacia arriba.
\item El eje Z es creciente y apunta hacia afuera de la pantalla, hacia el usuario.
\item El método SetTarget(), para orientar el oyente en una dirección, usa un vector normalizado relativo al oyente, no el punto del objeto al que escucha, como puede malinterpretarse por la documentación.
\item La librería NO permite la correcta espacialización del oyente en un entorno 3D tal y como se distribuye. Esto es debido a que enmascara la creación del oyente de OpenAL, ignorando una componente crucial: el vector de verticalidad. Establecen este vector siempre como vertical en el espacio absoluto. Como puede apreciarse en la figura \ref{F_SFML_listener_orientation}, esto impide la correcta orientación del oyente e impide que se pueda distinguir la orientación derecha-izquierda de la 'cabeza'. Sólo sería válido para posicionamiento 2D o 3D donde el vector de dirección del usuario se moviera en el plano horizontal y la verticalidad del oyente no cambiara.
\end{itemize}

\begin{figure} [H]
\begin{center}
\includegraphics[width=\textwidth]{recursos_memoria/SFML_listener_orientation.png}
\end{center}
\caption{ \label{F_SFML_listener_orientation} Necesidad del vector de verticalidad.}
\end{figure}

Esto puede verse claramente en la Definición del método de la clase Listener:

\begin{lstlisting}[language=C++]
/// Change the orientation of the listener (the point he must look at) (take 3 values)
void Listener::SetTarget(float X, float Y, float Z)
{   float Orientation[] = {X, Y, Z, 0.f, 1.f, 0.f};
    ALCheck(alListenerfv(AL_ORIENTATION, Orientation)); }
\end{lstlisting}
Sin embargo, el arreglo es sencillo. Basta con añadir a la clase Listener la siguiente función:
\begin{lstlisting}[language=C++]
void Listener::SetTarget(float X, float Y, float Z, float u, float v, float p)
{   float Orientation[] = {X, Y, Z, u, v, p};
    ALCheck(alListenerfv(AL_ORIENTATION, Orientation)); }
\end{lstlisting}

Tras recompilar se obtiene una librería que, ahora sí, es capaz de posicionar correctamente sonido y oyente en 3D.

\subsection{OpenCV, Open Source Computer Vision}\label{detallesImp:OpenCV}
(RETOMAR!!!)
2. Due to many technical problems the installation package does
   not include pre-compiled OpenCV libraries for Visual Studio users.

   Instead, it includes libraries built with MinGW 4.3.3 TDM-SJLJ.

   They are good enough to run the C/C++ and Python samples and tests,
   but for developing your OpenCV-based applications using
   Visual Studio, Borland IDE etc., or even a different version of MinGW,
   you need to build the libraries with your compiler using CMake,
   as explained here:
      http://opencv.willowgarage.com/wiki/InstallGuide.
   
   Here is the procedure at glance:
   --------------------------------
   1. Download CMake from http://www.cmake.org/cmake/resources/software.html
      and install it.

   2. Run CMake GUI tool and configure OpenCV there:
      2.1. select C:/OpenCV2.0 (or the installation directory you chose)
           as the source directory;
      2.2. choose some other directory name for the generated project files, e.g. C:/OpenCV2
      2.3. press Configure button, select your preferrable build environment
      2.4. adjust any options at your choice
      2.5. press Configure again, then press Generate.
   3a. In the case of Visual Studio or any other IDE, open the generated
      solution/workspace/project ..., e.g. C:/OpenCV2.0/vs2008/OpenCV.sln,
      build it in Release and Debug configurations.
   3b. In the case of command-line Makefiles, enter the destination directory
       and type "make" (or "nmake" etc.) 
      
   4. Add the output directories to the system path, e.g.:
      C:/OpenCV2.0/vs2008/bin/Debug;C:/OpenCV2.0/vs2008/bin/Release:\%PATH\%
      It is safe to add both directories, since the Debug
      OpenCV DLLs have the "d" suffix, which the Release DLLs do not have.
      
   5. Optionally, add C:/OpenCV2.0/include/opencv to the list of
      include directories in your IDE settings,
      and the output library directories
      (e.g. C:/OpenCV2.0/vs2008/lib/(Debug,Release))
      to the list of library paths.

   It is important to build both release and debug configurations, and link
   you code with the proper libraries in each configuration,
   otherwise various compile-time or run-time errors are possible.


ADEMAS VS 2008 EE no tiene soporte para OPENMP, así que es necesario desactivarlo en CMAKE, tambien PYTHON SUPPORT

Dependencias cv200d.lib cxcore200d.lib highgui200d.lib
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Panda3D}\label{detallesImp:Panda3D}
(REVISAR!!!!!)
www.panda3d.org/wiki/index.php/Tutorial:\_Compiling\_the\_Panda\_3D\_Source\_on\_Windows
www.panda3d.org/wiki/index.php/How\_to\_build\_a\_CXX\_Panda3D\_game\_using\_Microsoft\_Visual\_Studio\_2008
www.panda3d.org/wiki/index.php/Configuring\_Panda

scr/framework/config\_famework.cxx  (debug)
ConfigVariableBool show\_frame\_rate\_meter("show-frame-rate-meter", true);

panda3d usa winsock mientras que openCV usa ws2def....... sonincompatibles, debería usarse winsock2.h..

Se añade winsock2.h al comienzo de Application.h para resolver el conflicto (este problema sólo aparecería en las versiones de las librerías compliladas en Windows)

Excluir librería standar (norecuerdonombre)

Modificar fuentes de panda para exportar Geom::CDataCache y GeomVertexData::CDataCache, mediate macro EXPCL\_PANDA\_GOBJ : 
src/gobj/geom.h

  // The pipelined data with each CacheEntry.
  class EXPCL\_PANDA\_GOBJ CDataCache : public CycleData {
  public:
    INLINE CDataCache();
    INLINE CDataCache(const CDataCache \&copy);
    virtual ~CDataCache();
    ALLOC\_DELETED\_CHAIN(CDataCache);
    virtual CycleData *make\_copy() const;
    virtual TypeHandle get\_parent\_type() const {
      return Geom::get\_class\_type();
    }

src/gobj/geomvertexdata

  class EXPCL\_PANDA\_GOBJ CDataCache : public CycleData {
  public:
    INLINE CDataCache();
    INLINE CDataCache(const CDataCache \&copy);
    ALLOC\_DELETED\_CHAIN(CDataCache);
    virtual CycleData *make\_copy() const;
    virtual TypeHandle get\_parent\_type() const {
      return GeomVertexData::get\_class\_type();
    }

cambios aceptados en revisión y subidos al repositorio


\subsection{PostgreSQL}\label{detallesImp:PostgreSQL}
Inslatador de windows. Descargar instalador de Windows, ejecutar, seguir los pasos del tutorial. Instalar al mismo nivel que el proyecto. en carpeta BBDD. puerto por defecto 5432. Ejecutar pgAdmin para crear la base de datos. nombre voxDB, codificacion UTF8, tablespace pg\_default, colacióntipo de caracter spanish\_spain.1252. Nuevo rol de login, nombre vox, contraseña vox. Asignar usuario a base de datos.

\subsection{Debea}\label{detallesImp:Debea}
set DEVEL = directorio
nmake -f makefile.vc DEBUG=0 DEBUG=1 PGSQL=1
nmake -f makefile.vc DEBUG=0 DEBUG=1 PGSQL=1 install
copiar directorio resultatnte en extern\_debea
(REVISAR!!!!!)




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Interfaces core}\label{detallesImp:InterfacesCore}
Para preparar el módulo ha sido necesario configurar el proyecto igui de la siguiente forma:
\begin{itemize}
\item Additional Include Directories:
\begin{lstlisting}[language=C++]
.
..\..\src
..\..\extern\include
\end{lstlisting}
\item Additional Library Directories:
\begin{lstlisting}[language=C++]
\"\$(OutDir)\"
\end{lstlisting}
\item Preprocessor Definitions (Debug): WIN32; \_DEBUG; \_WINDOWS; 
\item Preprocessor Definitions (Release): WIN32; \_WINDOWS;
\end{itemize}

Además por asuntos de compatibilidad es necesario asegurar las siguientes opciones:
\begin{itemize}
\item No usar la macro \_NDEBUG en release.
\item Configuration Type: Static Library (.lib). (actualemnte dll cambiar)
\item Use of ATL: Not Using ATL.
\item Common Language Runtime Support: No Common Language Runtime Support.
\item Runtime Library: Multi-threaded [Debug] DLL ($\backslash$MTD $\backslash$MTDd).
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{IApplicationConfiguration}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{lstlisting}[language=C++]
class CameraData
{ public:
   CameraData() : x(0),y(0),z(0),flip_h(false),flip_v(false){}
   ~CameraData(){}
   double x, y, z;
   bool flip_h, flip_v; };
   
class DisplayData
{ public:
   DisplayData() : x(0),y(0),z(0),flip_h(false),flip_v(false), resolution_x(800),resolution_y(600){}
   ~DisplayData() {}
   double x, y, z;
   bool flip_h, flip_v;
   unsigned int resolution_x, resolution_y; };
   
class IApplicationConfiguration
{ public:
   virtual ~IApplicationConfiguration(){}
   virtual core::CameraData  GetCameraData(const int &id)=0;
   virtual core::DisplayData GetDisplayData(const int &id)=0;	
   virtual unsigned int GetNumCams()     = 0;
   virtual unsigned int GetNumDisplays() = 0;   
   virtual std::string GetDBHost() = 0;
   virtual std::string GetDBPort() = 0;
   virtual std::string GetDBName() = 0;
   virtual std::string GetDBUser() = 0;
   virtual std::string GetLanguage() = 0;   
   virtual std::string GetDBPassword()      = 0;
   virtual std::string GetRootDirectory()   = 0;
   virtual std::string GetDataDirectory()   = 0;
   virtual std::string GetModelDirectory()  = 0;
   virtual std::string GetSoundDirectory()  = 0;
   virtual std::string GetImageDirectory()	= 0;
   virtual std::string GetUIResourceDirectory() = 0;			
   
   virtual void SetRootDirectory(const std::string &value) = 0;
   virtual void SetDataDirectory(const std::string &value) = 0;
   virtual void SetModelDirectory(const std::string &value) = 0;
   virtual void SetSoundDirectory(const std::string &value) = 0;
   virtual void SetImageDirectory(const std::string &value) = 0;
   virtual void SetUIResourceDirectory(const std::string &value) = 0;
   virtual void SetDBHost(const std::string &value) = 0;
   virtual void SetDBPort(const std::string &value) = 0;
   virtual void SetDBName(const std::string &value) = 0;
   virtual void SetDBUser(const std::string &value) = 0;
   virtual void SetDBPassword(const std::string &value) = 0;
   virtual void SetLanguage(const std::string &value) = 0;		
   virtual void SetNumCams(const unsigned int &value) = 0;
   virtual void SetNumDisplays(const unsigned int &value) = 0;
   virtual void SetCameraData(const int &id, const CameraData &value)=0;
   virtual void SetDisplayData(const int &id, const DisplayData &value)=0;
};   
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Módulo de GUI}\label{detallesImp:ModuloGUI}
Para preparar el módulo ha sido necesario configurar el proyecto igui de la siguiente forma:
\begin{itemize}
\item Additional Include Directories:
\begin{lstlisting}[language=C++]
.
..\..\src
..\..\extern\include
..\..\extern\include\wxwidgets
..\..\extern\include\wxwidgets\msvc
..\..\extern\boost
\end{lstlisting}
\item Additional Library Directories:
\begin{lstlisting}[language=C++]
..\..\bin
..\..\extern\lib
..\..\extern\boost\lib
\"\$(OutDir)\"
\end{lstlisting}
\item Preprocessor Definitions (Debug): WIN32; \_DEBUG; \_WINDOWS; \_USRDLL; \_MSVC; \_IGUIEXPORT\_; \_\_WXMSW\_\_; \_\_WXDEBUG\_\_; \_UNICODE; NOPCH
\item Preprocessor Definitions (Release): WIN32; \_WINDOWS; \_USRDLL; \_MSVC;\_IGUIEXPORT\_; \_\_WXMSW\_\_; \_UNICODE; NOPCH
\item Additional Dependencies (Debug): 
wxmsw29ud\_core.lib wxbase29ud.lib wxtiffd.lib wxjpegd.lib wxpngd.lib wxzlibd.lib wxregexud.lib wxexpatd.lib kernel32.lib user32.lib gdi32.lib comdlg32.lib
winspool.lib winmm.lib shell32.lib comctl32.lib ole32.lib oleaut32.lib uuid.lib rpcrt4.lib advapi32.lib wsock32.lib wininet.lib 
\item Additional Dependencies (Release): wxmsw29u\_core.lib wxbase29u.lib wxtiff.lib wxjpeg.lib wxpng.lib wxzlib.lib wxregexu.lib wxexpat.lib kernel32.lib user32.lib gdi32.lib comdlg32.lib winspool.lib winmm.lib shell32.lib comctl32.lib ole32.lib oleaut32.lib rpcrt4.lib advapi32.lib wsock32.lib wininet.lib
\end{itemize}

Además por asuntos de compatibilidad es necesario asegurar las siguientes opciones:
\begin{itemize}
\item No usar la macro \_NDEBUG en release.
\item Configuration Type: Static Library (.lib).
\item Use of ATL: Not Using ATL.
\item Common Language Runtime Support: No Common Language Runtime Support.
\item Runtime Library: Multi-threaded [Debug] DLL ($\backslash$MTD $\backslash$MTDd).
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{MainGui}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{lstlisting}[language=C++]
#define IMPLEMENT_MIIAPP(name) IMPLEMENT_APP(name)
namespace core {namespace igui{
class MainFrame;
class MainGui : public core::IGui
{public:
 	virtual ~MainGui();
 	virtual void Delete();
 	virtual void Update();

 	void RegisterWindow(IGuiWindow *window);
 	void AddWindowToFullscreenList(IGuiWindow *window);
 	void ShowAll(bool value);
 	void SetAllWindowsFullScreen(bool value);
 	static MainGui* GetInstance(const std::wstring &title = L"");
 private:		
 	MainGui(const std::wstring &title = L"");
 	static MainGui* instance; 
 	static MainFrame *main_frame;
 	static std::map<IGuiWindow*, int> registered_windows;
 	static std::map<IGuiWindow*, int> fullscreenable_windows;
}; 
}}

MainGui* MainGui::GetInstance(const std::string &title)
{	boost::mutex::scoped_lock lock(m_mutex);
	if (instance == NULL) 
		instance = new MainGui(title);
	return instance; }
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{MainFrame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{lstlisting}[language=C++]
namespace core { namespace igui	{
class MainGui;
class MainFrame : public wxFrame
{ public:
	MainFrame(wxWindow *parent, wxWindowID id, const wxString &title, const wxPoint &pos=wxDefaultPosition, const wxSize &size=wxDefaultSize, long style=wxDEFAULT_FRAME_STYLE, const wxString &name=wxFrameNameStr);
	virtual ~MainFrame();
	void Delete();
 private:
	wxMenu *file_menu, *view_menu, *tools_menu, *help_menu;
	wxMenuItem *item_file_close, *item_view_fullscreen, *item_view_start, *item_tools_configure, *item_help_about;
	wxWindow *dummy_panel;
	GUIHelp  *help_panel;
	GUIStart *start_panel;
	DECLARE_EVENT_TABLE()
	void InitShortCuts();
	void OnClose(wxCommandEvent& WXUNUSED(event));
	void OnViewStart(wxCommandEvent& WXUNUSED(event));
	void OnHelpAbout(wxCommandEvent& WXUNUSED(event));
	void DismissPanels();
};	}}
#endif
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{GUIStart}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{lstlisting}[language=C++]
namespace core { namespace igui { 
class GUIStart : public wxPanel 
{ public:
	GUIStart(wxWindow *parent, wxWindowID id,  const wxPoint &pos=wxDefaultPosition, const wxSize &size=wxDefaultSize, long style=wxTAB_TRAVERSAL, const wxString &name = "panel");
	virtual ~GUIStart();
	void Delete();
	void OnPaint(wxPaintEvent &evt);
	void paintNow();	        
	void render(wxDC& dc);
 private:
	wxBitmap background_image;
	DECLARE_EVENT_TABLE()		
	wxButton *login_button, *start_button, *configure_button;
};}}
#endif
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{GUIHelp}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{lstlisting}[language=C++]
BEGIN_EVENT_TABLE(GUIHelp, wxPanel)
	EVT_PAINT (GUIHelp::OnPaint)
END_EVENT_TABLE()

GUIHelp::GUIHelp(wxWindow *parent, wxWindowID id, const wxPoint &pos, const wxSize &size, long style, const wxString &name) 
: wxPanel(parent, id, pos, size, style, name)
{ background_image = wxBitmap("c:/etc/help.png", wxBITMAP_TYPE_ANY); }

GUIHelp::~GUIHelp()
{}

void GUIHelp::Delete()
{ wxPanel::Destroy(); }

void GUIHelp::OnPaint(wxPaintEvent & evt)
{ wxPaintDC dc(this);
  render(dc); }

void GUIHelp::render(wxDC& dc)
{ dc.DrawBitmap(background_image, 0, -20, false );
  dc.DrawRotatedText("ProjectVOX", 250, 30, 0);
  dc.DrawRotatedText("Code Name ::TheElectricGOAT::", 250, 50, 0);
  dc.DrawRotatedText("Version 0.1", 250, 70, 0); }
\end{lstlisting}
 
\section{Módulo de Percepción}\label{detallesImp:ModuloPercepcion}

Para implementar el módulo IPercept se ha configurado el proyecto de la siguiente forma:

\begin{itemize}
\item Additional Include Directories:
\begin{lstlisting}[language=C++]
.
..\..\src
..\..\extern\include
..\..\extern\include\opencv
..\..\extern\boost
..\..\extern\include\wxwidgets\msvc
..\..\extern\include\wxwidgets
..\..\extern\sfml\include
\end{lstlisting}
\item Additional Library Directories:
\begin{lstlisting}[language=C++]
..\..\bin
..\..\extern\lib
..\..\extern\lib\opencv
..\..\extern\boost\lib
..\..\extern\sfml\lib\vc2008
\"\$(OutDir)\"
\end{lstlisting}
\item Preprocessor Definitions (Debug): WIN32;\_DEBUG
\item Preprocessor Definitions (Release): WIN32;\_WINDOWS;\_MSVC;
\item Additional Dependencies (Debug): cv200d.lib cxcore200d.lib highgui200d.lib sfml-audio-s-d.lib sfml-system-s-d.lib
\item Additional Dependencies (Release): cv200.lib cxcore200.lib highgui200.lib sfml-audio-s.lib sfml-system-s.lib
\end{itemize}

Además por asuntos de compatibilidad es necesario asegurar las siguientes opciones:
\begin{itemize}
\item No usar la macro \_NDEBUG en release.
\item Configuration Type: Static Library (.lib).
\item Use of ATL: Not Using ATL.
\item Common Language Runtime Support: No Common Language Runtime Support.
\item Runtime Library: Multi-threaded [Debug] DLL ($\backslash$MTD $\backslash$MTDd).
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{MainPercept}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{lstlisting}[language=C++]
#include <core/IPercept/IPercept.h>
#include <ipercept/PerceptAudio.h>
#include <ipercept/PerceptVideo.h>
#include <string>
#include <vector>
namespace core { namespace ipercept	{
 class MainPercept : public core::IPercept
 { public:
    MainPercept();
	virtual ~MainPercept();
	virtual void Delete();
	virtual void Init();
   private:
	static int num_cam;
	static PerceptAudio* perceptAudio_module;
	static PerceptVideo* perceptVideo_module;
 };} }

MainPercept::MainPercept()
{	perceptAudio_module = new PerceptAudio();
	perceptVideo_module = new PerceptVideo(); }

MainPercept::~MainPercept()
{	delete perceptAudio_module;
	delete perceptVideo_module; }

void MainPercept::Delete()
{	perceptAudio_module->Delete();
	perceptVideo_module->Delete(); }

void MainPercept::Init()
{	perceptAudio_module->Init();
	perceptVideo_module->Init(); }
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{PerceptAudio}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{lstlisting}[language=C++]
#include <core/IPercept/IPerceptAudio.h>
#include <string>
#include <vector>
#include <boost/thread.hpp>
#include <SFML/Audio.hpp>
#include <SFML/Audio/SoundRecorder.hpp>
namespace core { namespace ipercept {
class PerceptAudio : public core::IPerceptAudio 
{ public:
   PerceptAudio();
   virtual ~PerceptAudio();
   virtual void Delete();
   virtual void Init();
  private:
   static void DoInit();
   static void DoMainLoop();
   static void Iterate();
   static void Capture();
   
   static boost::shared_ptr<boost::thread> m_thread;
   static boost::try_mutex m_mutex;
   static bool initialized, stop_requested;
   static sf::SoundBufferRecorder Recorder;
   static sf::SoundBuffer recordingBuffer;
};}}

void PerceptAudio::Delete()
{	stop_requested = true;
	assert(m_thread);
	m_thread->join(); }

void PerceptAudio::Init()
{	PerceptAudio::DoInit(); }

void PerceptAudio::DoInit()
{	if (!initialized)
	{	assert(!m_thread);
		m_thread = boost::shared_ptr<boost::thread>(new boost::thread(boost::function0<void>(&PerceptAudio::DoMainLoop))); } }

void PerceptAudio::DoMainLoop()
{	initialized = true;
	Recorder.Start();
	while(!stop_requested)
	{	Iterate();
		m_thread->sleep(boost::get_system_time()+boost::posix_time::milliseconds(1000)); }}

void PerceptAudio::Iterate()
{	boost::try_mutex::scoped_try_lock lock(m_mutex);
	if (lock) { Capture(); } 
}

void PerceptAudio::Capture()
{	Recorder.Stop();
	recordingBuffer = Recorder.GetBuffer();
	Recorder.Start(); }
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{PerceptVideo}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{lstlisting}[language=C++]
#include <core/IPercept/IPerceptVideo.h>
#include <ipercept/CamWindow.h>
#include <string>
#include <vector>
#include <cv.h>
#include <cxcore.h>
#include <highgui.h>
#include <boost/thread.hpp>
namespace core { namespace ipercept {
class PerceptVideo : public core::IPerceptVideo
{ public:
   PerceptVideo();
   virtual ~PerceptVideo();
   virtual void Delete();
   virtual void Init();
   
  private:
   static void DoInit();
   static void DoMainLoop();
   static void Iterate();
   static void Capture();

   static int num_cam;
   static std::map< int, CvCapture* > capture_cam_array;
   static std::map< std::string, CamWindow* > camWindow_array;
   static IplImage *capture_img;

   static boost::shared_ptr<boost::thread> m_thread;
   static boost::try_mutex m_mutex;
   static bool initialized, stop_requested;
};}}

PerceptVideo::PerceptVideo()
{ if (!initialized)
  { num_cam = NUM_CAM;
    for (int i=0; i<num_cam; i++)
    { std::stringstream window_name;
      window_name << "Cam" << i << ":";
      capture_cam_array[i] = cvCaptureFromCAM( i );
      camWindow_array[window_name.str()] = new CamWindow(window_name.str());
} } }

PerceptVideo::~PerceptVideo()
{ boost::try_mutex::scoped_try_lock lock(m_mutex);
  if (lock)
  { for (std::map< int, CvCapture * >::iterator iter = capture_cam_array.begin(); iter!=capture_cam_array.end(); iter++)
    { std::stringstream window_name;
      window_name << "Cam" << iter->first << ":";
      cvReleaseCapture(&(iter->second)); }
    capture_cam_array.erase(capture_cam_array.begin(),capture_cam_array.begin());

    for (std::map< std::string, CamWindow* >::iterator iter = camWindow_array.begin(); iter!=camWindow_array.end(); iter++)
     delete iter->second;
    camWindow_array.erase(camWindow_array.begin(),camWindow_array.begin());
}}

void PerceptVideo::Delete()
{ stop_requested = true;
  assert(m_thread);
  m_thread->join(); }

void PerceptVideo::Init()
{ PerceptVideo::DoInit(); }

void PerceptVideo::DoInit()
{ if (!initialized)
  { assert(!m_thread);
    m_thread = boost::shared_ptr<boost::thread>(new boost::thread(boost::function0<void>(&PerceptVideo::DoMainLoop))); 
} }

void PerceptVideo::DoMainLoop()
{ initialized = true;
  while(!stop_requested)
  { Iterate();
    m_thread->sleep(boost::get_system_time()+boost::posix_time::milliseconds(10));
} }

void PerceptVideo::Iterate()
{  boost::try_mutex::scoped_try_lock lock(m_mutex);
   if (lock) { Capture(); } }

void PerceptVideo::Capture()
{ for (std::map<int, CvCapture *>::iterator iter = capture_cam_array.begin(); iter!=capture_cam_array.end(); iter++)
  { std::stringstream window_name;
    window_name << "Cam" << iter->first << ":";
    capture_img = cvQueryFrame(iter->second);
    std::map< std::string, CamWindow* >::iterator cam_iter = camWindow_array.find(window_name.str());
    if (cam_iter != camWindow_array.end())
      cam_iter->second->ShowImage(capture_img);
} }
\end{lstlisting}


\section{Módulo de Producción}\label{detallesImp:ModuloProduccion}

Para implementar el módulo IProd se ha configurado el proyecto de la siguiente forma:

\begin{itemize}
\item Additional Include Directories:
\begin{lstlisting}[language=C++]
.
..\..\src
..\..\extern\include
..\..\extern\panda3d\built\include
..\..\extern\panda3d\built\python\include
..\..\extern\boost
..\..\extern\include\wxwidgets\msvc
..\..\extern\include\wxwidgets
..\..\extern\sfml\include
\end{lstlisting}
\item Additional Library Directories (Debug):
\begin{lstlisting}[language=C++]
..\..\bin
..\..\extern\lib
..\..\extern\panda3d\debug\lib
..\..\extern\panda3d\debug\python
..\..\extern\panda3d\debug\python\Lib
..\..\extern\panda3d\debug\python\libs
..\..\extern\boost\lib
..\..\extern\sfml\lib\vc2008
\$(OutDir)
\end{lstlisting}
\item Additional Library Directories (Release):
\begin{lstlisting}[language=C++]
..\..\bin
..\..\extern\lib
..\..\extern\panda3d\built\lib
..\..\extern\panda3d\built\python
..\..\extern\panda3d\built\python\Lib
..\..\extern\panda3d\built\python\libs
..\..\extern\boost\lib
..\..\extern\sfml\lib\vc2008
\$(OutDir)
\end{lstlisting}
\item Preprocessor Definitions (Debug): WIN32;\_DEBUG
\item Preprocessor Definitions (Release): WIN32;
\item Additional Dependencies (Debug): libpandaexpress.lib libp3framework.lib libpanda.lib libpandafx.lib libp3dtool.lib libp3dtoolconfig.lib libp3pystub.lib libp3direct.lib sfml-audio-s-d.lib sfml-system-s-d.lib
\item Additional Dependencies (Release): libpandaexpress.lib libp3framework.lib libpanda.lib libpandafx.lib libp3dtool.lib libp3dtoolconfig.lib libp3pystub.lib libp3direct.lib sfml-audio-s.lib sfml-system-s.lib
\end{itemize}

Además por asuntos de compatibilidad es necesario asegurar las siguientes opciones:
\begin{itemize}
\item No usar la macro \_NDEBUG en release.
\item Configuration Type: Static Library (.lib).
\item Use of ATL: Not Using ATL.
\item Common Language Runtime Support: No Common Language Runtime Support.
\item Runtime Library: Multi-threaded [Debug] DLL ($\backslash$MTD $\backslash$MTDd).
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Prod3dWindow}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{lstlisting}[language=C++]
#include <igui/maingui.h>
#include <string>
#include <vector>
#include <pandaFramework.h>
namespace core { namespace iprod {
class Prod3DWindow : public core::IGuiWindow
{ public:
   Prod3DWindow(PandaFramework *framework, const WindowProperties &props, bool registrable = false, bool fullscreenable = false);
   virtual ~Prod3DWindow();
   WindowFramework *GetWindowFrameWork() {return m_windowFramework;}
   void Show(const bool &value = true);
   void FullScreen( const bool &value = true );
   bool IsShown() {return isShown;}
 private:
   bool isShown;
   WindowFramework *m_windowFramework;
}; }}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{MainProd}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{lstlisting}[language=C++]
#include <core/IProd/IProd.h>
#include <iprod/Prod3DWindow.h>
#include <string>
#include <pandaFramework.h>
#include <pandaSystem.h>
#include <modelPool.h>
#include <filename.h>
#include <genericAsyncTask.h>
#include <asyncTaskManager.h>
#include "cIntervalManager.h"
#include "cLerpNodePathInterval.h"
#include "cMetaInterval.h"
#include <boost/thread.hpp>
#include <SFML/Audio.hpp>

namespace core { namespace iprod {
class MainProd : public core::IProd
{ public:
   MainProd(int argc, char *argv[]);
   virtual ~MainProd();
   virtual void Delete();
   virtual void Init();
   virtual void DoStuff();
   virtual void OpenWindow();
  private:
   static void DoInit();
   static void DoDoStuff();
   static void PlaySoundCapture();
   static void DoMainLoop();
   static void Iterate();
   static void CreateDefaultWindows(int numWindows);
   static void LoadDefaultScene();

   static AsyncTask::DoneStatus SpinCameraTask(GenericAsyncTask* task, void* data);
   static boost::shared_ptr<boost::thread> m_thread;
   static boost::try_mutex m_mutex;
   static PandaFramework framework;
   static Thread *graphic_thread;
   static PT(AsyncTaskManager) taskMgr;
   static PT(ClockObject) globalClock;
   static bool initialized, stop_requested;
   static std::map<int, Prod3DWindow*>		prod3Dwindow_array;
   static std::map<int, WindowFramework*>	pandawindows_array;
   static std::map<int, NodePath>			windowcamera_array;
   static int last_window_id, m_argc;
   static char **m_argv;
   static NodePath cam_viewpoint;
   static NodePath origin, up;

   static sf::SoundBuffer sound_Buffer;
   static double listener_position[];
   static double listener_target[];
   static double sound_pos[];
   static sf::Sound Sound;
}; } }

MainProd::MainProd(int argc, char *argv[])
{ m_argc = argc;
  m_argv = argv; }

MainProd::~MainProd()
{ m_thread->join();
  for (std::map<int, Prod3DWindow*>::iterator iter=prod3Dwindow_array.begin(); iter != prod3Dwindow_array.end(); iter++)
   delete iter->second;
  prod3Dwindow_array.erase(prod3Dwindow_array.begin(), prod3Dwindow_array.end());
}

void MainProd::Delete()
{ stop_requested = true;
  assert(m_thread);
  m_thread->join(); }

void MainProd::DoMainLoop()
{ framework.open_framework( m_argc, m_argv);
  taskMgr = AsyncTaskManager::get_global_ptr();
  globalClock = ClockObject::get_global_clock();
  graphic_thread = Thread::get_current_thread();	

  CreateDefaultWindows(DEFAULT_NUM_WINDOWS);

  LoadDefaultScene();

  sf::SoundBuffer Buffer;
  if (!Buffer.LoadFromFile("c://etc//motor.wav"))
   int error_loadfromfile = 1;		
  unsigned int chan = Buffer.GetChannelsCount();
  sf::Listener::SetGlobalVolume(100.f);
  Sound.SetBuffer(Buffer);
  Sound.SetLoop(true);
  Sound.SetPosition(sound_pos[0], sound_pos[1], sound_pos[2]);
  Sound.SetMinDistance(10.f);
  Sound.SetAttenuation(0.75f);

  initialized = true;
  
  Sound.Play();	

  while(!stop_requested) 
  { Iterate();
    m_thread->sleep(boost::get_system_time()+boost::posix_time::milliseconds(10)); }

  framework.close_all_windows();
  framework.close_framework();
}

void MainProd::Iterate()
{ boost::try_mutex::scoped_try_lock lock(m_mutex);
  if (lock)
  { framework.do_frame(graphic_thread);
    CIntervalManager::get_global_ptr()->step(); }
}

void MainProd::Init()
{ MainProd::DoInit(); }

void MainProd::DoStuff()
{ MainProd::DoDoStuff(); }

void MainProd::DoInit()
{ if (!initialized)
	{ assert(!m_thread);
      m_thread = boost::shared_ptr<boost::thread>(new boost::thread(boost::function0<void>(&MainProd::DoMainLoop))); }
}

void MainProd::DoDoStuff()
{ boost::try_mutex::scoped_try_lock lock(m_mutex);
  if (lock && initialized)
  { double time = globalClock->get_real_time();
    double angledegrees = time * 2.0;
    double angleradians = angledegrees * (3.14 / 180.0);
    windowcamera_array[1].set_pos(20*sin(angleradians),-20.0*cos(angleradians),3);
    windowcamera_array[1].set_hpr(angledegrees, 0, 0);

    LPoint3f cam_pos = windowcamera_array[2].get_pos();
    LVector3f abs_vec_at, abs_vec_up;
    abs_vec_at = cam_viewpoint.get_pos(pandawindows_array[2]->get_render());
    abs_vec_up = up.get_pos(pandawindows_array[2]->get_render());
    LPoint3f new_pos(cam_pos.get_x()  ,    cam_pos.get_z(),    -cam_pos.get_y());
    LPoint3f new_at(abs_vec_at.get_x(), abs_vec_at.get_z(), -abs_vec_at.get_y());
    LPoint3f new_up(abs_vec_up.get_x(), abs_vec_up.get_z(), -abs_vec_up.get_y());
    new_at = new_at - new_pos;
    new_up = new_up - new_pos;
    new_at.normalize();
    new_up.normalize();
    sf::Listener::SetPosition(new_pos.get_x(), new_pos.get_y(), new_pos.get_z());
    sf::Listener::SetTarget(new_at.get_x(), new_at.get_y(), new_at.get_z() , new_up.get_x(), new_up.get_y(), new_up.get_z());
   }
   else 
   { //más suerte la próxima }
}

void MainProd::CreateDefaultWindows(int num_windows)
{ WindowProperties win_props = WindowProperties(); 
  win_props.set_size(800, 600); 
  for (int i=last_window_id+1; i <= last_window_id + num_windows; i++)
  { prod3Dwindow_array[i] = new Prod3DWindow(&framework, win_props, true, true);
    pandawindows_array[i] = prod3Dwindow_array[i]->GetWindowFrameWork();
    pandawindows_array[i]->set_background_type(WindowFramework::BackgroundType::BT_white);
    pandawindows_array[i]->set_lighting(true);
    pandawindows_array[i]->set_perpixel(true);
    windowcamera_array[i] = pandawindows_array[i]->get_camera_group(); 
  }
  origin = pandawindows_array[1]->load_model(framework.get_models(), "panda-model");
  origin.set_pos(0,0,0);
  origin.set_scale(0.001);
  origin.reparent_to(pandawindows_array[2]->get_render());
  up = pandawindows_array[1]->load_model(framework.get_models(), "panda-model");
  up.set_pos(0,0,10);
  up.set_scale(0.002);
  up.reparent_to(pandawindows_array[2]->get_camera_group());
  cam_viewpoint = pandawindows_array[1]->load_model(framework.get_models(), "panda-model");
  cam_viewpoint.set_pos(0,10,0);
  cam_viewpoint.set_scale(0.002);
  cam_viewpoint.reparent_to(pandawindows_array[2]->get_camera_group());
  last_window_id += num_windows;
}

void MainProd::LoadDefaultScene()
{ if (pandawindows_array.begin() != pandawindows_array.end())
  { NodePath environment = pandawindows_array[1]->load_model(framework.get_models(),"environment");
    environment.set_scale(0.25,0.25,0.25);
    environment.set_pos(-8,42,0);
    environment.reparent_to(pandawindows_array[1]->get_render());
    NodePath pandaActor = pandawindows_array[1]->load_model(framework.get_models(), "panda-model");
    pandaActor.set_scale(0.005);
    LPoint3f pandapos = pandaActor.get_pos();
    pandaActor.reparent_to(pandawindows_array[1]->get_render());
    NodePath pandaActor2 = pandawindows_array[1]->load_model(framework.get_models(), "panda-model");
    pandaActor2.set_scale(0.004);
    pandaActor2.set_pos(10.0,0.0,0.0);
    LPoint3f pandapos2 = pandaActor2.get_pos();
    pandaActor2.reparent_to(pandawindows_array[1]->get_render());
	...

    pandawindows_array[1]->load_model(pandaActor, "panda-walk4");
    pandawindows_array[1]->loop_animations(0);

    std::map<int, WindowFramework*>::iterator iter = pandawindows_array.begin();
    iter++;
    while(iter != pandawindows_array.end())
    { environment.instance_to(iter->second->get_render());
      pandaActor.instance_to(iter->second->get_render());
      pandaActor2.instance_to(iter->second->get_render());
      pandaActor3.instance_to(iter->second->get_render());
      pandaActor4.instance_to(iter->second->get_render());
      iter->second->setup_trackball();
      iter++;
} } }
\end{lstlisting}

\section{Aplicación Principal}\label{detallesImp:Application}

El proyecto que conforma la aplicación princial se ha configurado de la siguiente forma:

\begin{itemize}
\item Additional Include Directories:
\begin{lstlisting}[language=C++]
.
..\..\src
..\..\extern\include
..\..\extern\panda3d\built\include
..\..\extern\panda3d\built\python\include
..\..\extern\include\opencv
..\..\extern\include\wxwidgets
..\..\extern\include\wxwidgets\msvc
..\..\extern\boost
..\..\extern\sfml\include
\end{lstlisting}
\item Additional Library Directories (Debug):
\begin{lstlisting}[language=C++]
..\..\bin
..\..\extern\lib
..\..\extern\bin
..\..\extern\panda3d\debug\python\libs
..\..\extern\boost\lib
\$(OutDir)
\end{lstlisting}
\item Additional Library Directories (Release):
\begin{lstlisting}[language=C++]
..\..\bin
..\..\extern\lib
..\..\extern\bin
..\..\extern\panda3d\built\python\libs
..\..\extern\boost\lib
\$(OutDir)
\end{lstlisting}
\item Preprocessor Definitions (Debug): WIN32;\_DEBUG;\_WINDOWS;\_MSVC;
\item Preprocessor Definitions (Release): WIN32;\_WINDOWS;\_MSVC;
\item Additional Dependencies (Debug): icogd.lib iguid.lib iperceptd.lib ipersistenced.lib iprodd.lib
\item Additional Dependencies (Release): icog.lib igui.lib ipercept.lib ipersistence.lib iprod.lib
\item Environment (Debug): 
\begin{listing}[style=consola, numbers=none]
PATH=%PATH%;..\..\extern\bin;..\..\extern\bin\opencv;..\..\extern\panda3d\debug\bin;..\..\extern\panda3d\debug\python;..\..\extern\panda3d\debug\python\DLLs;..\..\extern\sfml\extlibs\bin;
\end{listing}
\item Environment (Release): 
\begin{listing}[style=consola, numbers=none]
PATH=%PATH%;..\..\extern\bin;..\..\extern\bin\opencv;..\..\extern\panda3d\built\bin;..\..\extern\panda3d\built\python;..\..\extern\panda3d\built\python\DLLs;..\..\extern\sfml\extlibs\bin;
\end{listing}
\end{itemize}

Además por asuntos de compatibilidad es necesario asegurar las siguientes opciones:
\begin{itemize}
\item No usar la macro \_NDEBUG en release.
\item Configuration Type: Application (.exe).
\item Use of ATL: Not Using ATL.
\item Common Language Runtime Support: No Common Language Runtime Support.
\item Runtime Library: Multi-threaded [Debug] DLL ($\backslash$MD $\backslash$MDd).
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Application}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{lstlisting}[language=C++]
#ifdef _WINDOWS
#include <winsock2.h>
#endif
#include <core/IApplication.h>
#include <core/IGUI/IGui.h>
#include <core/ICog/ICog.h>
#include <core/IProd/IProd.h>
#include <core/IPercept/IPercept.h>
#include <core/IPersistence/IPersistence.h>
#include <igui/maingui.h>
#include <icog/maincog.h>
#include <iprod/mainprod.h>
#include <ipercept/mainpercept.h>
#include <ipersistence/mainpersistence.h>
class Application : public wxApp, public core::IApplication
{ public:
   Application(void);
   ~Application(void);
   bool OnInit();
   void ExitApplication();
  private:
   DECLARE_EVENT_TABLE();
   wxTimer app_timer;
   core::IGui		*app_maingui;
   core::IPercept	*app_mainpercept;
   core::IProd		*app_mainprod;
   void	OnIdle(wxIdleEvent &event);
   int		OnRun();
   void	DoMainLoopStuff(wxTimerEvent& event);   
};

#define MAINLOOP_EVT 12345

BEGIN_EVENT_TABLE(Application, wxApp)
	EVT_IDLE	(Application::OnIdle)
	EVT_TIMER	(MAINLOOP_EVT, Application::DoMainLoopStuff)
END_EVENT_TABLE()

Application::Application(void) : app_maingui(NULL), app_mainpercept(NULL), app_mainprod(NULL)
{ app_timer.SetOwner(this, MAINLOOP_EVT); }

Application::~Application(void)
{	if (app_mainpercept!=NULL)
	{	app_mainpercept->Delete();
		delete app_mainpercept;	}

	if (app_mainprod!=NULL)
	{	app_mainprod->Delete();
		delete app_mainprod;	}

	if (app_maingui!=NULL)
	{	app_maingui->Delete();
		delete app_maingui;	} }

bool Application::OnInit()
{ app_maingui     = core::igui::MainGui::GetInstance("VOX");
  app_mainpercept = (core::IPercept *) new core::ipercept::MainPercept(); 
  app_mainprod    = (core::IProd *) new core::iprod::MainProd(argc, argv); 
  app_mainpercept->Init();
  app_mainprod->Init();
  return true; }

void Application::OnIdle(wxIdleEvent &event)
{ //To Do less important/frequent stuff }

int Application::OnRun()
{ app_timer.Start(10);
  return wxApp::OnRun(); }

void Application::ExitApplication()
{	wxApp::Exit(); }

void Application::DoMainLoopStuff(wxTimerEvent& event)
{ //To Do important/frequent stuff
  app_mainprod->DoStuff(); }
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{main}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{lstlisting}[language=C++]
#define _WINSOCKAPI_
#include "Application.h"
IMPLEMENT_MIIAPP(Application)
\end{lstlisting}

\chapter[Redacción de Proyectos]{Comentarios Generales sobre la redacción de los proyectos}


Por donde se empieza? Habitualmente se empieza a redactar en orden inverso al que se lee el documento, primero 
se puede empezar a rellenar la bibliografía utilizada que se irá completando según avance el proyecto. A continuación, 
a partir de un esqueleto inicial del proyecto, que puede estar redactado, manuscrito, o simplemente en la cabeza del estudiante, 
se empieza a redactar las partes más concretas del proyecto, que tengamos más claras, y que sean lo más independiente posible 
de la redacción de otras partes del proyecto. Por ejemplo, se puede empezar por anexos donde se resuma las características 
de una herramienta que utilizamos, etc.., a continuación empezamos a redactar de manera individual los detalles de cada 
una de las etapas en las que se constituye el proyecto, no tienen que redactarse ordenadas según aparecen en el texto, 
sobre la elección sobre cual empezar, siempre primará que sea una parte que tengamos bien clara, y que hayamos delimitado 
su contenido para que sea independiente de la redacción de las otras etapas. Como verán, según vayan avanzando en la 
redacción, cada vez verán las cosas más claras, y de forma natural verán la forma de ir redactando las otras partes del 
proyecto, hasta llegar a las secciones de introducción y conclusiones y resultados que son las más delicadas de desarrollar, 
pues son las más importantes y las que previsiblemente se van a leer en mayor detalle las personas que lean el proyecto. 
Una deficiente redacción de la introducción (que es donde se atrae al lector sobre la importancia de lo que se va a hacer) 
o una mala presentación de las conclusiones y resultados (que es donde se transmite el mensaje de todo lo bueno que hay 
en proyecto) pone en entredicho la calidad global del proyecto. Una buena estrategia consiste en según se van redactando 
las diferentes secciones del proyecto, ir haciendo un borrador de las secciones de introducción y conclusiones y resultados, 
poniendo las ideas sueltas, y en principio desordenadas, que nos vayan surgiendo  y que puedan ser de utilidad en la redacción 
de estas secciones. Redactar bien tiene su dificultad y no todos los días tenemos la inspiración adecuada, para esos días 
negros, que no nos viene nada a la cabeza, lo mejor es dedicarse a cosas más mecánicas que no requieren tanta concentración, 
como puede ser completar la bibliografía, ir haciendo un manual de usuario o un anexo técnico, etc..

Cuando empezamos a redactar, siempre es necesario tener en cuenta algunos criterios básicos como son:

1. Escribir de cada cosa su esencia. Que es lo que es realmente relevante en la sección que estoy redactando y esforzarme 
en que ello quede claro

2. Ponerse en el lugar del potencial lector. El orden y la forma en la redactamos no es sólo para que nosotros tengamos 
claro lo que hacemos, es sobre todo para que una tercera persona que lea el texto lo pueda tener, si cabe, más claro 
que nosotros. Para ello hay que respetar un orden lógico en la forma en que presentamos las cosas y no presuponer que 
el lector conoce los entresijos de lo que estamos haciendo, hay que evitar dar saltos en el vacío, por ejemplo dando 
por supuesto conocimientos que el lector no tiene o alterando el orden natural en que deben aparecer las cosas.

Algunas ideas sueltas sacadas del libro "Como elaborar y presentar un trabajo escrito" cuyo autor es el profesor Santos Pérez:

El proyecto fin de carrera es un trabajo personal en el que el estudiante debe demostrar que domina el tema, sabe organizarlo, 
estructurarlo y elaborar en profundidad, y presentarlo en la forma normalizada de un trabajo técnico o científico. Es la 
ocasión que tiene el estudiante de demostrar que sabe analizar un problema, sabe seleccionar la metodología y técnicas 
apropiadas para reunir los datos, y alcanzar conclusiones razonables. Un proyecto de esta naturaleza permite la evaluación 
de la capacidad del estudiante para aplicar su conocimiento a un tema concreto.

El proyecto fin de carrera debe ser
\begin{itemize}
\item Proyecto Personal: debe ser un producto de la reflexión, investigación y esfuerzo del estudiante. Si se hace con 
 reflexión, con investigación y esfuerzo personal, el rendimiento que obtiene el estudiante es muy productivo y beneficioso para él y de una duración permanente.
\item  Es un trabajo documentado: es decir, serio, científico, hay que sustentar las afirmaciones con datos comprobables 
 y lógicamente fundados.
\item  Planificado: La elaboración de un proyecto fin de carrera es un proceso complicado. Un trabajo de esta naturaleza 
 requiere una planificación cuidadosa del tiempo: tiempo para investigar y documentarse, tiempo para reflexionar, 
 tiempo para corregir posibles desviaciones y finalmente tiempo para redactarlo y presentarlo de forma adecuada.
\end{itemize}

El esquema final de un proyecto fin de carrera debe llenar las siguientes características:

\begin{itemize}
\item Claridad: la claridad se consigue sobre todo con una nítida división y distribución del esquema. Y a su vez esta 
 claridad deriva también de la compresión en profundidad del material recogido.
\item Convergencia hacia el objetivo: El secreto de la claridad está en saber ordenar las partes del trabajo hacia el 
 objetivo buscado; es decir, en lograr que cada punto del esquema nos vaya encaminando con naturalidad hacia la meta 
 enunciada en el título del trabajo.
\item Coherencia: las distintas partes, puntos o párrafos deben estar trabados entre sí, concatenados, de forma que se 
 vayan preparando y completandose recíprocamente para conseguir el efectode que cada punto sea consecuencia del otro, 
 formando un todo orgánico y no una mera yuxtaposición de partes; por el contrario que se vaya mostrando la conexión 
 y la coherencia lógica de los distintos aspectos tratados
\item Conformidad con el objetivo: La estructura del esquema final debe resaltar lo más importante y debe dejar en la 
 penumbra los accesorios.
\item Elegancia: en la distribución del esquema, debe guardarse una cierta simetría y proporción. La elegancia no debe 
 subordinarse a la claridad y a la verdad; pero hay una elegancia no sólo formal, sino de concepción y elegancia 
 que contribuye significativamente a conseguir la armonía y transparencia en la transmisión del contenido principal 
 del tema. Conviene resaltar esta elegancia sobre todo ahora que nos encontramos en un mundo de zafiedad y donde se 
 hace gala del caos mental como norma de actuación.
\item El descanso inteligente: Una vez que se ha acabado la primera redacción del proyecto se sugiere tomarse unos 
 días de descanso suficientes para que la cabeza descanse del tema. Con este descanso se adquiere perspectiva, 
 y aumenta la objetividad y sentido crítico del autor.
\end{itemize}


% Aqui va la Bibliografía utilizada por el proyecto.

\begin{thebibliography}{1}

\bibitem{La86} Leslie Lamport {\em LaTex : A document Preparation System}. Addison"=Wesley, 1986.

\bibitem{Ro93} Christian Rolland {\em LaTex guide pratique}. Addison"=Wesley, 1993.

\bibitem{Castrillon05} M. Castrillón Santana, C. Guerra Artal and M. Hernández Tejera {\em Real"=time Detection of Faces in Video.} Face Processing in Video 2005, Victoria, Canada.


\bibitem{Chellappa95} R. Chellappa et al. {\em Human and machine recognition of faces: A survey.} Proceedings IEEE, vol. 83(5), 705~-740, 1995.

\bibitem{Cielniak03} G. Cielniak, M. Miladinovic, D. Hammarin, L. Göransson, A. Lilienthal and T. Duckett {\em Appearance-based Tracking of Persons with an Omnidirectional Vision Sensor} Proceedings of the Fourth IEEE Workshop on Omnidirectional Vision (Omnivis 2003)", Madison, Wisconsin", 2003

\bibitem{Deniz04} O. Déniz, A. Falcón, J. Méndez, M. Castrillón {\em Useful Computer Vision Techniques for Human-Robot Interaction.} International Conference on Image Analysis and Recognition, September 2004, Porto, Portugal.

\bibitem{Hjelmas01a} E. Hjelmas y B. K. Low {\em Face Detection: A Survey.} Computer Vision and Image Understanding, vol. 83(3), 2001.

\bibitem{Iges99} José Iges {\em El espacio. El tiempo en la mirada del sonido.} Catálogo de exposición. Kulturanea. España, 1999.

\bibitem{Krueger85} Myron W. Krueger, Thomas Gionfriddo y Katrin Hinrichsen {\em VIDEOPLACE: An Artificial Reality} Proceedings of the SIGCHI conference on Human factors in computing systems, 35~-40, 1985.

\bibitem{Levin04} Golan Levin y Zachary Lieberman {\em In-Situ Speech Visualization in Real-Time Interactive Installation and Performance.} The 3rd International Symposium on Non-Photorealistic Animation and Rendering (NPAR) June 7~-9 2004, Annecy, France

\bibitem{Samal92} A. Samal and P. A. Iyengar {\em Automatic Recognition and Analysis of Human Faces and Facial Expressions: A Survey.} Pattern Recognition, vol. 25(1), 1992.

\bibitem{Spalter99} Anne Morgan Spalter {\em The Computer in The Visual Arts.} Addison-Wesley Professional. 1st edition, 1999.

\bibitem{Viola01cvpr} P. Viola and M. J. Jones {\em Rapid Object Detection using a Boosted Cascade of Simple Features.} In Computer Vision and Pattern Recognition, 2001a.

\bibitem{Yang02} M. H. Yang et al. {\em Detecting Faces in Images: A Survey.} Transactions on Pattern Analysis and Machine Intelligence, vol. 24(1), 34~-58, 2002.

\bibitem{OpenCV09} Willow Garage: S. Hassan, S. Cousins, B. Gerkey et al. {\em OpenCV, Open Source Computer Vision} Official Page and Documentation: http://opencv.willowgarage.com/documentation/index.html 2009.

\bibitem{Chuck09} G. Wang, P. Cook et al. {\em Chuck, Strongly-timed, Concurrent, and On-the-fly Audio Programming Language} http://chuck.cs.princeton.edu/ 2009.

\bibitem{DME09} Devmasters.net {\em 3D Engines Data Base} http://www.devmaster.net/engines/ 2009

\bibitem{UDK09} Epic Games {\em Unreal Development Kit} http://www.udk.com/ 2009

\bibitem{UDKS09} Epic Games {\em Unreal Script Language Reference, Example Program Structure}  http://udn.epicgames.com/Three/UnrealScriptReference.html/ 2009

\bibitem{UDKFL09} Epic Games {\em Unreal Engine 3: Rendering Feature List}  http://www.unrealtechnology.com/features.php?ref=rendering 2009

\bibitem{CryE309} CryTek {\em CryENGINE 3 Educational SDK License} http://mycryengine.com/index.php?conid=42 2009

\bibitem{CryE3FL09} CryTek {\em CryENGINE 3 - Specifications}  http://www.crytek.com/technology/cryengine-3/specifications/ 2009

\bibitem{CryMod09} Crytek {\em CryTek Official Modding Portal} Educational community area for the CryENGINE 3 Software Development Kit: http://www.crymod.com/ 2009

\bibitem{wx09} wxWidgets {\em wxWidgets, Cross~platform GUI library} http://www.wxwidgets.org/ 2009

\bibitem{wxFL09} wxWidgets {\em wxWidgets Features} http://www.wxwidgets.org/about/feature2.htm 2009

\bibitem{KenB01} K. Beck, J. Sutherland et al. {\em Manifesto for Agile Software Development} http://www.agilemanifesto.org 2001

\bibitem{RCol09} R. Colusso {\em Desarrollo ágil de software} http://knol.google.com/k/desarrollo-ágil-de-software 2009

\bibitem{IJacobson09} I. Jacobson {Introducing the Essential Unified Process} 2009

\bibitem{BOOST10} D. Abrahams et al. {Boost C++ Liraries} http://www.boost.org/ 2010

\bibitem{SFML10} L. Gomila {Simple and Fast Multimedia Library} http://www.sfml-dev.org 2010

\bibitem{PGSQL10} PostGreSQL {\em PostGreSQL, The world most advanced open source database} http://www.postgresql.org/about/ 2010

\bibitem{DEBEA10} Debea {\em Debea Database Access Library} http://www.debea.net/ 2010

\end{thebibliography}


% Termina el documento
\end{document}
