<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0057)http://udn.epicgames.com/Three/UnrealScriptReference.html -->
<HTML><HEAD><META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE> UDN - Three - UnrealScriptReference    </TITLE>

<STYLE type="text/css" media="all">@import "rsrc/udn_new.css";</STYLE>
<!-- view.static_udn3.tmpl  -->
<SCRIPT language="JavaScript" type="text/javascript" src="./UDN - Three - UnrealScriptReference_files/udn.js"></SCRIPT>

</HEAD><BODY id="webbgThree"><P>

</P><DIV id="webThree"><DIV id="head">
<DIV style="background: url(/pub/webbg_new.jpg); background-repeat: no-repeat; height:140px; width: 100%;">
<DIV id="nav">
<UL class="nav">
<FONT color="black">|</FONT>&nbsp;&nbsp;<LI class="nav_Three"><A href="http://udn.epicgames.com/Main/WebHome.html" class="twikiLink">Main</A></LI><FONT color="black">|</FONT><LI class="nav_Three"><A href="http://udn.epicgames.com/Two/WebHome.html" class="twikiLink">UnrealEngine2</A></LI><FONT color="black">|</FONT><LI class="nav_Three"><A href="http://udn.epicgames.com/Three/WebHome.html" class="twikiLink">UnrealEngine3</A></LI><FONT color="black">|</FONT><LI class="nav_Three">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</LI><FONT color="black">|</FONT><LI class="nav_Three"><A href="http://udn.epicgames.com/Main/BusinessAndLegal.html" class="twikiLink">Business &amp; Legal</A></LI><FONT color="black">|</FONT>
</UL><BR><BR><BR>
</DIV>
</DIV>
</DIV> <!-- end head -->
<DIV id="pagedefault">
<DIV id="maincol">
<DIV id="tool">
<DIV id="tooltop">UDN</DIV> 
<DIV id="tooltext" style="padding: 10px 10px 10px 10px;">
Search public documentation<BR>
<FORM action="http://udn.epicgames.com/search" method="GET" name="main" id="main">
<INPUT type="TEXT" name="q" size="15" style="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;">
<INPUT type="SUBMIT" value="Search" style="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;"><BR>
</FORM></DIV>
<DIV id="toolband">UnrealScriptReference  </DIV>
<DIV id="tooltext">
<!-- Three/UnrealScriptReference --> Licensees can <A href="https://udn.epicgames.com/Three/UnrealScriptReference">log in</A>.<P><A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#" class="restricted">Red</A> links require licensee log in.</P>
Interested in the Unreal engine?<BR>
Check out the <A href="http://www.epicgames.com/licensing.html" target="_top">licensing</A> page.<BR>
<BR>
Questions about UDN itself?<BR>
Contact the <A href="http://udn.epicgames.com/Main/ContactUDNStaff.html" class="twikiLink">UDN Staff</A>
</DIV> <!-- end toolbox content -->
<DIV id="toolbottom"></DIV>
</DIV> <!-- end tool -->
<H1><A name="UnrealScript Language Reference"></A><A name="_UnrealScript Language Reference"></A> UnrealScript Language Reference </H1>
<P>
<EM>Document Summary: Introduction to and short reference of UnrealScript. Original author was <A href="https://udn.epicgames.com/Main/TimSweeney" class="restricted">Tim Sweeney</A> (<A href="https://udn.epicgames.com/Main/EpicGames" class="restricted">EpicGames</A>).</EM>
</P><P>
<EM>Document Changelog: Created; Maintained over time.</EM>
</P><P>
</P><DIV class="twikiToc"><SPAN class="twikiTocTitle">Contents</SPAN> <UL>
<LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#UnrealScript Language Reference"> UnrealScript Language Reference</A> <UL>
<LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Introduction"> Introduction</A> <UL>
<LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Quick Links"> Quick Links</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Purpose of this document"> Purpose of this document</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Design goals of _UnrealScript"> Design goals of UnrealScript</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#New in Unreal Engine 3"> New in Unreal Engine 3</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Example program structure"> Example program structure</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#The Unreal Virtual Machine"> The Unreal Virtual Machine</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Object Hierarchy"> Object Hierarchy</A>
</LI></UL> 
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Classes"> Classes</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Variables"> Variables</A> <UL>
<LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Variable types"> Variable types</A> <UL>
<LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Built-in types"> Built-in types</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Aggregate data types"> Aggregate data types</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Unreal types"> Unreal types</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Variable specifiers"> Variable specifiers</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Editability"> Editability</A>
</LI></UL> 
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Arrays"> Arrays</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Structs"> Structs</A> <UL>
<LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Struct specifiers"> Struct specifiers</A>
</LI></UL> 
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Enumerations"> Enumerations</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Constants"> Constants</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Object and actor reference variables"> Object and actor reference variables</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Class Reference Variables"> Class Reference Variables</A>
</LI></UL> 
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Expressions"> Expressions</A> <UL>
<LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Assignment"> Assignment</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Converting object references among classes"> Converting object references among classes</A>
</LI></UL> 
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Functions"> Functions</A> <UL>
<LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Declaring Functions"> Declaring Functions</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Function parameter specifiers"> Function parameter specifiers</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Function overriding"> Function overriding</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Advanced function specifiers"> Advanced function specifiers</A>
</LI></UL> 
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Control Structures"> Control Structures</A> <UL>
<LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Repetition Structures"> Repetition Structures</A> <UL>
<LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#For Loops"> For Loops</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Do Loops"> Do Loops</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#While Loops"> While Loops</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Continue"> Continue</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Break"> Break</A>
</LI></UL> 
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Selection Structures"> Selection Structures</A> <UL>
<LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#If-Then-Else Statements"> If-Then-Else Statements</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Case Statements"> Case Statements</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Goto"> Goto</A>
</LI></UL> 
</LI></UL> 
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Language Functionality"> Language Functionality</A> <UL>
<LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Built-in operators and their precedence"> Built-in operators and their precedence</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#General purpose functions"> General purpose functions</A> <UL>
<LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Creating objects"> Creating objects</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Integer functions"> Integer functions</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Floating point functions"> Floating point functions</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#String functions"> String functions</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Vector functions"> Vector functions</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Timer functions"> Timer functions</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Debugging functions"> Debugging functions</A>
</LI></UL> 
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#UnrealScript preprocessor"> UnrealScript preprocessor</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#UnrealScript tools and utilities"> UnrealScript tools and utilities</A> <UL>
<LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Script Profiler"> Script Profiler</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Script Debugger"> Script Debugger</A>
</LI></UL> 
</LI></UL> 
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Advanced Language Features"> Advanced Language Features</A> <UL>
<LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Timers"> Timers</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#States"> States</A> <UL>
<LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Overview of States"> Overview of States</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#State Labels and Latent Functions"> State Labels and Latent Functions</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#State inheritance and scoping rules"> State inheritance and scoping rules</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Advanced state programming"> Advanced state programming</A> <UL>
<LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#State Stacking"> State Stacking</A>
</LI></UL> 
</LI></UL> 
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Replication"> Replication</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Iteration (_ForEach)"> Iteration (ForEach)</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Function Calling Specifiers"> Function Calling Specifiers</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Accessing static functions in a variable class"> Accessing static functions in a variable class</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Default values of variables"> Default values of variables</A> <UL>
<LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Accessing default values of variables"> Accessing default values of variables</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Accessing default values of variables through a class reference"> Accessing default values of variables through a class reference</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Specifying default values using the defaultproperties block"> Specifying default values using the defaultproperties block</A> <UL>
<LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Syntax"> Syntax</A>
</LI></UL> 
</LI></UL> 
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Struct Defaults"> Struct Defaults</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Dynamic Arrays"> Dynamic Arrays</A> <UL>
<LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Length Variable"> Length Variable</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Iterating Dynamic Arrays"> Iterating Dynamic Arrays</A>
</LI></UL> 
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Interface Classes"> Interface Classes</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Function Delegates"> Function Delegates</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Native Classes"> Native Classes</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#MetaData Support"> MetaData Support</A> <UL>
<LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Metadata Overview"> Metadata Overview</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Using Multiple _MetaData Specifications"> Using Multiple MetaData Specifications</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Available _MetaData Specifications"> Available MetaData Specifications</A>
</LI></UL> 
</LI></UL> 
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Advanced Technical Issues"> Advanced Technical Issues</A> <UL>
<LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#UnrealScript Implementation"> UnrealScript Implementation</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#UnrealScript binary compatibility issues"> UnrealScript binary compatibility issues</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#Technical notes"> Technical notes</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#UnrealScript programming strategy"> UnrealScript programming strategy</A>
</LI></UL> 
</LI></UL> 
</LI></UL> 
</DIV>
<P>
<NOAUTOLINK>
</NOAUTOLINK></P><P>
</P><P>
</P><H2><A name="Introduction"></A> Introduction </H2>
<P>
</P><H3><A name="Quick Links"></A> Quick Links </H3>
<P>
<STRONG>Be sure to check out the UnrealScript <A href="http://udn.epicgames.com/Three/UnrealScriptCheatSheet.html" class="twikiLink">CheatSheet</A> and the <A href="https://udn.epicgames.com/Three/MasteringUnrealScriptTableOfContents" class="restricted">MasteringUnrealScriptTOC</A> tutorials</STRONG>.
</P><P>
</P><H3><A name="Purpose of this document"></A> Purpose of this document </H3>
<P>
This is a technical document describing the UnrealScript language. It's not a tutorial, nor does it provide detailed examples of useful UnrealScript code. For examples of UnrealScript the reader is referred to the source code of the engine, which provides tens of thousands of lines of working UnrealScript code which solves many problems such as AI, movement, inventory, and triggers. A good way to get started is by looking at the "Actor", "Object", "Controller", "Pawn", and "Weapon" scripts.
</P><P>
This document assumes that the reader has a working knowledge of C/C++ or Java, is familiar with object-oriented programming, has played Unreal and has used the UnrealEd editing environment.
</P><P>
For programmers who are new to OOP, I highly recommend going to Amazon.com or a bookstore and buying an introductory book on Java programming.  Java is very similar to UnrealScript, and is an excellent language to learn about due to its clean and simple approach.
</P><P>
</P><H3><A name="Design goals of _UnrealScript"></A> Design goals of UnrealScript </H3>
<P>
UnrealScript was created to provide the development team and the third-party Unreal developers with a powerful, built-in programming language that maps naturally onto the needs and nuances of game programming.
</P><P>
The major design goals of UnrealScript are: 
</P><P> </P><UL>
<LI> To support the major concepts of time, state, properties, and networking which traditional programming languages don't address. This greatly simplifies UnrealScript code. The major complication in C/C++ based AI and game logic programming lies in dealing with events that take a certain amount of game time to complete, and with events which are dependent on aspects of the object's state. In C/C++, this results in spaghetti-code that is hard to write, comprehend, maintain, and debug. UnrealScript includes native support for time, state, and network replication which greatly simplify game programming.
</LI></UL> 
<P> </P><UL>
<LI> To provide Java-style programming simplicity, object-orientation, and compile-time error checking. Much as Java brings a clean programming platform to Web programmers, UnrealScript provides an equally clean, simple, and robust programming language to 3D gaming. The major programming concepts which UnrealScript derives from Java are: <UL>
<LI> a pointerless environment with automatic garbage collection;
</LI> <LI> a simple single-inheritance class graph;
</LI> <LI> strong compile-time type checking;
</LI> <LI> a safe client-side execution "sandbox";
</LI> <LI> and the familiar look and feel of C/C++/Java code. 
</LI></UL> 
</LI></UL> 
<P> </P><UL>
<LI> To enable rich, high level programming in terms of game objects and interactions rather than bits and pixels. Where design tradeoffs had to be made in UnrealScript, I sacrificed execution speed for development simplicity and power. After all, the low-level, performance-critical code in Unreal is written in C/C++ where the performance gain outweighs the added complexity. UnrealScript operates at a level above that, at the object and interaction level, rather than the bits and pixels level.
</LI></UL> 
<P>
During the early development of UnrealScript, several major different programming paradigms were explored and discarded before arriving at the current incarnation. First, I researched using the Sun and Microsoft Java VM's for Windows as the basis of Unreal's scripting language. It turned out that Java offered no programming benefits over C/C++ in the Unreal context, added frustrating restrictions due to the lack of needed language features (such as operator overloading), and turned out to be unfathomably slow due to both the overhead of the VM task switch and the inefficiencies of the Java garbage collector in the case of a large object graph. Second, I based an early implementation of UnrealScript on a Visual Basic variant, which worked fine, but was less friendly to programmers accustomed to C/C++. The final decision to base UnrealScript on a C++/Java variant was based on the desire to map game-specific concepts onto the language definition itself, and the need for speed and familiarity. This turned out to be a good decision, as it has greatly simplified many aspects of the Unreal codebase.
</P><P>
</P><H3><A name="New in Unreal Engine 3"></A> New in Unreal Engine 3 </H3>
<P>
For those who are already familiar with UnrealScript, here's a short overview of the major changes in UnrealScript since UnrealEngine2.
</P><P> </P><UL>
<LI> Replication - replication statements have changed in UE3: <UL>
<LI> The replication block is only used for variables now
</LI> <LI> Function replication is now defined by means of <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#AdvancedFunctionSpecifiers" class="twikiAnchorLink">function specifiers</A> ( <EM>Server, Client, Reliable</EM> )
</LI></UL> 
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#StateStacking" class="twikiAnchorLink">Stacking states</A> - you are now able to push and pop states onto a stack
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptPreprocessor.html" class="twikiLink">UnrealScript Preprocessor</A> - support for macros and conditional compilation
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#DebuggingFunctions" class="twikiAnchorLink">Debugging Functions</A> - new debugging related functions have been added
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#DefaultPropertiesParser" class="twikiAnchorLink">Default properties</A> - processing of the defaultproperties block has been changed\improved a bit <UL>
<LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#StructDefaults" class="twikiAnchorLink">Struct defaults</A> - structs can now also have default properties
</LI> <LI> It is no longer allowed to set default values for config or localized variables
</LI> <LI> Defaultproperties are readonly at runtime, it is no longer allowed to do <CODE>class'MyClass'.default.variable = 1</CODE>
</LI></UL> 
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#DynArray" class="twikiAnchorLink">Dynamic Arrays</A> - Dynamic arrays now have a new function <EM>find()</EM> to find the index of an element
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#DynArrayIterator" class="twikiAnchorLink">Dynamic Array Iterators</A> - The foreach operator now functions on dynamic arrays.
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptDelegates.html" class="twikiLink">Delegate function arguments</A> - UE3 now allows delegates to be passed as function arguments
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptInterfaces.html" class="twikiLink">Interfaces</A> - Support for interfaces has been added
</LI> <LI> Accessing constants from other classes: <CODE>class'SomeClass'.const.SOMECONST</CODE>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#TimerFunctions" class="twikiAnchorLink">Multiple timer support</A>
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#DefFuncArgs" class="twikiAnchorLink">Default function argument values</A> - the default value for optional function arguments can now be specified.
</LI> <LI> Tooltip Support - Editor property windows now display tooltips when you mouse over a property, if that property has a comment of the form <CODE>/** tooltip text */</CODE> above its declaration in UnrealScript. 
</LI> <LI> <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#UnrealScriptMetadata" class="twikiAnchorLink">Metadata Support</A> - Extend in-game and in-editor functionality by associating properties with various types of metadata.
</LI></UL> 
<P>
</P><H3><A name="Example program structure"></A> Example program structure </H3>
<P>
This example illustrates a typical, simple UnrealScript class, and it highlights the syntax and features of UnrealScript. Note that this code may differ from that which appears in the current Unreal source, as this documentation is not synced with the code.
</P><P>
</P><PRE>//=====================================================================
// TriggerLight.
// A lightsource which can be triggered on or off.
//=====================================================================
class TriggerLight extends Light;
 
//---------------------------------------------------------------------
// Variables.
 
var() float ChangeTime; // Time light takes to change from on to off.
var() bool bInitiallyOn; // Whether it's initially on.
var() bool bDelayFullOn; // Delay then go full-on.
 
var ELightType InitialType; // Initial type of light.
var float InitialBrightness; // Initial brightness.
var float Alpha, Direction;
var actor Trigger;
 
//---------------------------------------------------------------------
// Engine functions.
 
// Called at start of gameplay.
function BeginPlay()
{
   // Remember initial light type and set new one.
   Disable( 'Tick' );
   InitialType = LightType;
   InitialBrightness = LightBrightness;
   if( bInitiallyOn )
   {
      Alpha = 1.0;
      Direction = 1.0;
   }
   else
   {
      LightType = LT_None;
      Alpha = 0.0;
      Direction = -1.0;
   }
}
 
// Called whenever time passes.
function Tick( float DeltaTime )
{
   LightType = InitialType;
   Alpha += Direction * DeltaTime / ChangeTime;
   if( Alpha &gt; 1.0 )
   {
      Alpha = 1.0;
      Disable( 'Tick' );
      if( Trigger != None )
         Trigger.ResetTrigger();
   }
   else if( Alpha &lt; 0.0 )
   {
      Alpha = 0.0;
      Disable( 'Tick' );
      LightType = LT_None;
      if( Trigger != None )
         Trigger.ResetTrigger();
   }
   if( !bDelayFullOn )
      LightBrightness = Alpha * InitialBrightness;
   else if( (Direction&gt;0 &amp;amp;amp;amp;&amp;amp;amp;amp; Alpha!=1) || Alpha==0 )
      LightBrightness = 0;
   else
      LightBrightness = InitialBrightness;
}
 
//---------------------------------------------------------------------
// Public states.
 
// Trigger turns the light on.
state() TriggerTurnsOn
{
   function Trigger( actor Other, pawn EventInstigator )
   {
      Trigger = None;
      Direction = 1.0;
      Enable( 'Tick' );
   }
}
 
// Trigger turns the light off.
state() TriggerTurnsOff

{
   function Trigger( actor Other, pawn EventInstigator )
   {
      Trigger = None;
      Direction = -1.0;
      Enable( 'Tick' );
   }
}
 
// Trigger toggles the light.
state() TriggerToggle
{
   function Trigger( actor Other, pawn EventInstigator )
   {
      log("Toggle");
      Trigger = Other;
      Direction *= -1;
      Enable( 'Tick' );
   }
}
 
// Trigger controls the light.
state() TriggerControl
{
   function Trigger( actor Other, pawn EventInstigator )
   {
      Trigger = Other;
      if( bInitiallyOn ) Direction = -1.0;
      else Direction = 1.0;
      Enable( 'Tick' );
   }
   function UnTrigger( actor Other, pawn EventInstigator )
   {
      Trigger = Other;
      if( bInitiallyOn ) Direction = 1.0;
      else Direction = -1.0;
      Enable( 'Tick' );
   }
}
</PRE>
<P>
The key elements to look at in this script are: 
</P><P> </P><UL>
<LI> The class declaration. Each class "extends" (derives from) one parent class, and each class belongs to a "package," a collection of objects that are distributed together. All functions and variables belong to a class, and are only accessible through an actor that belongs to that class. There are no system-wide global functions or variables. <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#ClassDeclaration" class="twikiAnchorLink">More Details</A>
</LI></UL> 
<P> </P><UL>
<LI> The variable declarations. UnrealScript supports a very diverse set of variable types including most base C/Java types, object references, structs, and arrays. In addition, variables can be made into editable properties, which designers can access in UnrealEd without any programming. These properties are designated using the <CODE>var()</CODE> syntax, instead of <CODE>var</CODE>.  <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#VariableDeclaration" class="twikiAnchorLink">More Details</A>
</LI></UL> 
<P> </P><UL>
<LI> The functions. Functions can take a list of parameters, and they optionally return a value. Functions can have local variables. Some functions are called by the Unreal engine itself (such as BeginPlay), and some functions are called from other script code elsewhere (such as Trigger).  <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#FunctionDeclarations" class="twikiAnchorLink">More Details</A>
</LI></UL> 
<P> </P><UL>
<LI> The code. All of the standard C and Java keywords are supported, like <CODE>for</CODE>, <CODE>while</CODE>, <CODE>break</CODE>, <CODE>switch</CODE>, <CODE>if</CODE>, and so on.  Braces and semicolons are used in UnrealScript as in C, C++, and Java.
</LI></UL> 
<P> </P><UL>
<LI> Actor and object references. Here you see several cases where a function is called within another object, using an object reference.  <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#ObjectRefs" class="twikiAnchorLink">More Details</A>
</LI></UL> 
<P> </P><UL>
<LI> The "state" keyword. This script defines several "states", which are groupings of functions, variables, and code that are executed only when the actor is in that state.  <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#StateDeclaration" class="twikiAnchorLink">More Details</A>
</LI></UL> 
<P> </P><UL>
<LI> Note that all keywords, variable names, functions, and object names in UnrealScript are case-insensitive. To UnrealScript, <CODE>Demon</CODE>, <CODE>demON</CODE>, and <CODE>demon</CODE> are the same thing.
</LI></UL> 
<P>
</P><H3><A name="The Unreal Virtual Machine"></A> The Unreal Virtual Machine </H3>
<P>
The Unreal Virtual Machine consists of several components: The server, the client, the rendering engine, and the engine support code.
</P><P>
The Unreal server controls all gameplay and interaction between players and actors. In a single-player game, both the Unreal client and the Unreal server are run on the same machine; in an Internet game, there is a dedicated server running on one machine; all players connect to this machine and are clients.
</P><P>
All gameplay takes place inside a "level", a self-contained environment containing geometry and actors. Though UnrealServer may be capable of running more than one level simultaneously, each level operates independently, and are shielded from each other: actors cannot travel between levels, and actors on one level cannot communicate with actors on another level.
</P><P>
Each actor in a map can either be under player control (there can be many players in a network game) or under script control. When an actor is under script control, its script completely defines how the actor moves and interacts with other actors.
</P><P>
With all of those actors running around, scripts executing, and events occuring in the world, you're probably asking how one can understand the flow of execution in an UnrealScript. The answer is as follows:
</P><P>
To manage time, Unreal divides each second of gameplay into "Ticks". A tick is the smallest unit of time in which all actors in a level are updated. A tick typically takes between 1/100th to 1/10th of a second. The tick time is limited only by CPU power; the faster machine, the lower the tick duration is.
</P><P>
Some commands in UnrealScript take zero ticks to execute (i.e. they execute without any game-time passing), and others take many ticks. Functions that require game-time to pass are called "latent functions". Some examples of latent functions include <EM>Sleep</EM>, <EM>FinishAnim</EM>, and <EM>MoveTo</EM>. Latent functions in UnrealScript may only be called from code within a state (the so called "state code"), not from code within a function (that includes functions define within a state).
</P><P>
While an actor is executing a latent function, that actor's state execution doesn't continue until the latent function completes. However, other actors, or the VM, may call functions within the actor. The net result is that all UnrealScript functions can be called at any time, even while latent functions are pending.
</P><P>
In traditional programming terms, UnrealScript acts as if each actor in a level has its own "thread" of execution. Internally, Unreal does not use Windows threads, because that would be very inefficient (Windows 95 and Windows NT do not handle thousands of simultaneous threads efficiently). Instead, UnrealScript simulates threads. This fact is transparent to UnrealScript code, but becomes very apparent when you write C++ code that interacts with UnrealScript.
</P><P>
All UnrealScripts are executed independently of each other. If there are 100 monsters walking around in a level, all 100 of those monsters' scripts are executing simultaneously and independently each "Tick".
</P><P>
</P><H3><A name="Object Hierarchy"></A> Object Hierarchy </H3>
<P>
Before beginning work with UnrealScript, it's important to understand the high-level relationships of objects within Unreal. The architecture of Unreal is a major departure from that of most other games: Unreal is purely object-oriented (much like COM/ActiveX), in that it has a well-defined object model with support for high-level object oriented concepts such as the object graph, serialization, object lifetime, and polymorphism. Historically, most games have been designed monolithically, with their major functionality hardcoded and unexpandable at the object level, though many games, such as Doom and Quake, have proven to be very expandable at the content level. There is a major benefit to Unreal's form of object-orientation: major new functionality and object types can be added to Unreal at runtime, and this extension can take the form of subclassing, rather than (for example) by modifying a bunch of existing code. This form of extensibility is extremely powerful, as it encourages the Unreal community to create Unreal enhancements that all interoperate.
</P><P>
Object is the parent class of all objects in Unreal. All of the functions in the Object class are accessible everywhere, because everything derives from Object. Object is an abstract base class, in that it doesn't do anything useful. All functionality is provided by subclasses, such as Texture (a texture map), TextBuffer (a chunk of text), and Class (which describes the class of other objects).
</P><P>
Actor (extends Object) is the parent class of all standalone game objects in Unreal. The Actor class contains all of the functionality needed for an actor to move around, interact with other actors, affect the environment, and do other useful game-related things.
</P><P>
Pawn (extends Actor) is the parent class of all creatures and players in Unreal which are capable of high-level AI and player controls.
</P><P>
Class (extends Object) is a special kind of object which describes a class of object. This may seem confusing at first: a class is an object, and a class describes certain objects. But, the concept is sound, and there are many cases where you will deal with Class objects. For example, when you spawn a new actor in UnrealScript, you can specify the new actor's class with a Class object.
</P><P>
With UnrealScript, you can write code for any Object class, but 99% of the time, you will be writing code for a class derived from Actor. Most of the useful UnrealScript functionality is game-related and deals with actors.
</P><P>
<A name="ClassDeclaration"></A>
</P><H2><A name="Classes"></A> Classes </H2>
<P>
Each script corresponds to exactly one class, and the script begins by declaring the class, the class's parent, and any additional information that is relevent to the class. The simplest form is:
</P><P>
</P><PRE>class MyClass extends MyParentClass;
</PRE>
<P>
Here I am declaring a new class named "MyClass", which inherits the functionality of "MyParentClass". Additionally, the class resides in the package named "MyPackage".
</P><P>
Each class inherits all of the variables, functions, and states from its parent class. It can then add new variable declarations, add new functions (or override the existing functions), add new states (or add functionality to the existing states).
</P><P>
The typical approach to class design in UnrealScript is to make a new class (for example a Minotaur monster) which extends an existing class that has most of the functionality you need (for example the Pawn class, the base class of all monsters). With this approach, you never need to reinvent the wheel -- you can simply add the new functionality you want to customize, while keeping all of the existing functionality you don't need to customize. This approach is especially powerful for implementing AI in Unreal, where the built-in AI system provides a tremendous amount of base functionality which you can use as building blocks for your custom creatures.
</P><P>
The class declaration can take several optional specifiers that affect the class: 
</P><P> </P><DL>
<DT> <B>Native(PackageName)</B></DT><DD> Indicates that "this class uses behind-the-scenes C++ support". Unreal expects native classes to contain a C++ implementation in the .EXE.  Only native classes are allowed to declare native functions or implement native interfaces.  Native classes must always derive from another native class.  Native classes create an auto-generated C++ header file with the necessary <EM>glue</EM> to interact with the script variables and specified functions.  By default, the <EM>PackageName</EM> is the package that the script class resides in.  For example, if the class were in the Engine package, the resulting auto-generated header would be called <EM>EngineClasses.h</EM>.
</DD> <DT> <B>NativeReplication</B></DT><DD> Indicates that replication of variable values for this class is handled in the C++ implementation.  Only valid for native classes.
</DD> <DT> <B>DependsOn(<I>ClassName</I>[,<I>ClassName</I>,...])</B></DT><DD> Indicates that <I>ClassName</I> is compiled before this class.  <I>ClassName</I> must specify a class in the same (or a previous) package.  Multiple dependency classes can be specified using a single <CODE>DependsOn</CODE> line delimited by commas, or can be specified using a separate <CODE>DependsOn</CODE> line for each class.
</DD> <DT> <B>Abstract</B></DT><DD> Declares the class as an "abstract base class". This prevents the user from adding actors of this class to the world in UnrealEd or creating instances of this class during the game, because the class isn't meaningful on its own. For example, the "Actor" base class is abstract, while the "Ladder" subclass is not abstract -- you can place a Ladder in the world, but you can't place an Actor in the world.  This keyword is propagated to intrinsic child classes, but not to script child classes.
</DD> <DT> <B>Deprecated</B></DT><DD> Causes all objects of this class to be loaded but not saved. Any placed instances of deprecated actors will generate warnings for level designers when they load a map in the editor.  This keyword is propagated to child classes.
</DD> <DT> <B>Transient</B></DT><DD> Says "objects belonging to this class should never be saved on disk". Only useful in conjunction with certain kinds of native classes which are non-persistent by nature, such as players or windows.  This keyword is propagated to child classes; child classes can override this flag using the <CODE>NotTransient</CODE> keyword.
</DD> <DT> <B>NonTransient</B></DT><DD> Negates a <CODE>Transient</CODE> keyword inherited from a base class.
</DD> <DT> <B>Config(IniName)</B></DT><DD> Indicates that this class is allowed to store data in the .ini.  If there are any configurable variables in the class (declared with "config" or "globalconfig"), causes those variables to be stored in the specified configuration file.  This flag is propagated to all child classes and cannot be negated, but child classes can change the .ini file by redeclaring the <CODE>Config</CODE> keyword and specifying a different IniName.  Normally IniName specifies the name of the .ini file to store data in, but several names have a special meaning: <UL>
<LI> Config(Engine): Uses the Engine configuration file, which is the name of your game followed by "Engine.ini".  For example, ExampleGame's engine configuration file is named ExampleEngine.ini.
</LI> <LI> Config(Editor): Uses the Editor configuration file, which is the name of your game followed by "Editor.ini".  For example, ExampleGame's editor configuration file is named ExampleEditor.ini.
</LI> <LI> Config(Game): Uses the Game configuration file, which is the name of your game followed by "Game.ini".  For example, ExampleGame's game configuration file is named ExampleGame.ini.
</LI> <LI> Config(Input): Uses the Input configuration file, which is the name of your game followed by "Input.ini".  For example, ExampleGame's engine configuration file is named ExampleInput.ini.
</LI></UL> 
</DD> <DT> <B>PerObjectConfig</B></DT><DD> Configuration information for this class will be stored per object, where each object has a section in the .ini file named after the object in the format [ObjectName ClassName].  This keyword is propagated to child classes.
</DD> <DT> <B>PerObjectLocalized</B></DT><DD> Localized data for this class will be defined on a per-object basis, where each object has a section in the localization file named after the object in the format [ObjectName ClassName].  This keyword is propagated to child classes.
</DD> <DT> <B>EditInlineNew</B></DT><DD> Editor.  Indicates that objects of this class can be created from the UnrealEd property window (default behavior is that only references to existing objects may be assigned through the property window).  This flag is propagated to all child classes; child classes can override this flag using the <CODE>NotEditInlineNew</CODE> keyword.
</DD> <DT> <B>NotEditInlineNew</B></DT><DD> Editor.  Negates a <CODE>EditInlineNew</CODE> keyword inherited from a base class.  No effect if no parent classes are using <CODE>EditInlineNew</CODE>.
</DD> <DT> <B>Placeable</B></DT><DD> Editor.  Indicates that this class can be created in UnrealEd and placed into a level, UI scene, or kismet window (depending on the class type).  This flag is propagated to all child classes; child classes can override this flag using the <CODE>NotPlaceable</CODE> keyword.
</DD> <DT> <B>NotPlaceable</B></DT><DD> Editor.  Negates a <CODE>Placeable</CODE> keyword inherited from a base class.  Indicates that this class may not be placed into a level, etc. in UnrealEd.
</DD> <DT> <B>HideDropDown</B></DT><DD> Editor.  Prevents this class from showing up in UnrealEd property window combo boxes.
</DD> <DT> <B>HideCategories(<I>Category</I>[,<I>Category</I>,...])</B></DT><DD> Editor.  Specifies one or more categories that should be hidden in the UnrealEd property window for objects of this class.  To hide variables declared with no category, use the name of the class which declares the variable.
</DD> <DT> <B>ShowCategories(<I>Category</I>[,<I>Category</I>,...])</B></DT><DD> Editor.  Negates a <CODE>HideCategories</CODE> keyword inherited from a base class.
</DD> <DT> <B>AutoExpandCategories(<I>Category</I>[,<I>Category</I>,...])</B></DT><DD> Editor.  Specifies one or more categories that should be automatically expanded in the UnrealEd property window for objects of this class.  To auto-expand variables declared with no category, use the name of the class which declares the variable.
</DD> <DT> <B>Collapsecategories</B></DT><DD> Editor.  Indicates that properties of this class should not be grouped in categories in UnrealEd property windows.  This keyword is propagated to child classes; child classes can override this flag using the <CODE>DontCollapseCategories</CODE> keyword.
</DD> <DT> <B>DontCollapseCategories</B></DT><DD> Editor.  Negates a <CODE>CollapseCatogories</CODE> keyword inherited from a base class.
</DD> <DT> <B>Within&nbsp;<I>ClassName</I></B></DT><DD> Advanced. Indicates that objects of this class cannot exist without an instance of <I>ClassName</I>.  In order to create an object of this class, you must specify an instance of <I>ClassName</I> as the <CODE>Outer</CODE> object.  This keyword must be the first to follow the class declaration itself.
</DD> <DT> <B>Inherits(<I>ClassName</I>[,<I>ClassName</I>,...])</B></DT><DD> Advanced. Used for multiple inheritance - specifies the additional base classes.  Multiple bases can be specified using a single <CODE>Inherits</CODE> line delimited by commas, or can be specified using a separate <CODE>Inherits</CODE> line for each base class.  Only valid for native classes.  Multiple inheritance from two UObject-derived classes is not supported.
</DD> <DT> <B>Implements(<I>ClassName</I>[,<I>ClassName</I>,...])</B></DT><DD> Advanced. Specifies one of more interface classes which are this class will implement.  Multiple interfaces can be specified using a single <CODE>Implements</CODE> line delimited by commas, or can be specified using a separate <CODE>Implements</CODE> line for each interface class.  Only native classes can implement native interfaces.
</DD> <DT> <B>NoExport</B></DT><DD> Advanced. Indicates that this class's C++ declaration should not be included in the automatically-generated C++ header file by the script compiler.  The C++ class declaration must be defined manually in a separate header file.  Only valid for native classes.
</DD></DL> 
<P>
</P><P>
<A name="VariableDeclaration"></A>
</P><H2><A name="Variables"></A> Variables </H2>
<P>
</P><H3><A name="Variable types"></A> Variable types </H3>
<P>
</P><H4><A name="Built-in types"></A> Built-in types </H4>
<P>
Here are some examples of instance variable declarations in UnrealScript:
</P><P>
</P><PRE>var int a;               // Declare an integer variable named "A".
var byte Table[64];         // Declare a static array of 64 bytes named "Table".
var string PlayerName;      // Declare a string variable named "PlayerName".
var actor Other;         // Declare a variable which can be assigned a reference to an Actor instance.
var() float MaxTargetDist;   // Declare a float variable named "MaxTargetDist" and allow its value to be modified from an UnrealEd property window.
</PRE>
<P>
Variables can appear in two kinds of places in UnrealScript: Instance variables, which apply to an entire object, appear immediately after the class declarations or within struct declarations. Local variables appear within a function, and are only active while that function executes. Instance variables are declared with the <CODE>var</CODE> keyword. Local variables are declared with the <CODE>local</CODE> keyword, such as:
</P><P>
</P><PRE>function int Foo()
{
   local int Count;
   Count = 1;
   return Count;
}
</PRE>
<P>
Here are the built-in variable types supported in UnrealScript: 
</P><P> </P><UL>
<LI> <STRONG>byte</STRONG>: A single-byte value ranging from <CODE>0</CODE> to <CODE>255</CODE>. 
</LI> <LI> <STRONG>int</STRONG>: A 32-bit integer value. 
</LI> <LI> <STRONG>bool</STRONG>: A boolean value: either <CODE>true</CODE> or <CODE>false</CODE>. 
</LI> <LI> <STRONG>float</STRONG>: A 32-bit floating point number. 
</LI> <LI> <STRONG>string</STRONG>: A string of characters. (see <A href="http://udn.epicgames.com/Three/StringsInUnrealScript.html" class="twikiLink">Unreal Strings</A>)
</LI> <LI> <STRONG>constant</STRONG>: A variable that cannot be modified. 
</LI> <LI> <STRONG>enumeration</STRONG>: A variable that can take on one of several predefined named integer values. For example, the ELightType enumeration defined in the Actor script describes a dynamic light and takes on a value like <CODE>LT_None</CODE>, <CODE>LT_Pulse</CODE>, <CODE>LT_Strobe</CODE>, and so on. 
</LI></UL> 
<P>
</P><H4><A name="Aggregate data types"></A> Aggregate data types </H4>
<P> </P><UL>
<LI> <STRONG>array&lt;Type&gt;</STRONG>: A variable length array of <CODE>Type</CODE>.
</LI> <LI> <STRONG>struct</STRONG>: Similar to C structures, UnrealScript structs let you create new variable types that contain sub-variables. For example, two commonly-used Unreal structs are <CODE>vector</CODE>, which consists of an X, Y, and Z component; and <CODE>rotator</CODE>, which consists of a pitch, yaw, and roll component.
</LI></UL> 
<P>
</P><H4><A name="Unreal types"></A> Unreal types </H4>
<P> </P><UL>
<LI> <STRONG>Name</STRONG>: The name of an item in Unreal (such as the name of a function, state, class, etc).  Names are stored as an index into the global name table. Names correspond to simple strings of up to 64 characters. Names are not like strings in that they are immutable once created (see <A href="http://udn.epicgames.com/Three/StringsInUnrealScript.html" class="twikiLink">Unreal Strings</A> for more information). 
</LI> <LI> <STRONG>Object and Actor references</STRONG>: A variable that refers to another object or actor in the world. For example, the Pawn class has an "Enemy" actor reference that specifies which actor the pawn should be trying to attack. Object and actor references are very powerful tools, because they enable you to access the variables and functions of another actor. For example, in the Pawn script, you can write <EM>Enemy.Damage(123)</EM> to call your enemy's Damage function -- resulting in the enemy taking damage. Object references may also contain a special value called <CODE>None</CODE>, which is the equivalent of the C <CODE>NULL</CODE> pointer: it says "this variable doesn't refer to any object". 
</LI> <LI> <STRONG>Delegate</STRONG>: Holds a reference to an unrealscript function.
</LI></UL> 
<P>
</P><H4><A name="Variable specifiers"></A> Variable specifiers </H4>
<P>
Variables may also contain additional specifiers such as <CODE>const</CODE> that further describe the variable. Actually, there are quite a lot of specifiers which you wouldn't expect to see in a general-purpose programming language, mainly as a result of wanting UnrealScript to natively support many game- and environment- specific concepts:
</P><P> </P><DL>
<DT> <B>config</B></DT><DD> This variable will be made configurable. The current value can be saved to the ini file and will be loaded when created.  Cannot be given a value in default properties.  Implies const.
</DD> <DT> <B>globalconfig</B></DT><DD> Works just like config except that you can't override it in a subclass.  Cannot be given a value in default properties.  Implies const.
</DD> <DT> <B>localized</B></DT><DD> The value of this variable will have a localized value defined. Mostly used for strings. Implies const. Read more about this in the <A href="http://udn.epicgames.com/Three/LocalizationReference.html" class="twikiLink">Localization Reference</A> and <A href="http://udn.epicgames.com/Three/StringsInUnrealScript.html" class="twikiLink">Unreal Strings</A>.
</DD> <DT> <B>const</B></DT><DD> Treats the contents of the variable as a constant. In UnrealScript, you can read the value of const variables, but you can't write to them. "Const" is only used for variables which the engine is responsible for updating, and which can't be safely updated from UnrealScript, such as an actor's Location (which can only be set by calling the MoveActor function). 
</DD> <DT> <B>private</B></DT><DD> The variable is private, and may only be accessed by the class's script; no other classes (including subclasses) may access it.
</DD> <DT> <B>protected</B></DT><DD> The variable can only be accessed from the class and it's subclasses, not from other classes.
</DD> <DT> <B>repnotify</B></DT><DD> Actors should be notified (via the ReplicatedEvent function) when this value for this property is received via replication.
</DD> <DT> <B>deprecated</B></DT><DD> Indicates that this variable is going to be removed in the near future, and should no longer be accessible in the editor.  Deprecated properties are loaded, but not saved.
</DD> <DT> <B>instanced</B></DT><DD> Object properties only.  When an instance of this class is created, it will be given a unique copy of the object assigned to this variable in defaults.  Used for instancing subobjects defined in class default properties.
</DD> <DT> <B>databinding</B></DT><DD> This property can be manipulated by the data store system.
</DD> <DT> <B>editoronly</B></DT><DD> This property's value will only be loaded when running UnrealEd or a commandlet.  During the game, the value for this property is discarded.
</DD> <DT> <B>notforconsole</B></DT><DD> This property's value will only be loaded when running on the PC.  On consoles, the value for this property is discarded.
</DD></DL> 
<P> </P><DL>
<DT> <B>editconst</B></DT><DD> Editor. The variable can be seen in UnrealEd but not edited. A variable that is editconst is <I>not</I> implictly "const".
</DD> <DT> <B>editfixedsize</B></DT><DD> Editor. Only useful for dynamic arrays. This will prevent the user from changing the length of an array via the UnrealEd property window.
</DD> <DT> <B>editinline</B></DT><DD> Editor. Allows the user to edit the properties of the object referenced by this variable within UnrealEd's property inspector (only useful for object references, including arrays of object reference).
</DD> <DT> <B>editinlineuse</B></DT><DD> Editor.  In addition to the behavior associated with <EM>editinline</EM>, adds a "Use" button next to this object reference in the editor
</DD> <DT> <B>noclear</B></DT><DD> Editor. Allows this object reference to be set to None from the editor.
</DD> <DT> <B>interp</B></DT><DD> Editor. Indicates that the value can be driven over time by a Float or Vector Property Track in Matinee.
</DD></DL> 
<P> </P><DL>
<DT> <B>input</B></DT><DD> Advanced. Makes the variable accessible to Unreal's input system, so that input (such as button presses and joystick movements) can be directly mapped onto it. Only relevent with variables of type "byte" and "float". 
</DD> <DT> <B>transient</B></DT><DD> Advanced. Declares that the variable is for temporary use, and isn't part of the object's persistent state. Transient variables are not saved to disk. Transient variables are initialized to the class's default value for that variable when an object is loaded. 
</DD> <DT> <B>duplicatetransient</B></DT><DD> Advanced. Indicates that the variable's value should be reset to the class default value when creating a binary duplicate of an object (via StaticDuplicateObject).
</DD> <DT> <B>noimport</B></DT><DD> Advanced.  Indicates that this variable should be skipped when importing T3D text.  In other words, the value of this variable will not be transferred to new object instances when importing or copy/pasting objects.
</DD> <DT> <B>native</B></DT><DD> Advanced. Declares that the variable is loaded and saved by C++ code, rather than by UnrealScript.
</DD> <DT> <B>export</B></DT><DD> Advanced. Only useful for object properties (or arrays of objects).  Indicates that the object assigned to this property should be exported in its entirety as a subobject block when the object is copied (for copy/paste) or exported to T3D, as opposed to just outputting the object reference itself.
</DD> <DT> <B>noexport</B></DT><DD> Advanced. Only useful for native classes.  This variable should not be included in the auto-generated class declaration.
</DD> <DT> <B>nontransactional</B></DT><DD> Advanced. Indicates that changes to this variable value will not be included in the editor's undo/redo history.
</DD> <DT> <B>pointer{<I>type</I>}</B></DT><DD> Advanced.  This variable is a pointer to <I>type</I>.  (The <I>type</I> is optional). Note the syntax is: pointer varname{<I>type</I>}.
</DD> <DT> <B>init</B></DT><DD> Advanced.  This property should be exported to the header file as an FString or TArray, rather than an FStringNoInit or TArrayNoInit.  Only applicable to strings and dynamic arrays declared in native classes.  'Init' properties should not be given default values, as the default value will be cleared when the object is created. (See <A href="http://udn.epicgames.com/Three/StringsInUnrealScript.html" class="twikiLink">Unreal Strings</A> and <A href="https://udn.epicgames.com/Three/StringsInNativeCode" class="restricted">Native Strings</A>)
</DD></DL> 
<P> </P><DL>
<DT> <B>out</B></DT><DD> This specifier is only valid for function parameters.  See <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#FunctionDeclarations" class="twikiAnchorLink">Functions</A> for more details.
</DD> <DT> <B>coerce</B></DT><DD> This specifier is only valid for function parameters.  See <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#FunctionDeclarations" class="twikiAnchorLink">Functions</A> for more details.
</DD> <DT> <B>optional</B></DT><DD> This specifier is only valid for function parameters.  See <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#FunctionDeclarations" class="twikiAnchorLink">Functions</A> for more details.
</DD> <DT> <B>skip</B></DT><DD> This specifier is only valid for operator function parameters.  Only used for logical operators like &amp;&amp; and ||. Prevents evaluation if the outcome of an expression can already be determined. Example: FALSE &amp;&amp; ++b==10 (<A href="https://udn.epicgames.com/lists/showpost/php?list=unprog&id=1221" class="restricted">More details</A>).
</DD></DL> 
<P>
</P><H4><A name="Editability"></A> Editability </H4>
<P>
In UnrealScript, you can make an instance variable "editable", so that users can edit the variable's value in UnrealEd. This mechanism is responsible for the entire contents of the "Actor Properties" dialog in UnrealEd: everything you see there is simply an UnrealScript variable, which has been declared editable.
</P><P>
The syntax for declaring an editable variable is as follows:
</P><P>
</P><PRE>var() int MyInteger; // Declare an editable integer in the default
                     // category.

var(MyCategory) bool MyBool; // Declare an editable integer in
                             // "MyCategory".
</PRE>
<P>
You can also declare a variable as <CODE>editconst</CODE>, which means that the variable should be visible but <EM>not</EM> editable UnrealEd. Note that this only prevents the variable from being changed in the editor, not in script. If you want a variable that is truly <CODE>const</CODE> but still visible in the editor, you must declare it <CODE>const editconst</CODE>:
</P><P>
</P><PRE>// MyBool is visible but not editable in UnrealEd
var(MyCategory) editconst bool MyBool; 

// MyBool is visible but not editable in UnrealEd and 
// not changeable in script
var(MyCategory) const editconst bool MyBool; 

// MyBool is visible and can be set in UnrealEd but
// not changeable in script
var(MyCategory) const bool MyBool; 
</PRE>
<P>
</P><H3><A name="Arrays"></A> Arrays </H3>
<P>
Arrays are declared using the following syntax:
</P><P>
</P><PRE>var int MyArray[20]; // Declares an array of 20 ints.
</PRE>
<P>
UnrealScript supports only single-dimensional arrays, though you can simulate multidimensional arrays by carrying out the row/column math yourself. For information on Dynamic Arrays, see below in the <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#DynArray" class="twikiAnchorLink">Advanced Language Features</A> section.
</P><P>
</P><H3><A name="Structs"></A> Structs </H3>
<P>
An UnrealScript struct is a way of cramming a bunch of variables together into a new kind of super-variable called a struct. UnrealScript structs are much like C structs, in that they can contain variables, arrays, and other structs, but UnrealScript structs cannot contain functions.
</P><P>
You can declare a struct as follows:
</P><P>
</P><PRE>// A point or direction vector in 3D space.
struct Vector
{
   var float X;
   var float Y;
   var float Z;
};
</PRE>
<P>
Once you declare a struct, you are ready to start declaring specific variables of that struct type:
</P><P>
</P><PRE>// Declare a bunch of variables of type Vector.
var Vector Position;
var Vector Destination;
</PRE>
<P>
To access a component of a struct, use code like the following.
</P><P>
</P><PRE>function MyFunction()
{
   Local Vector A, B, C;
    
   // Add some vectors.
   C = A + B;
 
   // Add just the x components of the vectors.
   C.X = A.X + B.X;
 
   // Pass vector C to a function.
   SomeFunction( C );
 
   // Pass certain vector components to a function.
   OtherFunction( A.X, C.Z );
} 
</PRE>
<P>
You can do anything with Struct variables that you can do with other variables: you can assign variables to them, you can pass them to functions, and you can access their components.
</P><P>
There are several Structs defined in the Object class, which are used throughout Unreal. You should become familiar with their operation, as they are fundamental building blocks of scripts: 
</P><P> </P><DL>
<DT> <B>Vector</B></DT><DD> A unique 3D point or vector in space, with an X, Y, and Z component. 
</DD> <DT> <B>Plane</B></DT><DD> Defines a unique plane in 3D space. A plane is defined by its X, Y, and Z components (which are assumed to be normalized) plus its W component, which represents the distance of the plane from the origin, along the plane's normal (which is the shortest line from the plane to the origin). 
</DD> <DT> <B>Rotator</B></DT><DD> A rotation defining a unique orthogonal coordinate system. A rotator contains Pitch, Yaw, and Roll components. 
</DD> <DT> <B>Coords</B></DT><DD> An arbitrary coordinate system in 3D space. 
</DD> <DT> <B>Color</B></DT><DD> An RGB color value. 
</DD> <DT> <B>Region</B></DT><DD> Defines a unique convex region within a level.
</DD></DL> 
<P>
</P><H4><A name="Struct specifiers"></A> Struct specifiers </H4>
<P>
Structs may also have a few specifiers that affect all instances of the struct.
</P><P> </P><DL>
<DT> <B>atomic</B></DT><DD> Indicates that this struct should always be serialized as a single unit; if any property in the struct differs from its defaults, then all elements of the struct will be serialized.
</DD> <DT> <B>atomicwhencooked</B></DT><DD> applies the 'atomic' flag only when working with cooked package data.
</DD> <DT> <B>immutable</B></DT><DD> Indicates that this struct uses binary serialization (reduces disk space and improves serialization performance); it is unsafe to add/remove members from this struct without incrementing the package version. 
</DD> <DT> <B>immutablewhencooked</B></DT><DD> applies the 'immutable' flag only when working with cooked package data.
</DD> <DT> <B>strictconfig</B></DT><DD> Indicates that when the struct property has 'config/globalconfig', only properties marked config/globalconfig within this struct can be read from .ini (without this flag, all properties in the struct are configurable if the property is)
</DD></DL> 
<P>
</P><H3><A name="Enumerations"></A> Enumerations </H3>
<P>
Enumerations exist in UnrealScript as a convenient way to declare variables that can contain "one of" a bunch of keywords. For example, the actor class contains the enumeration <CODE>EPhysics</CODE>, which describes the physics which Unreal should apply to the actor. This can be set to one of the predefined values like <CODE>PHYS_None</CODE>, <CODE>PHYS_Walking</CODE>, <CODE>PHYS_Falling</CODE>, and so on.
</P><P>
Internally, enumerations are stored as byte variables. In designing UnrealScript, enumerations were not seen as a necessity, but it makes code so much easier to read to see that an actor's physics mode is being set to <CODE>PHYS_Swimming</CODE> than (for example) <CODE>3</CODE>.
</P><P>
Here is sample code that declares enumerations.
</P><P>
</P><PRE>// Declare the EColor enumeration, with three values.
enum EColor
{
   CO_Red,
   CO_Green,
   CO_Blue
};
 
// Now, declare two variables of type EColor.
var EColor ShirtColor, HatColor;
 
// Alternatively, you can declare variables and
// enumerations together like this:
var enum EFruit
{
   FRUIT_Apple,
   FRUIT_Orange,
   FRUIT_Bannana
} FirstFruit, SecondFruit;
</PRE>
<P>
In the Unreal source, we always declare enumeration values like <CODE>LT_Steady</CODE>, <CODE>PHYS_Falling</CODE>, and so on, rather than as simply "Steady" or "Falling".  This is just a matter of programming style, and is not a requirement of the language.
</P><P>
UnrealScript only recognizes unqualified enum tags (like <CODE>FRUIT_Apple</CODE>) in classes where the enumeration was defined, and in its subclasses.  If you need to refer to an enumeration tag defined somewhere else in the class hierarchy, you must "qualify it":
</P><P>
</P><PRE>FRUIT_Apple         // If Unreal can't find this enum tag...
EFruit.FRUIT_Apple  // Then qualify it like this.
</PRE>
<P>
</P><H3><A name="Constants"></A> Constants </H3>
<P>
In UnrealScript, you can specify constant literal values for nearly all data types: 
</P><P> </P><UL>
<LI> Integer and byte constants are specified with simple numbers, for example: <CODE>123</CODE>.  If you must specify an integer or byte constant in hexadecimal format, use i.e.: <CODE>0x123</CODE> 
</LI> <LI> Floating point constants are specified with decimal numbers like: <CODE>456.789</CODE>
</LI> <LI> String constants must be enclosed in double quotes, for example: <CODE>"MyString"</CODE> 
</LI> <LI> Name constants must be enclosed in single quotes, for example <CODE>'MyName'</CODE> 
</LI> <LI> Vector constants contain X, Y, and Z values like this: <CODE>vect(1.0,2.0,4.0)</CODE> 
</LI> <LI> Rotator constants contain Pitch, Yaw, and Roll values like this: <CODE>Rot(0x8000,0x4000,0)</CODE> 
</LI> <LI> The <CODE>None</CODE> constant refers to "no object" (or equivalently, "no actor"). 
</LI> <LI> The <CODE>Self</CODE> constant refers to "this object" (or equivalently, "this actor"), i.e. the object whose script is executing. 
</LI> <LI> General object constants are specified by the object type followed by the object name in single quotes, for example: <CODE>texture'Default'</CODE> 
</LI> <LI> <CODE>EnumCount</CODE> gives you the number of elements in an enumeration, for example: <CODE>ELightType.EnumCount</CODE> 
</LI> <LI> <CODE>ArrayCount</CODE> gives you the number of elements in an static array, for example: <CODE>ArrayCount(Touching)</CODE>
</LI></UL> 
<P>
You can use the "const" keyword to declare constants that you can later refer to by name.  For example:
</P><P>
</P><PRE>const LargeNumber=123456;
const PI=3.14159;
const MyName="Tim";
const Northeast=Vect(1.0,1.0,0.0);
</PRE>
<P>
Constants can be defined within classes or within structs.
</P><P>
To access a constant which was declared in another class, use the "class'classname'.const.constname" syntax, for example:
</P><P>
</P><PRE>class'Pawn'.const.LargeNumber
</PRE>
<P>
<A name="ObjectRefs"></A>
</P><H3><A name="Object and actor reference variables"></A> Object and actor reference variables </H3>
<P>
You can declare a variable that refers to an actor or object like this:
</P><P>
</P><PRE>var actor A; // An actor reference.
var pawn P; // A reference to an actor in the Pawn class.
var texture T; // A reference to a texture object.
</PRE>
<P>
The variable "P" above is a reference to an actor in the Pawn class. Such a variable can refer to any actor that belongs to a subclass of Pawn. For example, P might refer to a Brute, or a Skaarj, or a Manta. It can be any kind of Pawn. However, P can never refer to a Trigger actor (because Trigger is not a subclass of Pawn).
</P><P>
One example of where it's handy to have a variable referring to an actor is the Enemy variable in the Pawn class, which refers to the actor that the Pawn is trying to attack.
</P><P>
When you have a variable that refers to an actor, you can access that actor's variables, and call its functions. For example:
</P><P>
</P><PRE>// Declare two variables that refer to a pawns.
var pawn P, Q;
 
// Here is a function that makes use of P.
// It displays some information about P.
function MyFunction()
{
   // Set P's enemy to Q.
   P.Enemy = Q;
 
   // Tell P to play his running animation.
   P.PlayRunning();
}
</PRE>
<P>
Variables that refer to actors always either refer to a valid actor (any actor that actually exists in the level), or they contain the value <CODE>None</CODE>. None is equivalent to the C/C++ <CODE>NULL</CODE> pointer. However, in UnrealScript, it is safe to access variables and call functions with a <CODE>None</CODE> reference; the result is always zero.
</P><P>
Note that an object or actor reference "points to" another actor or object, it doesn't "contain" an actor or object. The C equivalent of an actor reference is a pointer to an object in the AActor class (in C, you'd say an AActor*). For example, you could have two monsters in the world, Bob and Fred, who are fighting each other. Bob's "Enemy" variable would "point to" Fred, and Fred's "Enemy" variable would "point to" Bob.
</P><P>
Unlike C pointers, UnrealScript object references are always safe and infallible. It is impossible for an object reference to refer to an object that doesn't exist or is invalid (other than the special-case <CODE>None</CODE> value). In UnrealScript, when an actor is destroyed, all references to it are automatically set to <CODE>None</CODE>.
</P><P>
</P><H3><A name="Class Reference Variables"></A> Class Reference Variables </H3>
<P>
In Unreal, classes are objects just like actors, textures, and sounds are objects.  Class objects belong to the class named "class".  Now, there will often be cases where you'll want to store a reference to a class object, so that you can spawn an actor belonging to that class (without knowing what the class is at compile-time).  For example:
</P><P>
</P><PRE>var() class C;
var actor A;
A = Spawn( C ); // Spawn an actor belonging to some arbitrary class C.
</PRE>
<P>
Now, be sure not to confuse the roles of a class C, and an object O belonging to class C (referred to as an "instance" of class C).  To give a really shaky analogy, a class is like a pepper grinder, and an instance of that class is like pepper.  You can use the pepper grinder (the class) to create pepper (objects of that class) by turning the crank (calling the Spawn function)...BUT, a pepper grinder (a class) is not pepper (an object belonging to the class), so you MUST NOT TRY TO EAT IT!
</P><P>
When declaring variables that reference class objects, you can optionally use the syntax <STRONG>class&lt;metaclass&gt;</STRONG> to limit the classes that can be referenced by the variable to classes of type <EM>metaclass</EM> (and its child classes).  For example, in the declaration:
</P><P>
</P><PRE>var class&lt;actor&gt; ActorClass;
</PRE>
<P>
The variable ActorClass may only reference a class that extends the "actor" class.  This is useful for improving compile-time type checking. For example, the Spawn function takes a class as a parameter, but only makes sense when the given class is a subclass of Actor, and the class&lt;classlimitor&gt; syntax causes the compiler to enforce that requirement.
</P><P>
As with dynamic object casting, you can dynamically cast classes like this:
</P><P>
</P><PRE>// casts the result of SomeFunctionCall() a class of type Actor (or subclasses of Actor)
class&lt;actor&gt;( SomeFunctionCall() )
</PRE>
<P>
</P><P>
</P><H2><A name="Expressions"></A> Expressions </H2>
<P>
</P><H3><A name="Assignment"></A> Assignment </H3>
<P>
To assign a value to a variable, use "=" like this:
</P><P>
</P><PRE>function Test()
{
   local int i;
   local string s;
   local vector v, q;
 
   i = 10;       // Assign a value to integer variable i.
   s = "Hello!"; // Assign a value to string variable s.
   v = q;        // Copy value of vector q to v.
}
</PRE>
<P>
In UnrealScript, whenever a function or other expression requires a certain type of data (for example, a "float"), and you specify a different type of data (for example, an "int), the compiler will try to automatically convert the value you give to the proper type. Conversions among all the numerical data types (byte, int, and float) happen automatically, without any work on your part.
</P><P>
UnrealScript is also able to convert many other built-in data types to other types, if you explicitly convert them in code. The syntax for this is:
</P><P>
</P><PRE>function Test()
{
   local int i;
   local string s;
   local vector v, q;
   local rotator r;
 
   s = string(i);     // Convert integer i to a string, and assign it to s.
   s = string(v);     // Convert vector v to a string, and assign it to s.
   v = q + vector(r); // Convert rotator r to a vector, and add q.
}
</PRE>
<P>
Here is the complete set of non-automatic conversions you can use in UnrealScript: 
</P><P> </P><UL>
<LI> String to Byte, Int, Float: Tries to convert a string like <CODE>"123"</CODE> to a value like <CODE>123</CODE>. If the string doesn't represent a value, the result is <CODE>0</CODE>. 
</LI> <LI> Byte, Int, Float, Vector, Rotator to String: Converts the number to its textual representation. 
</LI> <LI> String to Vector, Rotator: Tries to parse the vector or rotator's textual representation. 
</LI> <LI> String to Bool: Converts the case-insensitive words <CODE>"True"</CODE> or <CODE>"False"</CODE> to <CODE>True</CODE> and <CODE>False</CODE>; converts any non-zero value to <CODE>True</CODE>; everything else is <CODE>False</CODE>. 
</LI> <LI> Bool to String: Result is either <CODE>"True"</CODE> or <CODE>"False"</CODE>. 
</LI> <LI> Byte, Int, Float, Vector, Rotator to Bool: Converts nonzero values to <CODE>True</CODE>; zero values to <CODE>False</CODE>. 
</LI> <LI> Bool to Byte, Int, Float: Converts <CODE>True</CODE> to <CODE>1</CODE>; <CODE>False</CODE> to <CODE>0</CODE>. 
</LI> <LI> Name to String: Converts the name to the text equivalent. 
</LI> <LI> Rotator to Vector: Returns a vector facing "forward" according to the rotator. 
</LI> <LI> Vector to Rotator: Returns a rotator pitching and yawing in the direction of the vector; roll is zero. 
</LI> <LI> Object (or Actor) to Int: Returns an integer that is guaranteed unique for that object. 
</LI> <LI> Object (or Actor) to Bool: Returns <CODE>False</CODE> if the object is <CODE>None</CODE>; <CODE>True</CODE> otherwise. 
</LI> <LI> Object (or Actor) to String: Returns a textual representation of the object.
</LI></UL> 
<P>
</P><H3><A name="Converting object references among classes"></A> Converting object references among classes </H3>
<P>
Just like the conversion functions above, which convert among simple data types, in UnrealScript you can convert actor and object references among various types. For example, all actors have a variable named "Target", which is a reference to another actor. Say you are writing a script where you need to check and see if your Target belongs to the "Pawn" actor class, and you need to do something special with your target that only makes sense when it's a pawn -- for example, you need to call one of the Pawn functions. The actor cast operators let you do this. Here's an example:
</P><P>
</P><PRE>var actor Target;
//...
 
function TestActorConversions()
{
   local Pawn P;
 
   // Cast Target to Pawn and assign the result to P.  If Target is not a Pawn (or subclass of Pawn), then the value assigned to P will be None.
   P = Pawn(Target);
   if( P != None )
   {
      // Target is a pawn, so set its Enemy to Self.
      P.Enemy = Self;
   }
   else
   {
      // Target is not a pawn.
   }
}
</PRE>
<P>
To perform an actor conversion, type the class name followed by the actor expression you wish to convert, in parenthesis. Such conversions will either succeed or fail based on whether the conversion is sensible. In the above example, if your Target is referencing a Trigger object rather than a pawn, the expression Pawn(Target) will return "None", since a Trigger can't be converted to a Pawn. However, if your Target is referencing a Brute object, the conversion will successfully return the Brute, because Brute is a subclass of Pawn.
</P><P>
Thus, actor conversions have two purposes: First, you can use them to see if a certain actor reference belongs to a certain class. Second, you can use them to convert an actor reference from one class to a more specific class. Note that these conversions don't affect the actor you're converting at all -- they just enable UnrealScript to treat the actor reference as if it were a more specific type and allow you access the properties and methods declared in the more derived class.
</P><P>
Another example of conversions lies in the Inventory script. Each Inventory actor is owned by a Pawn, even though its Owner variable can refer to any Actor (because Actor.Owner is a variable of type Actor). So a common theme in the Inventory code is to cast Owner to a Pawn, for example:
</P><P>
</P><PRE>// Called by engine when destroyed.
function Destroyed()
{
    // Remove from owner's inventory.
    if( Pawn(Owner)!=None )
        Pawn(Owner).DeleteInventory( Self );
} 
</PRE>
<P>
</P><P>
</P><H2><A name="Functions"></A> Functions </H2>
<P>
<A name="FunctionDeclarations"></A>
</P><H3><A name="Declaring Functions"></A> Declaring Functions </H3>
<P>
In UnrealScript, you can declare new functions and write new versions of existing functions (overwrite functions). Functions can take one or more parameters (of any variable type UnrealScript supports), and can optionally return a value. Though most functions are written directly in UnrealScript, you can also declare functions that can be called from UnrealScript, but which are implemented in C++ and reside in a DLL. The Unreal technology supports all possible combinations of function calling: The C++ engine can call script functions; script can call C++ functions; and script can call script.
</P><P>
Here is a simple function declaration. This function takes a vector as a parameter, and returns a floating point number:
</P><P>
</P><PRE>// Function to compute the size of a vector.
function float VectorSize( vector V )
{
   return sqrt( V.X * V.X + V.Y * V.Y + V.Z * V.Z );
}
</PRE>
<P>
The word <CODE>function</CODE> always precedes a function declaration. It is followed by the optional return type of the function (in this case, <CODE>float</CODE>), then the function name, and then the list of function parameters enclosed in parenthesis.
</P><P>
When a function is called, the code within the brackets is executed. Inside the function, you can declare local variables (using the <CODE>local</CODE> keyword), and execute any UnrealScript code. The optional <CODE>return</CODE> keyword causes the function to immediately return a value.
</P><P>
You can pass any UnrealScript types to a function (including arrays), and a function can return any type.
</P><P>
By default, any local variables you declare in a function are initialized to zero.
</P><P>
Function calls can be recursive. For example, the following function computes the factorial of a number:
</P><P>
</P><PRE>// Function to compute the factorial of a number.
function int Factorial( int Number )
{
   if( Number &lt;= 0 )
      return 1;
   else
      return Number * Factorial( Number - 1 );
}
</PRE>
<P>
Some UnrealScript functions are called by the engine whenever certain events occur. For example, when an actor is touched by another actor, the engine calls its <EM>Touch</EM> function to tell it who is touching it. By writing a custom <EM>Touch</EM> function, you can take special actions as a result of the touch occurring:
</P><P>
</P><PRE>// Called when something touches this actor.
function Touch( actor Other )
{
   Log( "I was touched!")
   Other.Message( "You touched me!" );
}
</PRE>
<P>
The above function illustrates several things. First of all, the function writes a message to the log file using the <EM>Log</EM> command (which is the equivalent of Basic's "print" command and C's "printf", with the exception on formatting rules). Second, it calls the "Message" function residing in the actor Other. Calling functions in other actors is a common action in UnrealScript, and in object-oriented languages like Java in general, because it provides a simple means for actors to communicate with each other.
</P><P>
</P><H3><A name="Function parameter specifiers"></A> Function parameter specifiers </H3>
<P>
When you normally call a function, UnrealScript makes a local copy of the parameters you pass the function. If the function modifies some of the parameters, those don't have any effect on the variables you passed in. For example, the following program:
</P><P>
</P><PRE>function int DoSomething( int x )
{
   x = x * 2;
   return x;
}
function int DoSomethingElse()
{
   local int a, b;
 
   a = 2;
   log( "The value of a is " $ a );
 
   b = DoSomething( a );
   log( "The value of a is " $ a );
   log( "The value of b is " $ b );
}
</PRE>
<P>
Produces the following output when DoSomethingElse is called:
</P><P>
</P><PRE>The value of a is 2
The value of a is 2
The value of b is 4
</PRE>
<P>
In other words, the function DoSomething was futzing with a local copy of the variable "a" which was passed to it, and it was not affecting the real variable "a".
</P><P>
The <CODE>out</CODE> specifier lets you tell a function that it should actually modify the variable that is passed to it, rather than making a local copy. This is useful, for example, if you have a function that needs to return several values to the caller. You can juse have the caller pass several variables to the function which are <CODE>out</CODE> values. For example:
</P><P>
</P><PRE>// Compute the minimum and maximum components of a vector.
function VectorRange( vector V, out float Min, out float Max )
{
   // Compute the minimum value.
   if ( V.X&lt;V.Y &amp;amp;&amp;amp; V.X&lt;V.Z ) Min = V.X;
   else if( V.Y&lt;V.Z ) Min = V.Y;
   else Min = V.Z;
 
   // Compute the maximum value.
   if ( V.X&gt;V.Y &amp;amp;&amp;amp; V.X&gt;V.Z ) Max = V.X;
   else if( V.Y&gt;V.Z ) Max = V.Y;
   else Max = V.Z;
}
</PRE>
<P>
Without the <CODE>out</CODE> keyword, it would be painful to try to write functions that had to return more than one value. Out parameters are passed by reference so modifying the parameter's value in the function will immediately affect the original. This can also be used as an optimization for large values, similiarly to C++, by specifying "const out".
</P><P>
<A name="DefFuncArgs"></A>
With the <CODE>optional</CODE> keyword, you can make certain function parameters optional, as a convenience to the caller. For UnrealScript functions, optional parameters which the caller doesn't specify are set to the default value given in the function declaration, or zero (e.g. 0, false, "", none) if no value was specified in the function signature. For native functions, the default values of optional parameters depends on the function. For example, the Spawn function takes an optional location and rotation, which default to the spawning actor's location and rotation. The default value of optional arguments can be specified by adding <CODE>= value</CODE>. For example <CODE>function myFunc(optional int x = -1)</CODE>. 
</P><P>
The <CODE>coerce</CODE> keyword forces the caller's parameters to be converted to the specified type (even if UnrealScript normally would not perform the conversion automatically). This is useful for functions that deal with strings, so that the parameters are automatically converted to strings for you. (See <A href="http://udn.epicgames.com/Three/StringsInUnrealScript.html" class="twikiLink">Unreal Strings</A>)
</P><P>
</P><H3><A name="Function overriding"></A> Function overriding </H3>
<P>
"Function overriding" refers to writing a new version of a function in a subclass. For example, say you're writing a script for a new kind of monster called a Demon. The Demon class, which you just created, extends the Pawn class. Now, when a pawn sees a player for the first time, the pawn's "SeePlayer" function is called, so that the pawn can start attacking the player. This is a nice concept, but say you wanted to handle "SeePlayer" differently in your new Demon class. How do you do this? Function overriding is the answer.
</P><P>
To override a function, just cut and paste the function definition from the parent class into your new class. For example, for SeePlayer, you could add this to your Demon class.
</P><P>
</P><PRE>// New Demon class version of the Touch function.
function SeePlayer( actor SeenPlayer )
{
   log( "The demon saw a player" );
   // Add new custom functionality here...
}
</PRE>
<P>
Function overriding is the key to creating new UnrealScript classes efficiently. You can create a new class that extends an existing class. Then, all you need to do is override the functions that you want to be handled differently. This enables you to create new kinds of objects without writing gigantic amounts of code.
</P><P>
Several functions in UnrealScript are declared as <CODE>final</CODE>. The <CODE>final</CODE> keyword (which appears immediately before the word <CODE>function</CODE>) says "this function cannot be overridden by child classes". This should be used in functions that you know nobody would want to override, because it results in faster script code. For example, say you have a <EM>VectorSize</EM> function that computes the size of a vector. There's absolutely no reason anyone would ever override that, so declare it as <CODE>final</CODE>. On the other hand, a function like <EM>Touch</EM> is very context-dependent and should not be final.
</P><P>
<A name="AdvancedFunctionSpecifiers"></A>
</P><H3><A name="Advanced function specifiers"></A> Advanced function specifiers </H3>
<P> </P><DL>
<DT> <B>Static</B></DT><DD> A static function acts like a C global function, in that it can be called without having a reference to an object of the class.  Static functions can call other static functions, and can access the default values of variables. Static functions cannot call non-static functions and they cannot access instance variables (since they are not executed with respect to an instance of an object). Unlike languages like C++, static functions are virtual and can be overridden in child classes. This is useful in cases where you wish to call a static function in a variable class (a class not known at compile time, but referred to by a variable or an expression).
</DD></DL> 
<P> </P><DL>
<DT> <B>Singular</B></DT><DD> The <CODE>singular</CODE> keyword, which appears immediately before a function declaration, prevents a function from calling itself recursively. The rule is this: If a certain actor is already in the middle of a singular function, any subsequent calls to singular functions will be skipped over. This is useful in avoiding infinite-recursive bugs in some cases. For example, if you try to move an actor inside of your <EM>Bump</EM> function, there is a good chance that the actor will bump into another actor during its move, resulting in another call to the <EM>Bump</EM> function, and so on. You should be very careful in avoiding such behavior, but if you can't write code with complete confidence that you're avoiding such potential recursive situations, use the <CODE>singular</CODE> keyword.
</DD></DL> 
<P> </P><DL>
<DT> <B>Native</B></DT><DD> You can declare UnrealScript functions as <CODE>native</CODE>, which means that the function is callable from UnrealScript, but is actually implemented (elsewhere) in C++. For example, the Actor class contains a lot of native function definitions, such as:
</DD></DL> 
<P>
</P><PRE>native(266) final function bool Move( vector Delta );
</PRE>
<P>
   The number inside the parenthesis after the <CODE>native</CODE> keyword corresponds to the number of the function as it was declared in C++ (using the <CODE>AUTOREGISTER_NATIVE</CODE> macro), and is only required for operator functions. The native function is expected to reside in the DLL named identically to the package of the class containing the UnrealScript definition. 
</P><P> </P><DL>
<DT> <B>NoExport</B></DT><DD> Only used for native functions. Declares that the C++ function declaration for this native function should not be exported.  Only the declaration for the glue version of the function will be exported.
</DD></DL> 
<P> </P><DL>
<DT> <B>Exec</B></DT><DD> Indicates that this function can be executed by typing the name of the function into the console.  Only valid in certain classes.
</DD></DL> 
<P> </P><DL>
<DT> <B>Latent</B></DT><DD> Declares that a native function is latent, meaning that it can only be called from state code, and it may return after some game-time has passed.
</DD></DL> 
<P> </P><DL>
<DT> <B>Iterator</B></DT><DD> Declares that a native function is an iterator, which can be used to loop through a list of actors using the <CODE>foreach</CODE> command.
</DD></DL> 
<P> </P><DL>
<DT> <B>Simulated</B></DT><DD> Declares that a function may execute on the client-side when an actor is either a simulated proxy or an autonomous proxy. All functions that are both native and final are automatically simulated as well.
</DD></DL> 
<P> </P><DL>
<DT> <B>Server</B></DT><DD> Declares that a function should be sent to the server for execution instead of running on the local client.
</DD></DL> 
<P> </P><DL>
<DT> <B>Client</B></DT><DD> Declares that a function should be sent to the owning client for execution instead of running on the server.  This flag also implicitly sets the <B>simulated</B> flag for the function.
</DD></DL> 
<P> </P><DL>
<DT> <B>Reliable</B></DT><DD> Declares that a replicated function (marked with either <B>server</B> or <B>client</B>) should be reliably sent, meaning it will always eventually reach the other end in order relative to other replication on that Actor.
</DD></DL> 
<P> </P><DL>
<DT> <B>Unreliable</B></DT><DD> Declares that a replicated function (marked with either <B>server</B> or <B>client</B>) should be unreliably sent, meaning that it is not guaranteed to reach the other end in any particular order or at all and may be skipped completely if there is insufficient bandwidth available.
</DD></DL> 
<P> </P><DL>
<DT> <B>Private,&nbsp;Protected</B></DT><DD> These keywords have the same meaning as the corresponding variable keywords.
</DD></DL> 
<P> </P><DL>
<DT> <B>Operator,&nbsp;PreOperator,&nbsp;PostOperator</B></DT><DD> These keywords are for declaring a special kind of function called an operator (equivalent to C++ operators). This is how UnrealScript knows about all of the built-in operators like "+", "-", "==", and "||". I'm not going into detail on how operators work in this document, but the concept of operators is similar to C++, and you can declare new operator functions and keywords as UnrealScript functions or native functions.
</DD></DL> 
<P> </P><DL>
<DT> <B>Event</B></DT><DD> The <CODE>event</CODE> keyword has the same meaning to UnrealScript as <CODE>function". However, when you export a C++ header file from Unreal using =unreal -make -h</CODE>, UnrealEd automatically generates a C++ -&gt; UnrealScript calling stub for each "event".  This automatically keeps C++ code synched up with UnrealScript functions and eliminates the possibility of passing invalid parameters to an UnrealScript function. For example, this bit of UnrealScript code:
</DD></DL> 
<P>
</P><PRE>event Touch( Actor Other )
{ ... }
</PRE>
<P>
Generates code similar to the following in EngineClasses.h:
</P><P>
</P><PRE>void eventTouch(class AActor* Other)
{
    FName N("Touch",FNAME_Intrinsic);
    struct {class AActor* Other; } Parms;
    Parms.Other=Other;
    ProcessEvent(N, &amp;Parms);
}
</PRE>
<P>
Thus enabling you to call the UnrealScript function from C++ like this:
</P><P>
</P><PRE>AActor *SomeActor, *OtherActor;
SomeActor-&gt;eventTouch(OtherActor);
</PRE>
<P> </P><DL>
<DT> <B>Const</B></DT><DD> Can only be used with native declared function and this specifier is added <EM>after</EM> the function declaration. This specifier will determine whether this function should be exported as 'const' in the generated header. Example usage:
</DD></DL> 
<PRE>native function int doSomething(string myData) const;
</PRE>
<P>
</P><P>
</P><H2><A name="Control Structures"></A> Control Structures </H2>
<P>
UnrealScript supports all the standard flow-control statements of C/C++/Java: 
</P><P>
</P><H3><A name="Repetition Structures"></A> Repetition Structures </H3>
<P>
<A name="ForLoops"></A>
</P><H4><A name="For Loops"></A> For Loops </H4>
<P>
"For" loops let you cycle through a loop as long as some condition is met. For example:
</P><P>
</P><PRE>// Example of "for" loop.
function ForExample()
{
   local int i;
   log( "Demonstrating the for loop" );
   for( i=0; i&lt;4; i++ )
   {
      log( "The value of i is " $ i );
   }
   log( "Completed with i=" $ i);
}
</PRE>
<P>
The output of this loop is:
</P><P>
</P><PRE>Demonstrating the for loop
The value of i is 0
The value of i is 1
The value of i is 2
The value of i is 3
Completed with i=4
</PRE>
<P>
In a for loop, you must specify three expressions separated by semicolons. The first expression is for initializing a variable to its starting value. The second expression gives a condition which is checked before each iteration of the loop executes; if this expression is true, the loop executes. If it's false, the loop terminates. The third condition gives an expression which increments the loop counter.
</P><P>
Though most "for" loop expressions just update a counter, you can also use "for" loops for more advanced things like traversing linked lists, by using the appropriate initialization, termination, and increment expressions.
</P><P>
In all of the flow control statements, you can either execute a single statement, without brackets, as follows:
</P><P>
</P><PRE>for( i=0; i&lt;4; i++ )
   log( "The value of i is " $ i );
</PRE>
<P>
Or you can execute multiple statements, surrounded by brackets, like this: 
</P><P>
</P><PRE>for( i=0; i&lt;4; i++ )
{
   log( "The value of i is" );
   log( i );
}
</PRE>
<P>
<A name="DoLoops"></A>
</P><H4><A name="Do Loops"></A> Do Loops </H4>
<P>
"Do" loops let you cycle through a loop while some ending expression is true.  Note that Unreal uses <CODE>do-until</CODE> syntax, which differs from C/Java (which use <CODE>do-while</CODE>).
</P><P>
</P><PRE>// Example of "do" loop.
function DoExample()
{
   local int i;
   log( "Demonstrating the do loop" );
   do
   {
      log( "The value of i is " $ i );
      i = i + 1;
   } until( i == 4 );
   log( "Completed with i=" $ i);
}
</PRE>
<P>
The output of this loop is:
</P><P>
</P><PRE>Demonstrating the do loop
The value of i is 0
The value of i is 1
The value of i is 2
The value of i is 3
Completed with i=4
</PRE>
<P>
<A name="WhileLoops"></A>
</P><H4><A name="While Loops"></A> While Loops </H4>
<P>
"While" loops let you cycle through a loop while some starting expression is true.
</P><P>
</P><PRE>// Example of "while" loop.
function WhileExample()
{
   local int i;
   log( "Demonstrating the while loop" );
   while( i &lt; 4 )
   {

      log( "The value of i is " $ i );
      i = i + 1;
   }
   log( "Completed with i=" $ i);
}
</PRE>
<P>
The output of this loop is:
</P><P>
</P><PRE>Demonstrating the do loop
The value of i is 0
The value of i is 1
The value of i is 2
The value of i is 3
Completed with i=4
</PRE>
<P>
<A name="ContinueStatements"></A>
</P><H4><A name="Continue"></A> Continue </H4>
<P>
The "continue" command will jump back to the beginning of the loop, so everything after the continue command isn't executed. This can be used to skip the loop code in certain cases.
</P><P>
</P><PRE>function ContinueExample()
{
   local int i;
   log( "Demonstrating continue" );
   for( i=0; i&lt;4; i++ )
   {
      if( i == 2 )
         continue;
      log( "The value of i is " $ i );
   }
   log( "Completed with i=" $ i );
}
</PRE>
<P>
The output of this loop is:
</P><P>
</P><PRE>Demonstrating break
The value of i is 0
The value of i is 1
The value of i is 3
Completed with i=4
</PRE>
<P>
<A name="BreakStatements"></A>
</P><H4><A name="Break"></A> Break </H4>
<P>
The "break" command exits out of the nearest loop ("For", "Do", or "While").
</P><P>
</P><PRE>function BreakExample()
{
   local int i;
   log( "Demonstrating break" );
   for( i=0; i&lt;10; i++ )
   {
      if( i == 3 )
         break;
      log( "The value of i is " $ i );
   }
   log( "Completed with i=" $ i );
}
</PRE>
<P>
The output of this loop is:
</P><P>
</P><PRE>Demonstrating break
The value of i is 0
The value of i is 1
The value of i is 2
Completed with i=3
</PRE>
<P>
Note that the "break" command can also be used to skip the remainder of a conditional statement("switch").
</P><P>
</P><H3><A name="Selection Structures"></A> Selection Structures </H3>
<P>
</P><H4><A name="If-Then-Else Statements"></A> If-Then-Else Statements </H4>
"If", "Else If", and "Else" let you execute code if certain conditions are met.
<P>
</P><PRE>// Example of simple "if".
if( LightBrightness &lt; 20 )
   log( "My light is dim" );
 
// Example of "if-else".
if( LightBrightness &lt; 20 )
   log( "My light is dim" );
else
   log( "My light is bright" );
 
// Example if "if-else if-else".
if( LightBrightness &lt; 20 )
   log( "My light is dim" );
else if( LightBrightness &lt; 40 )
   log( "My light is medium" );
else if( LightBrightness &lt; 60 )
   log( "My light is kinda bright" );
else
   log( "My light is very bright" );
 
// Example if "if" with brackets.
if( LightType == LT_Steady )
{
   log( "Light is steady" );
}
else
{
   log( "Light is not steady" );
}
</PRE>
<P>
</P><H4><A name="Case Statements"></A> Case Statements </H4>
<P>
"Switch", "Case", "Default", and "Break" let you handle lists of conditions easily.
</P><P>
</P><PRE>// Example of switch-case.
function TestSwitch()
{
   // Executed one of the case statements below, based on
   // the value in LightType.
   switch( LightType )
   {
      case LT_None:
         log( "There is no lighting" );
         break;
      case LT_Steady:
         log( "There is steady lighting" );
         break;
      case LT_Backdrop:
         log( "There is backdrop lighting" );
         break;
      default:
         log( "There is dynamic" );
         break;
   }
}
</PRE>
<P>
A "switch" statement consists of one or more "case" statements, and an optional "default" statement. After a switch statement, execution goes to the matching "case" statement if there is one; otherwise execution goes to the "default" statement; otherwise execution continues past the end of the "select" statement.
</P><P>
After you write code following a "case" label, you must use a "break" statement to cause execution to go past the end of the "switch" statement. If you don't use a "break", execution "falls through" to the next "case" handler.
</P><P>
</P><PRE>// Example of switch-case.
function TestSwitch2()
{
   switch( LightType )
   {
      case LT_None:
         log( "There is no lighting" );
         break;
      case LT_Steady:   // will "fall though" to the LT_Backdrop case
      case LT_Backdrop:
         log( "There is lighting" );
         break;
      default:
         log( "Something else" );
         break;
   }
}
</PRE>
<P>
<A name="GotoStatements"></A>
</P><H4><A name="Goto"></A> Goto </H4>
<P>
The "Goto" command goes to a label somewhere in the current function or state.
</P><P>
</P><PRE>// Example of "goto".
function GotoExample()
{
   log( "Starting GotoExample" );
   goto Hither;
Yon:
   log( "At Yon" );
   goto Elsewhere;
Hither:
   log( "At Hither" );
   goto Yon;
Elsewhere:
   log( "At Elsewhere" );
}
</PRE>
<P>
The output is:
</P><P>
</P><PRE>Starting GotoExample
At Hither
At Yon
At Elsewhere
</PRE>
<P>
</P><P>
</P><H2><A name="Language Functionality"></A> Language Functionality </H2>
<P>
</P><H3><A name="Built-in operators and their precedence"></A> Built-in operators and their precedence </H3>
<P>
UnrealScript provides a wide variety of C/C++/Java-style operators for such operations as adding numbers together, comparing values, and incrementing variables. The complete set of operators is defined in Object.u, but here is a recap. Here are the standard operators, in order of precedence.  Note that all of the C style operators have the same precedence as they do in C.
</P><P>
</P><TABLE cellspacing="1" cellpadding="1" class="twikiTable" border="0"><TBODY><TR><TH bgcolor="#dadada" class="twikiFirstCol"> <A rel="nofollow" href="https://udn.epicgames.com/bin/publish/WebHome?webs=Main%2CTwo%2CThree%2CPowered&amp;inclusions=%2A&amp;exclusions=&amp;filter=&amp;inclfilter=%5C%25META%5C%3AFIELD%5C%7Bname%5C%3D%5C%22Documentavailability%5C%22.%2Avalue%5C%3D%5C%22General%20public%5C%22&amp;filterbymeta=yes&amp;skin=static_udn3&amp;restrictedclass=restricted&amp;format=&amp;sortcol=0;table=1;up=0#sorted_table" class="restricted" title="Sort by this column"><FONT color="#000000">Operator</FONT></A> </TH><TH bgcolor="#dadada"> <A rel="nofollow" href="https://udn.epicgames.com/bin/publish/WebHome?webs=Main%2CTwo%2CThree%2CPowered&amp;inclusions=%2A&amp;exclusions=&amp;filter=&amp;inclfilter=%5C%25META%5C%3AFIELD%5C%7Bname%5C%3D%5C%22Documentavailability%5C%22.%2Avalue%5C%3D%5C%22General%20public%5C%22&amp;filterbymeta=yes&amp;skin=static_udn3&amp;restrictedclass=restricted&amp;format=&amp;sortcol=1;table=1;up=0#sorted_table" class="restricted" title="Sort by this column"><FONT color="#000000">Types it applies to</FONT></A> </TH><TH bgcolor="#dadada"> <A rel="nofollow" href="https://udn.epicgames.com/bin/publish/WebHome?webs=Main%2CTwo%2CThree%2CPowered&amp;inclusions=%2A&amp;exclusions=&amp;filter=&amp;inclfilter=%5C%25META%5C%3AFIELD%5C%7Bname%5C%3D%5C%22Documentavailability%5C%22.%2Avalue%5C%3D%5C%22General%20public%5C%22&amp;filterbymeta=yes&amp;skin=static_udn3&amp;restrictedclass=restricted&amp;format=&amp;sortcol=2;table=1;up=0#sorted_table" class="restricted" title="Sort by this column"><FONT color="#000000">Meaning</FONT></A> </TH></TR>
<TR><TD bgcolor="#ffffff" align="center" class="twikiFirstCol"> @ </TD><TD bgcolor="#ffffff"> string </TD><TD bgcolor="#ffffff"> String concatenation, with an additional space between the two strings. "string1"@"string2" = "string1 string2" </TD></TR>
<TR><TD bgcolor="#eaeaea" align="center" class="twikiFirstCol"> @= </TD><TD bgcolor="#eaeaea"> string </TD><TD bgcolor="#eaeaea"> String concatenation, with an additional space between the two strings, concat and assign (v3323 and up) </TD></TR>
<TR><TD bgcolor="#ffffff" align="center" class="twikiFirstCol"> $ </TD><TD bgcolor="#ffffff"> string </TD><TD bgcolor="#ffffff"> String concatenation </TD></TR>
<TR><TD bgcolor="#eaeaea" align="center" class="twikiFirstCol"> $= </TD><TD bgcolor="#eaeaea"> string </TD><TD bgcolor="#eaeaea"> String concatenation, concat and assign (v3323 and up) </TD></TR>
<TR><TD bgcolor="#ffffff" align="center" class="twikiFirstCol"> *= </TD><TD bgcolor="#ffffff"> byte, int, float, vector, rotator </TD><TD bgcolor="#ffffff"> Multiply and assign </TD></TR>
<TR><TD bgcolor="#eaeaea" align="center" class="twikiFirstCol"> /= </TD><TD bgcolor="#eaeaea"> byte, int, float, vector, rotator </TD><TD bgcolor="#eaeaea"> Divide and assign </TD></TR>
<TR><TD bgcolor="#ffffff" align="center" class="twikiFirstCol"> += </TD><TD bgcolor="#ffffff"> byte, int, float, vector </TD><TD bgcolor="#ffffff"> Add and assign </TD></TR>
<TR><TD bgcolor="#eaeaea" align="center" class="twikiFirstCol"> -= </TD><TD bgcolor="#eaeaea"> byte, int, float, vector </TD><TD bgcolor="#eaeaea"> Subtract and assign </TD></TR>
<TR><TD bgcolor="#ffffff" align="center" class="twikiFirstCol"> || </TD><TD bgcolor="#ffffff"> bool </TD><TD bgcolor="#ffffff"> Logical or </TD></TR>
<TR><TD bgcolor="#eaeaea" align="center" class="twikiFirstCol"> &amp;&amp; </TD><TD bgcolor="#eaeaea"> bool </TD><TD bgcolor="#eaeaea"> Logical and </TD></TR>
<TR><TD bgcolor="#ffffff" align="center" class="twikiFirstCol"> ^^ </TD><TD bgcolor="#ffffff"> bool </TD><TD bgcolor="#ffffff"> Exclusive or </TD></TR>
<TR><TD bgcolor="#eaeaea" align="center" class="twikiFirstCol"> &amp; </TD><TD bgcolor="#eaeaea"> int </TD><TD bgcolor="#eaeaea"> Bitwise and </TD></TR>
<TR><TD bgcolor="#ffffff" align="center" class="twikiFirstCol"> | </TD><TD bgcolor="#ffffff"> int </TD><TD bgcolor="#ffffff"> Bitwise or </TD></TR>
<TR><TD bgcolor="#eaeaea" align="center" class="twikiFirstCol"> ^ </TD><TD bgcolor="#eaeaea"> int </TD><TD bgcolor="#eaeaea"> Bitwise exlusive or (XOR) </TD></TR>
<TR><TD bgcolor="#ffffff" align="center" class="twikiFirstCol"> != </TD><TD bgcolor="#ffffff"> All </TD><TD bgcolor="#ffffff"> Compare for inequality </TD></TR>
<TR><TD bgcolor="#eaeaea" align="center" class="twikiFirstCol"> == </TD><TD bgcolor="#eaeaea"> All </TD><TD bgcolor="#eaeaea"> Compare for equality </TD></TR>
<TR><TD bgcolor="#ffffff" align="center" class="twikiFirstCol"> &lt; </TD><TD bgcolor="#ffffff"> byte, int, float, string </TD><TD bgcolor="#ffffff"> Less than </TD></TR>
<TR><TD bgcolor="#eaeaea" align="center" class="twikiFirstCol"> &gt; </TD><TD bgcolor="#eaeaea"> byte, int, float, string </TD><TD bgcolor="#eaeaea"> Greater than </TD></TR>
<TR><TD bgcolor="#ffffff" align="center" class="twikiFirstCol"> &lt;= </TD><TD bgcolor="#ffffff"> byte, int, float, string </TD><TD bgcolor="#ffffff"> Less than or equal to </TD></TR>
<TR><TD bgcolor="#eaeaea" align="center" class="twikiFirstCol"> &gt;= </TD><TD bgcolor="#eaeaea"> byte, int, float, string </TD><TD bgcolor="#eaeaea"> Greater than or equal to </TD></TR>
<TR><TD bgcolor="#ffffff" align="center" class="twikiFirstCol"> ~= </TD><TD bgcolor="#ffffff"> float, string </TD><TD bgcolor="#ffffff"> Approximate equality (within 0.0001), case-insensitive equality. </TD></TR>
<TR><TD bgcolor="#eaeaea" align="center" class="twikiFirstCol"> &lt;&lt; </TD><TD bgcolor="#eaeaea"> int, vector </TD><TD bgcolor="#eaeaea"> Left shift (int), Forward vector transformation (vector) </TD></TR>
<TR><TD bgcolor="#ffffff" align="center" class="twikiFirstCol"> &gt;&gt; </TD><TD bgcolor="#ffffff"> int, vector </TD><TD bgcolor="#ffffff"> Right shift (int), Reverse vector transformation (vector) </TD></TR>
<TR><TD bgcolor="#eaeaea" align="center" class="twikiFirstCol"> &gt;&gt;&gt; </TD><TD bgcolor="#eaeaea"> &nbsp; </TD><TD bgcolor="#eaeaea"> same as &gt;&gt; </TD></TR>
<TR><TD bgcolor="#ffffff" align="center" class="twikiFirstCol"> + </TD><TD bgcolor="#ffffff"> byte, int, float, vector </TD><TD bgcolor="#ffffff"> Add </TD></TR>
<TR><TD bgcolor="#eaeaea" align="center" class="twikiFirstCol"> - </TD><TD bgcolor="#eaeaea"> byte, int, float, vector </TD><TD bgcolor="#eaeaea"> Subtract </TD></TR>
<TR><TD bgcolor="#ffffff" align="center" class="twikiFirstCol"> % </TD><TD bgcolor="#ffffff"> float, int, byte </TD><TD bgcolor="#ffffff"> Modulo (remainder after division) </TD></TR>
<TR><TD bgcolor="#eaeaea" align="center" class="twikiFirstCol"> * </TD><TD bgcolor="#eaeaea"> byte, int, float, vector, rotator </TD><TD bgcolor="#eaeaea"> Multiply </TD></TR>
<TR><TD bgcolor="#ffffff" align="center" class="twikiFirstCol"> / </TD><TD bgcolor="#ffffff"> byte, int, float, vector, rotator </TD><TD bgcolor="#ffffff"> Divide </TD></TR>
<TR><TD bgcolor="#eaeaea" align="center" class="twikiFirstCol"> Dot </TD><TD bgcolor="#eaeaea"> vector </TD><TD bgcolor="#eaeaea"> Vector dot product </TD></TR>
<TR><TD bgcolor="#ffffff" align="center" class="twikiFirstCol"> Cross </TD><TD bgcolor="#ffffff"> vector </TD><TD bgcolor="#ffffff"> Vector cross product </TD></TR>
<TR><TD bgcolor="#eaeaea" align="center" class="twikiFirstCol"> <PRE>**</PRE> </TD><TD bgcolor="#eaeaea"> float </TD><TD bgcolor="#eaeaea"> Exponentiation </TD></TR>
<TR><TD bgcolor="#ffffff" class="twikiFirstCol"> <BR>ClockwiseFrom </TD><TD bgcolor="#ffffff"> int (rotator elements) </TD><TD bgcolor="#ffffff"> returns true when the 1st is clockwise from the 2nd argument </TD></TR>
</TBODY></TABLE>
<P>
The above table lists the operators in order of precedence (with operators of the same precedence grouped together). When you type in a complex expression like "1*2+3*4", UnrealScript automatically groups the operators by precedence. Since multiplication has a higher precedence than addition, the expression is evaluated as "(1*2)+(3*4)".
</P><P>
The "&amp;&amp;" (logical and) and "||" (logical or) operators are short-circuited: if the result of the expression can be determined solely from the first expression (for example, if the first argument of &amp;&amp; is false), the second expression is not evaluated.
</P><P>
Regarding forward and reverse vector transformations, revers &gt;&gt; transforms from local space to world space and forward &lt;&lt; transforms back again.
</P><P>
For example, if you have a vector facing 64 units ahead of a player, vect(64,0,0) is in local player-space. If you want it in world space, you have to transform it to world space using the player's rotation so you'd calculate it with the following:
</P><P>
</P><PRE>myWorldSpaceVect = my64Vect &gt;&gt; playerPawn.rotation;
</PRE>
<P>
You'd want to use the forward rotation in cases when you have a world-space vector and you want it in local player space. As an example, you might want to convert a car actor's world-space velocity to local space so you can grab the X (forward velocity) to print it to a HUD.
</P><P>
In addition to the standard operators, UnrealScript supports the following unary operators: 
</P><P> </P><UL>
<LI> ! (bool) Logical not. 
</LI> <LI> - (int, float) negation. 
</LI> <LI> ~ (int) bitwise negation. 
</LI> <LI> ++, -- Decrement (either before or after a variable).
</LI></UL> 
<P>
New operators are added to the engine from time to time.  For a complete list of operators, check the latest UnrealScript source - specifically the Object class.
</P><P>
</P><H3><A name="General purpose functions"></A> General purpose functions </H3>
<P>
</P><H4><A name="Creating objects"></A> Creating objects </H4>
<P>
In order to create a new object instance in UnrealScript, you'll use one of two functions depending on whether the object is an Actor or not.  For Actors, you must use the Spawn function, which is declared in Actor.uc.  For non Actor-derived classes, you must use the <CODE>new</CODE> operator.  The syntax for the new operator is unlike that of any other function.  In addition to an optional parameter list, you must specify the class of the new object and an optional template object.  There is no UnrealScript declaration for the new operator, but here's what the function signature would look like:
</P><PRE>native final operator function coerce Object new
(
   object   InOuter,
   name     InName,
   int      InFlags,
   class    InClass,
   object   InTemplate
);
</PRE> <DL>
<DT> InOuter</DT><DD> (optional) the object to assign as the <I>Outer</I> for the newly created object.  If not specified, the object's Outer will be set to a special package which exists only while the game is running, called the "transient package".
</DD> <DT> InName</DT><DD> (optional) the name to give the new object.  If not specified, the object will be given a unique name in the format ClassName_##, where ## is incremented each time an instance of this class is created.
</DD> <DT> InFlags</DT><DD> (optional, currently broken since object flags are now 64 bits) the object flags to use when creating the object.  The valid values are:  <UL>
<LI> 0x0000000100000000: Supports editor undo/redo. (RF_Transactional)
</LI> <LI> 0x0000000400000000: Can be referenced by external files. (RF_Public)
</LI> <LI> 0x0000400000000000: Cannot be saved to disk. (RF_Transient)
</LI> <LI> 0x0010000000000000: Don't load object on the game client. (RF_NotForClient)
</LI> <LI> 0x0020000000000000: Don't load object on the game server. (RF_NotForServer)
</LI> <LI> 0x0040000000000000: Don't load object in the editor. (RF_NotForEdit)
</LI> <LI> 0x0008000000000000: Keep object around for editing even if unreferenced. (RF_Standalone)
</LI></UL> 
</DD> <DT> InClass</DT><DD> the class to create an instance of
</DD> <DT> InTemplate</DT><DD> the object to use for initializing the new object's property values
</DD></DL> 
<P>
The actual syntax for the new operator is as follows:
</P><PRE>ObjectVar = new[(InOuter, InName, InFlags)] &lt;class'InClass'&gt;[(InTemplate)];
</PRE>
<P>
Create an object of class LightFunction:
</P><PRE>function CreateALight()
{
   local LightFunction NewObj;

   NewObj = new class'Engine.LightFunction';
}
</PRE>
<P>
Create a new LightFunction object named "NewLight", assigning this object as its Outer
</P><PRE>function CreateALight()
{
   local LightFunction NewObj;

   NewObj = new(Self,'NewLight') class'Engine.LightFunction';
}
</PRE>
<P>
Create an new LightFunction object named "NewLight" in the transient package, using the object assigned as the value of the LightFunctionTemplate variable for initializing the new object's properties:
</P><PRE>var LightFunction LightFunctionTemplate;

function CreateALight()
{
   local LightFunction NewObj;

   NewObj = new(None,'NewLight') class'Engine.LightFunction' (LightFunctionTemplate);
}

defaultproperties
{
   Begin Object Class=LightFunction Name=MyLightFunctionArchetype
   End Object
   LightFunctionTemplate=MyLightFunctionArchetype
}
</PRE>
<P>
</P><H4><A name="Integer functions"></A> Integer functions </H4>
<P> </P><UL>
<LI> int Rand( int Max ); Returns a random number from 0 to Max-1. 
</LI> <LI> int Min( int A, int B ); Returns the minimum of the two numbers. 
</LI> <LI> int Max( int A, int B ); Returns the maximum of the two numbers. 
</LI> <LI> int Clamp( int V, int A, int B ); Returns the first number clamped to the interval from  A to B.
</LI></UL> 
<P>
   Warning - Unlike the C or C++ equivalents, Min and Max work on integers. There is no warning for using them on floats - your numbers will just be silently rounded down! For floats, you need to use FMin and FMax.
</P><P>
</P><H4><A name="Floating point functions"></A> Floating point functions </H4>
<P> </P><UL>
<LI> float Abs( float A ); Returns the absolute value of the number. 
</LI> <LI> float Sin( float A ); Returns the sine of the number expressed in radius. 
</LI> <LI> float Cos( float A ); Returns the cosine of the number expressed in radians. 
</LI> <LI> float Tan( float A ); Returns the tangent of the number expressed in radians. 
</LI> <LI> float ASin( float A ); Returns the inverse sine of the number expressed in radius. 
</LI> <LI> float ACos( float A ); Returns the inverse cosine of the number expressed in radius. 
</LI> <LI> float Atan( float A ); Returns the inverse tangent of the number expressed in radians. 
</LI> <LI> float Exp( float A ); Returns the constant "e" raised to the power of A. 
</LI> <LI> float Loge( float A ); Returns the log (to the base "e") of A. 
</LI> <LI> float Sqrt( float A ); Returns the square root of A. 
</LI> <LI> float Square( float A ); Returns the square of A = A*A. 
</LI> <LI> float FRand(); Returns a random number from 0.0 to 1.0. 
</LI> <LI> float FMin( float A, float B ); Returns the minimum of two numbers. 
</LI> <LI> float FMax( float A, float B ); Returns the maximum of two numbers. 
</LI> <LI> float FClamp( float V, float A, float B ); Returns the first number clamped to the
</LI> <LI> interval from A to B. 
</LI> <LI> float Lerp( float A, float B, float Alpha ); Returns the linear interpolation between A and B. 
</LI> <LI> float Smerp( float Alpha, float A, float B ); Returns an Alpha-smooth nonlinear interpolation between A and B.
</LI> <LI> float Ceil ( float A ); Rounds up 
</LI> <LI> float Round ( float A ); Rounds normally
</LI></UL> 
<P>
</P><H4><A name="String functions"></A> String functions </H4>
<P> </P><UL>
<LI> int Len( coerce string S ); Returns the length of a string. 
</LI> <LI> int InStr( coerce string S, coerce string t); Returns the offset into the first string of the second string if it exists, or -1 if not. 
</LI> <LI> string Mid ( coerce string S, int i, optional int j ); Returns the middle part of the string S, starting and character i and including j characters (or all of them if j is not specified). 
</LI> <LI> string Left ( coerce string S, int i ); Returns the i leftmost characters of s. 
</LI> <LI> string Right ( coerce string] S, int i ); Returns the i rightmost characters of s. 
</LI> <LI> string Caps ( coerce string S ); Returns S converted to uppercase.
</LI> <LI> string Locs ( coerce string S); Returns the lowercase representation of S (v3323 and up)
</LI> <LI> string Chr ( int i ); Returns a character from the ASCII table
</LI> <LI> int Asc ( string S ); Returns the ASCII value of a character (only the first character from the string is used)
</LI> <LI> string Repl ( coerce string Src, coerce string Match, coerce string With, optional bool bCaseSensitive ); Replace <CODE>Match</CODE> with <CODE>With</CODE> in the source. (v3323 and up)
</LI> <LI> string Split(coerce string Text, coerce string SplitStr, optional bool bOmitSplitStr); Splits <CODE>Text</CODE> on the first occurrence of <CODE>SplitStr</CODE> and returns the remaining part of <CODE>Text</CODE>. If <CODE>bOmitSplitStr</CODE> is true, <CODE>SplitStr</CODE> will be omitted from the returned string.
</LI> <LI> array<STRING> SplitString( string Source, optional string Delimiter=",", optional bool bCullEmpty ); Wrapper for splitting a string into an array of strings using a single expression.
</STRING></LI> <LI> JoinArray(array<STRING> StringArray, out string out_Result, optional string delim = ",", optional bool bIgnoreBlanks = true); Create a single string from an array of strings, using the delimiter specified, optionally ignoring blank members. 
</STRING></LI> <LI> ParseStringIntoArray(string BaseString, out array<STRING> Pieces, string Delim, bool bCullEmpty); Breaks up a delimited string into elements of a string array.
</STRING></LI> <LI> A == B;  Comparison that returns true if both strings are the same (Case Sensitive).
</LI> <LI> A ~= B;  Comparison that returns true if both strings are the same (NOT Case Sensitive).
</LI> <LI> A != B;  Comparison that returns true if the strings are different (Case Sensitive).
</LI></UL> 
<P>
See <A href="http://udn.epicgames.com/Three/StringsInUnrealScript.html" class="twikiLink">Unreal Strings</A> for more information.
</P><P>
</P><H4><A name="Vector functions"></A> Vector functions </H4>
<P> </P><UL>
<LI> vector vect( float X, float Y, float Z ); Creates a new vector with the given components.
</LI> <LI> float VSize( vector A ); Returns the euclidean size of the vector (the square root of the sum of the components squared).
</LI> <LI> vector Normal( vector A ); Returns a vector of size 1.0, facing in the direction of the specified vector.
</LI> <LI> Invert ( out vector X, out vector Y, out vector Z ); Inverts a coordinate system specified by three axis vectors.
</LI> <LI> vector VRand ( ); Returns a uniformly distributed random vector.
</LI> <LI> vector MirrorVectorByNormal( vector Vect, vector Normal ); Mirrors a vector about a specified normal vector.
</LI></UL> 
<P>
<A name="TimerFunctions"></A>
</P><H4><A name="Timer functions"></A> Timer functions </H4>
<P>
Timer functions are only available to Actor subclasses.
</P><P>
You can create multiple timers with each a different rate. Each timer has a unique target function (defaults to <EM>Timer()</EM>).
</P><P> </P><UL>
<LI> function SetTimer(float inRate, optional bool inbLoop, optional Name inTimerFunc); Start a timer that is triggered after <EM>inRate</EM> seconds. If <EM>inbLoop</EM> is true the timer will loop. <EM>inTimerFunc</EM> defines the function to call, by default this is the function <EM>Timer()</EM>, this value is also used to identify to multiple timers.
</LI> <LI> ClearTimer(optional Name inTimerFunc); stops a running timer.
</LI> <LI> bool IsTimerActive(optional Name inTimerFunc); returns true if the given timer is active
</LI> <LI> float GetTimerCount(optional Name inTimerFunc); returns the counter value of the timer, e.g. the number of seconds since the last time the timer was executed. Returns -1 if the timer is not active.
</LI> <LI> float GetTimerRate(optional name TimerFuncName = 'Timer'); returns the rate of timer, <CODE>GetTimerRate('SomeTimer') - GetTimerCount('SomeTimer')</CODE> will return the remaining time for the timer.
</LI></UL> 
<P>
<A name="DebuggingFunctions"></A>
</P><H4><A name="Debugging functions"></A> Debugging functions </H4>
<P>
The following functions can aid you in debugging you code
</P><P> </P><UL>
<LI> LogEx( ELoggingSeverity Severity, name Category, coerce string Msg ); Log a message with a given severity and category. This function gives more control that the standard <EM>log()</EM> function. It allows you to filter log messages based on severity and category in runtime.
</LI> <LI> LogFatal( name Category, coerce string Msg ); shorthand for calling <EM>LogEx(LOG_FATAL, Category, Msg)</EM>
</LI> <LI> LogError( name Category, coerce string Msg );
</LI> <LI> function LogWarn( name Category, coerce string Msg );
</LI> <LI> LogInfo( name Category, coerce string Msg );
</LI> <LI> LogDebug( name Category, coerce string Msg );
</LI> <LI> LogTrace( name Category, coerce string Msg );
</LI></UL> 
<P>
Note that as of changelist 134102, the above logging functions are no longer available. They have been replaced by a logging macro, which is handled by the <A href="http://udn.epicgames.com/Three/UnrealScriptPreprocessor.html" class="twikiLink">UnrealScript Preprocessor</A>. 
</P><P> </P><UL>
<LI> ScriptTrace(); Dumps the current script call stack to the log file
</LI> <LI> Name GetFuncName(); Returns the current calling function's name
</LI> <LI> DumpStateStack(); Logs the current state stack
</LI></UL> 
<P>
</P><H3><A name="UnrealScript preprocessor"></A> UnrealScript preprocessor </H3>
<P>
For more details, see the <A href="http://udn.epicgames.com/Three/UnrealScriptPreprocessor.html" class="twikiLink">Unrealscript Preprocessor</A> page.
</P><P>
</P><H3><A name="UnrealScript tools and utilities"></A> UnrealScript tools and utilities </H3>
<P>
</P><H4><A name="Script Profiler"></A> Script Profiler </H4>
<P>
The <A href="http://udn.epicgames.com/Three/ScriptProfiler.html" class="twikiLink">Script Profiler</A> can help with understanding what areas of script execution are taking the most time.
</P><P>
</P><H4><A name="Script Debugger"></A> Script Debugger </H4>
<P>
See the Unreal <A href="https://udn.epicgames.com/Three/DebuggingTools" class="restricted">Debugging Tools</A> page for more information.
</P><P>
</P><H2><A name="Advanced Language Features"></A> Advanced Language Features </H2>
<P>
</P><H3><A name="Timers"></A> Timers </H3>
<P>
Timers are used as a mechanism for scheduling an event to occur, or reoccur, over time. In this manner, an Actor can set a timer to register itself with the game engine to have a <CODE>Timer()</CODE> function called either once, or recurring, after a set amount of time has passed.
</P><P>
UnrealScript timers are just implemented as an array of structs inside each Actor (an Actor can have multiple timers pending). The struct contains the amount of time remaining before the timer expires, the function to call on expiry, etc.
</P><P>
The game loop normally <A href="https://udn.epicgames.com/Three/ActorTicking" class="restricted">ticks</A> each Actor once per frame, and part of each Ator's <CODE>Tick()</CODE> function includes a call to <CODE>UpdateTimers()</CODE> which will check for any expired timers and call their appropriate UnrealScript function.
</P><P>
The granularity is limited to the frame delta time, but there are no hardware or OS resources required. All of this is implemented in C++ so you could safely update hundreds of UnrealScript timers without any cause for concern. Of course you wouldn't want them all expiring simultaneously or every frame because they execute (slow) script code when they're activated.
</P><P>
</P><H3><A name="States"></A> States </H3>
<P>
<A name="StateDeclaration"></A>
</P><H4><A name="Overview of States"></A> Overview of States </H4>
<P>
Historically, game programmers have been using the concept of states ever since games evolved past the "pong" phase. States (and what is known as "state machine programming") are a natural way of making complex object behaviour manageable. However, before UnrealScript, states have not been supported at the language level, requiring developers to create C/C++ "switch" statements based on the object's state. Such code was difficult to write and update.
</P><P>
UnrealScript supports states at the language level.
</P><P>
In UnrealScript, each actor in the world is always in one and only one state. Its state reflects the action it wants to perform. For example, moving brushes have several states like "StandOpenTimed" and "BumpOpenTimed". Pawns have several states such as "Dying", "Attacking", and "Wandering".
</P><P>
In UnrealScript, you can write functions and code that exist in a particular state. These functions are only called when the actor is in that state. For example, say you're writing a monster script, and you're contemplating how to handle the "SeePlayer" function. When you're wandering around, you want to attack the player you see. When you're already attacking the player, you want to continue on uninterrupted.
</P><P>
The easiest way to do this is by defining several states (Wandering and Attacking), and writing a different version of "Touch" in each state. UnrealScript supports this.
</P><P>
Before delving deeper into states, you need to understand that there are two major benefits to states, and one complication: 
</P><P> </P><UL>
<LI> Benefit: States provide a simple way to write state-specific functions, so that you can handle the same function in different ways, depending on what the actor is doing.
</LI></UL> 
<P> </P><UL>
<LI> Benefit: With a state, you can write special "state code", using the entire regular UnrealScript commands plus several special functions known as "latent functions". A latent function is a function that executes "slowly" (i.e. non-blocking), and may return after a certain amount of "game time" has passed. This enables you to perform time-based programming -- a major benefit which neither C, C++, nor Java offer. Namely, you can write code in the same way you conceptualize it; for example, you can write a script that says the equivalent of "open this door; pause 2 seconds; play this sound effect; open that door; release that monster and have it attack the player". You can do this with simple, linear code, and the Unreal engine takes care of the details of managing the time-based execution of the code.
</LI></UL> 
<P> </P><UL>
<LI> Complication: Now that you can have functions (like <EM>Touch</EM>) overridden in multiple states as well as in child classes, you have the burden of figuring out exactly which "Touch" function is going to be called in a specific situation. UnrealScript provides rules which clearly delineate this process, but it is something you must be aware of if you create complex hierarchies of classes and states.
</LI></UL> 
<P>
Here is an example of states from the TriggerLight script:
</P><P>
</P><PRE>// Trigger turns the light on.
state() TriggerTurnsOn
{
   function Trigger( actor Other, pawn EventInstigator )
   {
      Trigger = None;
      Direction = 1.0;
      Enable( 'Tick' );
   }
}
 
// Trigger turns the light off.
state() TriggerTurnsOff
{
   function Trigger( actor Other, pawn EventInstigator )
   {
      Trigger = None;
      Direction = -1.0;
      Enable( 'Tick' );
   }
}
</PRE>
<P>
Here you are declaring two different states (TriggerTurnsOn and TriggerTurnsOff), and you're writing a different version of the Trigger function in each state. Though you could pull off this implementation without states, using states makes the code far more modular and expandable: in UnrealScript, you can easily subclass an existing class, add new states, and add new functions. If you had tried to do this without states, the resulting code would be more difficult to expand later.
</P><P>
A state can be declared as editable, meaning that the user can set an actor's state in UnrealEd, or not. To declare an editable state, do the following:
</P><P>
</P><PRE>state() MyState
{
   //...
}
</PRE>
<P>
To declare a non-editable state, do this:
</P><P>
</P><PRE>state MyState
{
   //...
}
</PRE>
<P>
You can also specify the automatic, or initial state that an actor should be in by using the "auto" keyword. This causes all new actors to be placed in that state when they first are activated:
</P><P>
</P><PRE>auto state MyState
{
   //...
}
</PRE>
<P>
</P><H4><A name="State Labels and Latent Functions"></A> State Labels and Latent Functions </H4>
<P>
In addition to functions, a state can contain one or more labels followed by UnrealScript code. For example:
</P><P>
</P><PRE>auto state MyState
{
Begin:
   Log( "MyState has just begun!" );
   Sleep( 2.0 );
   Log( "MyState has finished sleeping" );
   goto('Begin');
}
</PRE>
<P>
The above state code prints the message <CODE>"MyState has just begun!"</CODE>, then it pauses for two seconds, then it prints the message <CODE>"MyState has finished sleeping"</CODE>. The interesting thing in this example is the call to the latent function "Sleep": this function call doesn't return immediately, but returns after a certain amount of game time elapses. Latent functions can only be called from within state code, and not from within functions. Latent functions let you manage complex chains of events that include the passage of time.
</P><P>
All state code begins with a label definition; in the above example the label is named "Begin". The label provides a convenient entry point into the state code. You can use any label name in state code, but the "Begin" label is special: it is the default starting point for code in that state. 
</P><P>
There are three main latent functions available to all actors: 
</P><P> </P><UL>
<LI> Sleep( float Seconds ) pauses the state execution for a certain amount of time, and then continues. 
</LI> <LI> FinishAnim() waits until the current animation sequence you're playing completes, and then continues. This function makes it easy to write animation-driven scripts, scripts whose execution is governed by mesh animations. For example, most of the AI scripts are animation-driven (as opposed to time-driven), because smooth animation is a key goal of the AI system.
</LI> <LI> FinishInterpolation() waits for the current InterpolationPoint movement to complete, and then continues.
</LI></UL> 
<P>
The Pawn class defines several important latent functions for actions such as navigating through the world and short-term movement. See the separate AI docs for descriptions of their usage.
</P><P>
Three native UnrealScript functions are particularly useful when writing state code: 
</P><P> </P><UL>
<LI> The "Goto('LabelName')" function (similar to the C/C++/Basic goto) within a state causes the state code to continue executing at the specified label. 
</LI> <LI> The special Goto('') command within a state causes the state code execution to stop. State code execution doesn't continue until you go to a new state, or go to a new label within the current state. 
</LI> <LI> The "GotoState" function causes the actor to go to a new state, and optionally continue at a specified label (if you don't specify a label, the default is the "Begin" label). You can call GotoState from within state code, and it goes to the destination immediately. You can also call GotoState from within any function in the actor, but that does not take effect immediately: it doesn't take effect until execution returns back to the state code.
</LI></UL> 
<P>
Here is an example of the state concepts discussed so far:
</P><P>
</P><PRE>// This is the automatic state to execute.
auto state Idle
{
   // When touched by another actor...
   function Touch( actor Other )
   {
      log( "I was touched, so I'm going to Attacking" );
      GotoState( 'Attacking' );
      Log( "I have gone to the Attacking state" );
   }
Begin:
   log( "I am idle..." );
   sleep( 10 );
   goto 'Begin';
}
 
// Attacking state.
state Attacking
{
Begin:
   Log( "I am executing the attacking state code" );
   //...
}
</PRE>
<P>
When you run this program and then go touch the actor, you will see:
</P><P>
</P><PRE>I am idle...
I am idle...
I am idle...
I was touched, so I'm going to Attacking
I have gone to the Attacking state
I am executing the attacking state code
</PRE>
<P>
Make sure you understand this important aspect of GotoState: When you call GotoState from within a function, it does not go to the destination immediately, rather it goes there once execution returns back to the state code.
</P><P>
</P><H4><A name="State inheritance and scoping rules"></A> State inheritance and scoping rules </H4>
<P>
In UnrealScript, when you subclass an existing class, your new class inherits all of the variables, functions and states from its parent class. This is well-understood.
</P><P>
However, the addition of the state abstraction to the UnrealScript programming model adds additional twists to the inheritance and scoping rules. The complete inheritance rules are: 
</P><P> </P><UL>
<LI> A new class inherits all of the variables from its parent class. 
</LI> <LI> A new class inherits all of its parent class's non-state functions. You can override any of those inherited non-state functions. You can add entirely new non-state functions.
</LI> <LI> A new class inherits all of its parent class's states, including the functions and labels within those states. You can override any of the inherited state functions, and you can override any of the inherited state labels, you can add new state functions, and you can add new state labels.
</LI></UL> 
<P>
Here is an example of all the overriding rules:
</P><P>
</P><PRE>// Here is an example parent class.
class MyParentClass extends Actor;
 
// A non-state function.
function MyInstanceFunction()
{
   log( "Executing MyInstanceFunction" );
}
 
// A state.
state MyState
{
   // A state function.
   function MyStateFunction()
   {
      Log( "Executing MyStateFunction" );
   }
// The "Begin" label.
Begin:
   Log("Beginning MyState");
}
 
// Here is an example child class.
class MyChildClass extends MyParentClass;
 
// Here I'm overriding a non-state function.
function MyInstanceFunction()
{
   Log( "Executing MyInstanceFunction in child class" );
}
 
// Here I'm redeclaring MyState so that I can override MyStateFunction.
state MyState
{
   // Here I'm overriding MyStateFunction.
   function MyStateFunction()
   {
      Log( "Executing MyStateFunction" );
   }
// Here I'm overriding the "Begin" label.
Begin:
   Log( "Beginning MyState in MyChildClass" );
}
</PRE>
<P>
When you have a function that is implemented globally, in one or more states, and in one or more parent classes, you need to understand which version of the function will be called in a given context. The scoping rules that resolve these complex situations are: 
</P><P> </P><UL>
<LI> If the object is in a state, and an implementation of the function exists somewhere in that state (either in the actor's class or in some parent class), the most-derived state version of the function is called.
</LI> <LI> Otherwise, the most-derived non-state version of the function is called.
</LI></UL> 
<P>
</P><H4><A name="Advanced state programming"></A> Advanced state programming </H4>
<P>
If a state doesn't override a state of the same name in the parent class, then you can optionally use the "extends" keyword to make the state expand on an existing state in the current class. This is useful, for example, in a situation where you have a group of similar states (such as MeleeAttacking and RangeAttacking) that have a lot of functionality in common. In this case you could declare a base Attacking state as follows:
</P><P>
</P><PRE>// Base Attacking state.
state Attacking
{
   // Stick base functions here...
} 
 
// Attacking up-close.
state MeleeAttacking extends Attacking
{
   // Stick specialized functions here...
} 
 
// Attacking from a distance.
state RangeAttacking extends Attacking
{
   // Stick specialized functions here...
} 
</PRE>
<P>
A state can optionally use the <CODE>ignores</CODE> specifier to ignore functions while in a state. The syntax for this is:
</P><P>
</P><PRE>// Declare a state.
state Retreating
{
   // Ignore the following messages...
   ignores Touch, UnTouch, MyFunction;
 
   // Stick functions here...
}
</PRE>
<P>
You can tell what specific state an actor is in from its "state" variable, a variable of type "name".
</P><P>
It is possible for an actor to be in "no state" by using <EM>GotoState('')</EM>. When an actor is in "no state", only its global (non-state) functions are called.
</P><P>
Whenever you use the <EM>GotoState</EM> command to set an actor's state, the engine can call two special notification functions, if you have defined them: <EM>EndState()</EM> and <EM>BeginState()</EM>. <EM>EndState</EM> is called in the current state immediately before the new state is begun, and <EM>BeginState</EM> is called immediately after the new state begins. These functions provide a convenient place to do any state-specific initialization and cleanup that your state may require.
</P><P>
<A name="StateStacking"></A>
</P><H5><A name="State Stacking"></A> State Stacking </H5>
<P>
With normal state changing you go from one state to the other without being able to return to the previous state as it was left. With state stacking this is possible. Calling the function <EM>PushState</EM> will change to a new state putting it on top of the stack. The current state will be frozen. When <EM>PopState</EM> is called the previous state will be restored and continue it's execution from the point where <EM>PushState</EM> was called.  <EM>PushState</EM> will act as a latent function when possible (only inside of state code), so code execution behavior is different if you call <EM>PushState</EM> from within a function.  Calling it from a function will not interrupt code execution (much like GotoState from within a function), whereas calling it from within state code will pause execution until the child state is popped (again, similar to GotoState from within state code).
</P><P>
A state can be put on the stack only once, trying to push the same state on the stack a second time will fail. <EM>PushState</EM> works just like <EM>GotoState</EM>, it takes the state name and an optional label for the state's entry point. The new state will receive an <EM>PushedState</EM> event, the current state receives a <EM>PausedState</EM> event. After calling <EM>PopState</EM> the current state receives a <EM>PoppedState</EM> event and the new state (the one that was next on the stack) will receive <EM>ContinuedState</EM>.
</P><P>
</P><PRE>state FirstState
{
   function Myfunction()
   {
      doSomething();
      PushState('SecondState');
      // this will be executed immediately since we're inside of a function (no latent functionality)
      JustPushedSecondState();
   }
   
Begin:
   doSomething();
   PushState('SecondState');
   // this will be executed once SecondState is popped since we're inside of a state code block (latent functionality)
   JustPoppedSecondState();
}

state SecondState
{
   event PushState()
   {
      // we got pushed, push back
      PopState();
   }
}
</PRE>
<P>
Using the function <EM>IsInState</EM> you will be able to check if a certain state is on the stack. This function only checks the name of the states and therefor can not be used to check on parent states. For example:
</P><P>
</P><PRE>state BaseState
{
   ...
}

state ExtendedState extends BaseState
{
   ...
}
</PRE>
<P>
If the active state is <CODE>ExtendedState</CODE> then <EM>IsInState('BaseState')</EM> will return false. Ofcourse calling <EM>IsInState('BaseState', true)</EM> will return true if <EM>BaseState</EM> is on the stack.
</P><P>
</P><P>
</P><H3><A name="Replication"></A> Replication </H3>
<P>
For more details on replication in UnrealScript, see the <A href="http://udn.epicgames.com/Three/NetworkingOverview.html#UnrealScript:%20the%20Replication%20Statement" target="_top">Networking Overview</A> page.
</P><P>
</P><H3><A name="Iteration (_ForEach)"></A> Iteration (ForEach) </H3>
<P>
UnrealScript's <CODE>foreach</CODE> command makes it easy to deal with large groups of actors, for example all of the actors in a level, or all of the actors within a certain distance of another actor. "foreach" works in conjunction with a special kind of function called an "iterator" function whose purpose is to iterate through a list of actors.
</P><P>
Here is a simple example of <CODE>foreach</CODE>:
</P><P>
</P><PRE>// Display a list of all lights in the level.
function Something()
{
   local actor A;
 
   // Go through all actors in the level.
   log( "Lights:" );
   foreach AllActors( class 'Actor', A )
   {
      if( A.LightType != LT_None )
         log( A );
   }
}
</PRE>
<P>
The first parameter in all <CODE>foreach</CODE> commands is a constant class, which specifies what kinds of actors to search. You can use this to limit the search to, for example, all Pawns only.
</P><P>
The second parameter in the <CODE>foreach</CODE> command is a variable that is assigned an actor for the duration of each iteration through the <CODE>foreach</CODE> loop.
</P><P>
Here are all of the iterator functions that work with "foreach".
</P><P> </P><UL>
<LI> <CODE>AllActors ( class&lt;actor&gt; BaseClass, out actor Actor, optional name MatchTag )</CODE><BR> Iterates through all actors in the level. If you specify an optional MatchTag, only includes actors that have a "Tag" variable matching the tag you specified.
</LI></UL> 
<P> </P><UL>
<LI> <CODE>DynamicActors( class&lt;actor&gt; BaseClass, out actor Actor )</CODE><BR> Iterates through all the actors that have been spawned since the level started, ignoring the ones placed in the level.
</LI></UL> 
<P> </P><UL>
<LI> <CODE>ChildActors( class&lt;actor&gt; BaseClass, out actor Actor )</CODE><BR> Iterates through all actors owned by this actor.
</LI></UL> 
<P> </P><UL>
<LI> <CODE>BasedActors( class&lt;actor&gt; BaseClass, out actor Actor )</CODE><BR> Iterates through all actors which use this actor as a base.
</LI></UL> 
<P> </P><UL>
<LI> <CODE>TouchingActors( class&lt;actor&gt; BaseClass, out actor Actor )</CODE><BR> Iterates through all actors which are touching (interpenetrating) this actor.
</LI></UL> 
<P> </P><UL>
<LI> <CODE>TraceActors( class&lt;actor&gt; BaseClass, out actor Actor, out vector HitLoc, out vector HitNorm, vector End, optional vector Start, optional vector Extent )</CODE><BR> Iterates through all actors which touch a line traced from the Start point to the End point, using a box of collision extent Extent. On each iteration, HitLoc is set to the hit location, and HitNorm is set to an outward-pointing hit normal.
</LI></UL> 
<P> </P><UL>
<LI> <CODE>OverlappingActors( class&lt;actor&gt; BaseClass, out actor Actor, float Radius, optional vector Loc, optional bool bIgnoreHidden )</CODE><BR> Iterates through all actors within a specified radius of the specified location (or if none is specified, this actor's location).
</LI></UL> 
<P> </P><UL>
<LI> <CODE>VisibleActors( class&lt;actor&gt; BaseClass, out actor Actor, optional float Radius, optional vector Loc )</CODE><BR> Iterates through a list of all actors who are visible to the specified location (or if no location is specified, this actor's location).
</LI></UL> 
<P> </P><UL>
<LI> <CODE>VisibleCollidingActors ( class&lt;actor&gt; BaseClass, out actor Actor, float Radius, optional vector Loc, optional bool bIgnoreHidden );</CODE><BR> returns all colliding (bCollideActors==true) actors within a certain radius for which a trace from Loc (which defaults to caller's Location) to that actor's Location does not hit the world. Much faster than <EM>AllActors()</EM> since it uses the collision hash.
</LI></UL> 
<P> </P><UL>
<LI> <CODE>CollidingActors ( class&lt;actor&gt; BaseClass, out actor Actor, float Radius, optional vector Loc );</CODE><BR> returns colliding (bCollideActors==true) actors within a certain radius. Much faster than <EM>AllActors()</EM> for reasonably small radii since it uses the collision hash
</LI></UL> 
<P>
<EM>Note</EM>: The iterator functions are all members of particular class so if you want to use an iterator from within a function in a non-Actor, you must have an actor variable and use the following syntax:
</P><P> </P><UL>
<LI> <CODE>foreach ActorVar.DynamicActors(class'Pawn', P)</CODE>
</LI></UL> 
<P>
So, from with an Interaction class, you could do:
</P><P> </P><UL>
<LI> <CODE>foreach ViewportOwner.Actor.DynamicActors(class'Pawn', P)</CODE>
</LI></UL> 
<P>
<EM>Note</EM>: Iterators now support dynamic arrays as well, which you can find in the <A href="http://udn.epicgames.com/Three/UnrealScriptReference.html#DynArrayIterator" class="twikiAnchorLink">Advanced Language Features</A> section.
</P><P>
</P><H3><A name="Function Calling Specifiers"></A> Function Calling Specifiers </H3>
<P>
In complex programming situations, you will often need to call a specific version of a function, rather than the one that's in the current scope. To deal with these cases, UnrealScript provides the following keywords: 
</P><P> </P><DL>
<DT> <B>Global</B></DT><DD> Calls the most-derived global (non-state) version of the function. 
</DD> <DT> <B>Super</B></DT><DD> Calls the corresponding version of the function in the parent class. The function called may either be a state or non-state function depending on context. 
</DD> <DT> <B>Super(classname)</B></DT><DD> Calls the corresponding version of the function residing in (or above) the specified class. The function called may either be a state or non-state function depending on context.
</DD></DL> 
<P>
It is not valid to combine multiple calling specifiers (i.e. <EM>Super(Actor).Global.Touch</EM>).
</P><P>
</P><P>
Here are some examples of calling specifiers:
</P><P>
</P><PRE>class MyClass extends Pawn;
 
function MyExample( actor Other )
{
   Super(Pawn).Touch( Other );
   Global.Touch( Other );
   Super.Touch( Other );
}
</PRE>
<P>
As an additional example, the BeginPlay() function is called when an actor is about to enter into gameplay. The BeginPlay() function is implemented in the Actor class and it contains some important functionality that needs to be executed. Now, say you want to override BeginPlay() in your new class MyClass, to add some new functionality. To do that safely, you need to call the version of BeginPlay() in the parent class:
</P><P>
</P><PRE>class MyClass extends Pawn;
 
function BeginPlay()
{
   // Call the version of BeginPlay in the parent class (important).
   Super.BeginPlay();
 
   // Now do custom BeginPlay stuff.
   //...
}
</PRE>
<P>
</P><H3><A name="Accessing static functions in a variable class"></A> Accessing static functions in a variable class </H3>
<P>
Static functions in a variable class may be called using the following syntax.
</P><P>
</P><PRE>var class C;
var class&lt;Pawn&gt; PC;

class'SkaarjTrooper'.static.SomeFunction(); // Call a static function
                                            // in a specific class.

PC.static.SomeFunction(); // Call a static function in a variable class.

class&lt;Pawn&gt;(C).static.SomeFunction(); // Call a static function in a
                                      //casted class expression.
</PRE>
<P>
</P><H3><A name="Default values of variables"></A> Default values of variables </H3>
<P>
</P><H4><A name="Accessing default values of variables"></A> Accessing default values of variables </H4>
<P>
UnrealEd enables level designers to edit the "default" variables of an object's class. When a new actor is spawned of the class, all of its variables are initialized to those defaults. Sometimes, it's useful to manually reset a variable to its default value. For example, when the player drops an inventory item, the inventory code needs to reset some of the actor's values to its defaults. In UnrealScript, you can access the default variables of a class with the "Default." keyword. For example:
</P><P>
</P><PRE>var() float Health, Stamina;
//...
 
// Reset some variables to their defaults.
function ResetToDefaults()
{
   // Reset health, and stamina.
   Health = Default.Health;
   Stamina = Default.Stamina;
}
</PRE>
<P>
</P><H4><A name="Accessing default values of variables through a class reference"></A> Accessing default values of variables through a class reference </H4>
<P>
If you have a class reference (a variable of <CODE>class</CODE> or <CODE>class&lt;classlimitor&gt;</CODE> type), you can access the default properties of the class it references, without having an object of that class. This syntax works with any expression that evaluates to class type.
</P><P>
</P><PRE>var class C;
var class&lt;Pawn&gt; PC;

Health = class'Spotlight'.default.LightBrightness; // Access the default value of
                                                   // LightBrightness in the Spotlight class. 

Health = PC.default.Health; // Access the default value of Health in
                            // a variable class identified by PC.

Health = class&lt;Pawn&gt;(C).default.Health; // Access the default value
                                        // of Health in a casted class
                                        // expression.
</PRE>
<P>
<A name="DefaultPropertiesParser"></A>
</P><H4><A name="Specifying default values using the defaultproperties block"></A> Specifying default values using the defaultproperties block </H4>
<P>
In addition to setting the default value for an Actor's properties using a property window in UnrealEd, you can also assign default values for member variables by placing special assignment expressions inside the class's defaultproperties block.
</P><P> </P><UL>
<LI> Statements are not allowed in the defaultproperties block, which the exception of dynamic array operations
</LI> <LI> Semi-colons can be placed at the end of each line, but are not required
</LI> <LI> Default values are inherited by child classes.  Values specified in child classes' defaultproperties override values specified in parent classes.
</LI></UL> 
<P>
</P><H5><A name="Syntax"></A> Syntax </H5>
The syntax of the defaultproperties block is slightly different from the standard unrealscript syntax:
<P> </P><UL>
<LI> Simple Types (Ints, Floats, Bools, Bytes): <UL>
<LI> VarName=Value
</LI></UL> 
</LI></UL> 
<P> </P><UL>
<LI> Static Array: <UL>
<LI> <CODE>ArrayProp(0)=Value1</CODE><BR>        <CODE>ArrayProp(1)=Value2</CODE><BR> <STRONG>OR</STRONG>
</LI> <LI> <CODE>ArrayProp[0]=Value1</CODE><BR>        <CODE>ArrayProp[1]=Value2</CODE>
</LI></UL> 
</LI></UL> 
<P> </P><UL>
<LI> Dynamic&nbsp;Arrays: <UL>
<LI> <CODE>ArrayProp=(Value1,Value2,Value3)</CODE><BR> <STRONG>OR</STRONG>
</LI> <LI> <CODE>ArrayProp(0)=Value1</CODE><BR>        <CODE>ArrayProp(1)=Value2</CODE><BR>        <CODE>ArrayProp(2)=Value3</CODE><BR> <STRONG>OR</STRONG>
</LI> <LI> <CODE>ArrayProp.Add(Value1)</CODE><BR>        <CODE>ArrayProp.Add(Value2)</CODE><BR>        <CODE>ArrayProp.Add(Value3)</CODE><BR>
</LI></UL> 
</LI></UL> 
<P> </P><UL>
<LI> Names <UL>
<LI> <CODE>NameProp='Value'</CODE><BR> <STRONG>OR</STRONG>
</LI> <LI> <CODE>NameProp=Value</CODE>
</LI></UL> 
</LI></UL> 
<P> </P><UL>
<LI> Objects <UL>
<LI> <CODE>ObjectProp=ObjectClass'ObjectName'</CODE>
</LI></UL> 
</LI></UL> 
<P> </P><UL>
<LI> Subobjects <UL>
<LI> <CODE>Begin Object Class=ObjectClass Name=ObjectName</CODE><BR>        <CODE>&nbsp;&nbsp;&nbsp;&nbsp;VarName=Value</CODE><BR>        <CODE>&nbsp;&nbsp;&nbsp;&nbsp;...</CODE><BR>        <CODE>End Object</CODE><BR>        <CODE>ObjectProperty=ObjectName</CODE>
</LI></UL> 
</LI></UL> 
<P> </P><UL>
<LI> Structs (including Vectors): <UL>
<LI> <CODE>StructProperty=(InnerStructPropertyA=Value1,InnerStructPropertyB=Value2)</CODE><BR> <STRONG>OR</STRONG>
</LI> <LI> <CODE>StructProperty={(      <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InnerStructPropertyA=Value1,      <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InnerStructPropertyB=Value2      <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)}</CODE>
</LI></UL> 
</LI></UL> 
<STRONG>NOTE:</STRONG> Some types require different syntax when used inside a struct default value. <UL>
<LI> Inline static arrays must be declared like so (Notice that brackets "[]" are used here for the array delimiter instead of parenthesis "()"):   <BR>&nbsp;&nbsp;&nbsp;&nbsp;<CODE>StructProperty=(StaticArray[0]=Value,StaticArrayProp[1]=Value)</CODE>
</LI> <LI> Inline dynamic arrays must be declared using the single line syntax:   <BR>&nbsp;&nbsp;&nbsp;&nbsp;<CODE>StructProperty=(DynamicArray=(Value,Value))</CODE> 
</LI> <LI> Inline name variables must be wrapped with quotes:   <BR>&nbsp;&nbsp;&nbsp;&nbsp;<CODE>StructProperty=(NameProperty="Value")</CODE>
</LI></UL> 
<P> </P><UL>
<LI> Dynamic Array Operations. These can be used to modify the contents of a dynamic array, which can be inherited by a parent. <UL>
<LI> <CODE>Array.Empty</CODE> - clears the whole array
</LI> <LI> <CODE>Array.Add(element)</CODE> - adds element to the end of the array
</LI> <LI> <CODE>Array.Remove(element)</CODE> - removes the element from the array, this will remove all occurences of the element
</LI> <LI> <CODE>Array.RemoveIndex(index)</CODE> - removes the element at the given index
</LI> <LI> <CODE>Array.Replace(elm1, elm2)</CODE> - replaces elm1 with elm2. All occurences will be replaced. A warning is produced with elm1 is not found.
</LI></UL> 
</LI></UL> 
<P>
</P><P>
Consider the following example (based on Actor.uc):
</P><PRE>defaultproperties
{
   // objects
   MessageClass=class'LocalMessage'

    // declare an inline subobject of class SpriteComponent named "Sprite"
   Begin Object Class=SpriteComponent Name=Sprite
       // values specified here override SpriteComponent's own defaultproperties
      Sprite=Texture2D'EngineResources.S_Actor'
      HiddenGame=true
   End Object
   //todo
   Components.Add(Sprite)

    // declare an inline subobject of class CylinderComponent named "CollisionCylinder"
   Begin Object Class=CylinderComponent Name=CollisionCylinder
       // values specified here override CylinderComponent's own defaultproperties
      CollisionRadius=10
      CollisionHeight=10
      AlwaysLoadOnClient=True
      AlwaysLoadOnServer=True
   End Object
   //todo
   Components.Add(CollisionCylinder)
   
   CollisionComponent=CollisionCylinder

    // floats (leading '+' and trailing 'f' characters are ignored)
   DrawScale=00001.000000
   Mass=+00100.000000
   NetPriority=00001.f

    // ints
   NetUpdateFrequency=100
    
    // enumerations
   Role=ROLE_Authority
   RemoteRole=ROLE_None
    
    // structs
   DrawScale3D=(X=1,Y=1,Z=1)
    
    // bools
   bJustTeleported=true
   bMovable=true
   bHiddenEdGroup=false
   bReplicateMovement=true
   
   // names
   InitialState=None
   
   // dynamic array (in this case, a dynamic class array)
   SupportedEvents(0)=class'SeqEvent_Touch'
   SupportedEvents(1)=class'SeqEvent_UnTouch'
   SupportedEvents(2)=class'SeqEvent_Destroyed'
   SupportedEvents(3)=class'SeqEvent_TakeDamage'
}
</PRE>
<P>
<A name="StructDefaults"></A>
</P><H3><A name="Struct Defaults"></A> Struct Defaults </H3>
<P>
When you declare a struct in UnrealScript, you can optionally specify default values for the struct's properties.  Anytime the struct is used in UnrealScript, it's members are initialized with these values.  The syntax is identical to the defaultproperties block for a class - the only exception is that you must name the block <STRONG>structdefaultproperties</STRONG>.  For example:
</P><PRE>struct LinearColor
{
   var() config float R, G, B, A;

   structdefaultproperties
   {
      A=1.f
   }
};
</PRE>
<P>
Anytime you declare a LinearColor variable in UnrealScript, the value of its <EM>A</EM> property will be set to 1.f.  Something else that is important to understand when using structdefaultproperties is that class defaults override struct defaults.  If you have a class member variable of type LinearColor, any value you assign to that member variable in the class defaultproperties will override the value in the struct's defaults.
</P><PRE>var LinearColor NormalColor, DarkColor;

defaultproperties
{
    NormalColor=(R=1.f,B=1.f,G=1.f)       // value of A will be 1.0f for this property
    DarkColor=(R=1.f,B=1.f,G=1.f,A=0.2f)  // value of A will be 0.2f for this property
}
</PRE>
<P>
<A name="DynArray"></A>
</P><H3><A name="Dynamic Arrays"></A> Dynamic Arrays </H3>
<P>
Previously, we covered Arrays, which were static. What that means is that the size (how many elements are in the array) is set at compile time and cannot be changed. Dynamic Arrays and Static Arrays share the following common characteristics :
</P><P> </P><UL>
<LI> constant seek time - the time code spends accessing any given element of the array is the same, regardless of how many elements are in the array
</LI> <LI> unlimited element type - you can have an array of anything - ints, vectors, Actors, etc. (with the exception that booleans are only valid for dynamic arrays)
</LI> <LI> access behavior - you can access any element with an index into the array, and conversely, attempting to access an element at an index that is outside the bounds of the array will throw an accessed none.
</LI></UL> 
<P>
Dynamic Arrays provide a way of having Static Array functionality with the ability to change the number of elements during run-time, in order to accommodate changing needs. In order use Dynamic Arrays, we need to know a few things.
</P><P>
The first is variable declaration. Declaring a dynamic array is much like declaring any other unrealscript variable (i.e. var/local <EM>type</EM>  <EM>varname</EM>).  For dynamic arrays, the type is specified with the <EM>array</EM> keyword, followed by the array type wrapped in angle brackets.  If the array type contains angle brackets as well (such as <EM>class&lt;Actor&gt;</EM>), you must place a space between the closing bracket of the type and the closing bracket of the array wrapper or the compiler resolves the double closing brackets as the <CODE>&gt;&gt;</CODE> operator. For example:<BR>
Declare a dynamic array of ints named IntList: <CODE><B>var array&lt;int&gt; IntList;</B></CODE><BR>Declare a dynamic array of type class&lt;PlayerController&gt; named Players: <CODE><B>var array&lt;class&lt;PlayerController&gt; &gt; Players;</B></CODE>
</P><P>
When script starts, IntList will start with 0 elements. There are methods supported by Dynamic Arrays that allow us to add elements to the array, take elements out, and increase or decrease the length of the array arbitrarily. The syntax for calling these methods is (using our IntList example): <CODE>IntList.MethodName()</CODE>. The following dynamic array methods are available:
</P><P> </P><UL>
<LI> Add(<STRONG>int</STRONG> <EM>Count</EM>): extends the length of the array by <EM>Count</EM>, identical to FArray::AddZeroed().
</LI> <LI> Insert(<STRONG>int</STRONG> <EM>Index</EM>, <STRONG>int</STRONG> <EM>Count</EM>): where <EM>Index</EM> is the array index to being inserting elements, and <EM>Count</EM> is the number of elements to insert. Any existing elements at that location in the array are shifted up, and new elements are created and inserted into the specified location. Inserting 5 elements at index 3 will shift up (in index value) all elements in the array starting at index 3 and up by 5.  The element previously located at index 3 will now be located at index 8, element 4 will now be element 9, and so on.  Newly added elements are all initialized to their default values (zero/null for all types except structs containing structdefaultproperties).
</LI> <LI> Remove(<STRONG>int</STRONG> <EM>Index</EM>, <STRONG>int</STRONG> <EM>Count</EM>): where <EM>Index</EM> is the array index to begin removing elements from, and <EM>Count</EM> is the number of elements to remove.  This allows us to remove a group of elements from the array starting at any valid index within the array. Note that any indexes that are higher than the range to be removed will have their index values changed, keep this in mind if you store index values into dynamic arrays.
</LI> <LI> AddItem(<EM>Item</EM>): adds <EM>Item</EM> to the end of the array, extending the array length by one.
</LI> <LI> RemoveItem(<EM>Item</EM>): removes any instances of <EM>Item</EM> using a linear search.
</LI> <LI> InsertItem(<STRONG>int</STRONG> <EM>Index</EM>, <EM>Item</EM>): inserts <EM>Item</EM> into the array at <EM>Index</EM>, extending the array length by one.
</LI> <LI> Find(...) - finds the index of an element in the array.  There are two versions of Find: standard find for matching entire element values, and a specialized version for matching a struct based on the value of a single property of the struct <UL>
<LI> Find(<EM>Value</EM>): where <EM>Value</EM> is the value to search for.  Returns the index for the first element found in the array which matches the value specified, or -1 if that value wasn't found in the array.  <EM>Value</EM> can be represented using any valid expression.
</LI> <LI> Find(<EM>PropertyName</EM>, <EM>Value</EM>): where <EM>PropertyName</EM> is the name of property in the struct to search against (must be of type 'Name'), and <EM>Value</EM> is the value to search for.  Returns the index for the first struct in the array that has a value matching the value specified for a property named <EM>PropertyName</EM>, or -1 if the value wasn't found.  <EM>Value</EM> can be any valid expression.
</LI></UL> 
</LI> <LI> Sort(<EM>SortDelegate</EM>) - uses <EM>SortDelegate</EM> to sort the contents of the array in-place.  <EM>SortDelegate</EM> should have signature matching the following:  <UL>
<LI> delegate int ExampleSort(ArrayType A, ArrayType B) { return A &lt; B ? -1 : 0; }  // a negative return value indicates the items should be swapped
</LI></UL> 
</LI></UL> 
<P>
</P><H4><A name="Length Variable"></A> Length Variable </H4>
Dynamic Arrays also have a variable called <CODE>Length</CODE>, which is the current length (number of elements) of the dynamic array. To access Length, using our example array, we would say: <CODE>IntList.Length</CODE> . We can not only read the Length variable, but we can also directly set it, allowing us to modify the number of elements in the array. When you modify the Length variable directly, all changes in array length happen at the 'end' of the array. For example, if we set IntList.Length = 5, and then we set IntList.Length = 10, the extra 5 elements we just added were added to the end of the array, maintaining our original 5 elements and their values. If we decreased the Length, the elements would be taken off the end as well. Note that when you add elements to the array, either by Insert() or by increasing Length, the elements are initialized to the variable type's default value (0 for ints, None for class references, etc). It is also noteworthy to know that you can increase the length of a dynamic array by setting an element index that is greater than the array's current Length value. This will extend the array just as if you had set Length to the larger value.
<P>
<CODE> 
OldLength = Array.length <BR>
Array.Length = OldLength + 1 <BR>
Array[OldLength] = NewValue <BR>
</CODE>
</P><P>
<CODE> 
Array[Array.Length] = NewValue <BR>
</CODE> 
</P><P>
<CODE> 
Array.AddItem(NewValue) <BR>
</CODE>
</P><P>
are all equivalent forms of the same operation.  
</P><P>
Note however that you cannot both increase the length of an array and access its members at the same time.
</P><P>
<CODE>
Array[Array.length].myStructVariable = newVal<BR>
</CODE>
</P><P>
does not work.
</P><P>
A word of caution - the Length member of a dynamic array should never be incremented / decremented by '++', '--', '+=', or '-=', nor should you pass Length to a function as an out parameter (where the function can change the value of it). Doing these things will result in memory leaks and crashes due to Length not being accurate any more; only setting the Length via the '=' operator (and setting an element at an index larger than Length) modifies the actual length of the dynamic array properly.
</P><P>
<B>NOTE: <CODE>array&lt;bool&gt;</CODE> is not a supported type!</B>
</P><P>
</P><P>
A final note - dynamic arrays are <STRONG>not</STRONG> replicated. You could get around this by having a function that replicates and has two arguments, an index into the dynamic array and the value to store there. However, you would also have to consider consequences of elements not being the same within a space of a tick on client and server.
</P><P>
<A name="DynArrayIterator"></A>
</P><H4><A name="Iterating Dynamic Arrays"></A> Iterating Dynamic Arrays </H4>
<P>
Dynamic arrays now support the 'foreach' operator to allow simple iterations.  The basic syntax is 'foreach ArrayVariable(out ArrayItem,optional out ItemIndex) {}', where each iteration will increment the index and write out the item as well as the index if a property is supplied.
</P><P>
</P><PRE>function IterateThroughArray(array&lt;string&gt; SomeArray)
{
    local string ArrayItem;
    local int Index;
    foreach SomeArray(ArrayItem)
    {
       `log("Array iterator test #1:"@ArrayItem);
    }
    foreach SomeArray(ArrayItem,Index)
    {
        `log("Array iterator test #2:"@ArrayItem@Index);
    }
}
</PRE>
<P>
</P><H3><A name="Interface Classes"></A> Interface Classes </H3>
<P>
For more information on Interfaces, see the <A href="http://udn.epicgames.com/Three/UnrealScriptInterfaces.html" class="twikiLink">UnrealScript Interfaces</A> page.
</P><P>
</P><H3><A name="Function Delegates"></A> Function Delegates </H3>
<P>
For more information on how to use Delegates, see the <A href="http://udn.epicgames.com/Three/UnrealScriptDelegates.html" class="twikiLink">UnrealScript Delegates</A> page.
</P><P>
</P><H3><A name="Native Classes"></A> Native Classes </H3>
<P>
For more information on native classes, see the <A href="https://udn.epicgames.com/Three/CompilingNativeClasses" class="restricted">Compiling Native Classes</A> and <A href="https://udn.epicgames.com/Three/CreatingNativeClasses" class="restricted">Creating Native Classes</A> pages.
</P><P>
</P><P>
<A name="UnrealScriptMetadata"></A>
</P><H3><A name="MetaData Support"></A> MetaData Support </H3>
<P>
In-game and in-editor functionality can be extended via property meta-data. 
</P><P>
</P><H4><A name="Metadata Overview"></A> Metadata Overview </H4>
<P>
Arbitrary metadata can be linked to a property in UnrealScript as follows:
</P><P>
<STRONG>For a variable:</STRONG>
</P><P>
</P><PRE>var float MyVar&lt;TAG=VALUE&gt;
</PRE>
<P>
<STRONG>For an enum:</STRONG>
</P><P>
</P><PRE>enum EMyEnum
{
   EME_ValA&lt;TAG=VALUE&gt;,
   EME_ValB&lt;TAG=VALUE&gt;,
};
</PRE>
<P>
<STRONG>For a class:</STRONG>
</P><P>
See the following UnProg3 mailing list thread: <A href="https://udn.epicgames.com/lists/showpost/php?id=24834&list=unprog3" class="restricted" target="_top">https://udn.epicgames.com/lists/showpost.php?id=24834&amp;list=unprog3</A>
</P><P>
</P><H4><A name="Using Multiple _MetaData Specifications"></A> Using Multiple MetaData Specifications </H4>
<P>
You can use multiple metadata specifications for the same property by separating them by a <STRONG>|</STRONG> character. 
</P><P>
For example:
</P><PRE>var()   LinearColor    DrawColor&lt;DisplayName=Draw Color|EditCondition=bOverrideDrawColor&gt;;
</PRE>
<P>
</P><H4><A name="Available _MetaData Specifications"></A> Available MetaData Specifications </H4>
<P>
Here are the currently supported metadata tags and what they do:
</P><P>
<STRONG>&lt;ToolTip=TEXT_STRING&gt;</STRONG> 
</P><P>
Makes <CODE>TEXT_STRING</CODE> appear as the tooltip when the mouse is placed over the corresponding property in an editor property window. 
</P><P>
NOTE: Support was recently added so that <CODE>/** VALUE */</CODE> comments are automatically translated into ToolTip metadata by the script compiler.
</P><P>
</P><P>
<STRONG>&lt;DisplayName=TEXT_STRING&gt;</STRONG>
</P><P>
Makes a propertys name appear as <CODE>TEXT_STRING</CODE> in the editor property window instead of its actual name.
</P><P>
Example:
</P><P>
</P><PRE>Var() bool bEnableSpawning&lt;DisplayName=Spawning Enabled&gt;;
</PRE>
<P>
<STRONG>WARNING</STRONG>: <EM>The use of DisplayName in enums will cause problems if you modify UPropertyInputCombo to sort enums in editor combo boxes.</EM> 
</P><P>
See the following UnProg3 mailing list thread: <A href="https://udn.epicgames.com/lists/showpost/php?list=unprog3&id=24302" class="restricted" target="_top">https://udn.epicgames.com/lists/showpost.php?list=unprog3&amp;id=24302</A>
</P><P>
</P><P>
<STRONG>&lt;EditCondition=ConditionalPropertyName&gt;</STRONG>
</P><P>
This allows you to make the editability status of an editor property be enabled or disabled based on the value of another (Boolean) property. 
</P><P>
For example, you could have the following setup in the MyPackage.MyClass UnrealScript class:
</P><P>
</P><PRE>/** Enable or disable spawning */
Var() bool bEnableSpawning;

/** Set the rate at which AIs are spawned. Has no effect unless bEnableSpawning = TRUE */
Var() float RespawnsPerSecond&lt;EditCondition=bEnableSpawning&gt;;
</PRE>
<P>
And then RespawnsPerSecond would be greyed-out in the editor whenever bEnableSpawning is false. This helps make things less confusing for designers.
</P><P>
<STRONG>Important</STRONG>: This metadata setting requires that the controlled variable (RespawnsPerSecond) utilize a custom property item binding (WxCustomPropertyItem_ConditionalItem). 
</P><P>
In order to enable this, you need to hook it up in <GAME>Editor.ini, as follows:
</GAME></P><P>
</P><PRE>[UnrealEd.CustomPropertyItemBindings]
CustomPropertyClasses=(PropertyPathName=" MyPackage.MyClass: RespawnsPerSecond ",PropertyItemClassName="WxCustomPropertyItem_ConditionalItem")
</PRE>
<P>
For more info on this, see <A href="https://udn.epicgames.com/lists/showpost/php?list=unprog3&id=30824" class="restricted" target="_top">https://udn.epicgames.com/lists/showpost.php?list=unprog3&amp;id=30824</A>
</P><P>
</P><P>
<STRONG>&lt;FriendlyName=TEXT_STRING&gt;</STRONG>
</P><P>
NOT SURE IF THIS IS ONLY USED INTERNALLY AND NOT INTENDED FOR USE IN UNREALSCRIPT. PERHAPS EPIC CAN CLARIFY? 
</P><P>
</P><P>
<STRONG>&lt;AllowAbstract&gt;</STRONG>
</P><P>
If present on a Class property, editor drop-down boxes for editing that property will include abstract classes. If not present, they will only contain concrete classes. There is no need to specify a value such as True or False in this metadata specification.
</P><P>
</P><P>
<STRONG>&lt;AutoComment=BOOLEAN_VALUE&gt;</STRONG>
</P><P>
When added to a property of a Kismet Sequence Action, the property and its current value will automatically appear as a comment above that action. To see this in action place a new "Gate" sequence action in a script. In this class both bOpen and AutoCloseCount use this metadata option.
</P><P>
</P><P>
</P><H2><A name="Advanced Technical Issues"></A> Advanced Technical Issues </H2>
<P>
</P><H3><A name="UnrealScript Implementation"></A> UnrealScript Implementation </H3>
<P>
For more detailed information on how UnrealScript works under the covers - from the <A href="https://udn.epicgames.com/Three/UnrealScriptCompileProcess" class="restricted">Compile Process</A> to <A href="https://udn.epicgames.com/Three/UnrealScriptExecution" class="restricted">Execution</A> to <A href="https://udn.epicgames.com/Three/UnrealScriptByteCode" class="restricted">Byte Code</A> representaiton - see the <A href="https://udn.epicgames.com/Three/UnrealScriptImplementation" class="restricted">UnrealScript Implementation</A> page.
</P><P>
</P><H3><A name="UnrealScript binary compatibility issues"></A> UnrealScript binary compatibility issues </H3>
<P>
UnrealScript is designed so that classes in package files may evolve over time without breaking binary compatibility.  Here, binary compatibility means "dependent binary files may be loaded and linked without error"; whether your modified code functions as designed is a separate issue.  Specifically, the kinds of modifications when may be made safely are as follows: 
</P><P> </P><UL>
<LI> The .uc script files in a package may be recompiled without breaking binary compatibility.
</LI> <LI> Adding new classes to a package.
</LI> <LI> Adding new functions to a class.
</LI> <LI> Adding new states to a class.
</LI> <LI> Adding new variables to a class.
</LI> <LI> Removing private variables from a class.
</LI></UL> 
<P>
Other transformations are generally unsafe, including (but not limited to): 
</P><P> </P><UL>
<LI> Adding new members to a struct.
</LI> <LI> Removing a class from a package.
</LI> <LI> Changing the type of any variable, function parameter, or return value.
</LI> <LI> Changing the number of parameters in a function.
</LI></UL> 
<P>
</P><H3><A name="Technical notes"></A> Technical notes </H3>
<P>
   <STRONG>Garbage&nbsp;collection</STRONG>. All objects and actors in Unreal are garbage-collected using a tree-following garbage collector similar to that of the Java VM. The Unreal garbage collector uses the UObject class's serialization functionality to recursively determine which other objects are referenced by each active object. As a result, object need not be explicitly deleted, because the garbage collector will eventually hunt them down when they become unreferenced. This approach has the side-effect of latent deletion of unreferenced objects; however it is far more efficient than reference counting in the case of infrequent deletion. See the <A href="https://udn.epicgames.com/Three/GarbageCollection" class="restricted">Garbage Collection</A> page for more details.
</P><P>
   <STRONG>UnrealScript&nbsp;is&nbsp;bytecode&nbsp;based</STRONG>. UnrealScript code is compiled into a series of bytecodes similar to p-code or the Java bytecodes. This makes UnrealScript platform-neutral; this porting the client and server components of Unreal to other platforms, i.e. the Macintosh or Unix, is straightforward, and all versions can interoperate easily by executing the same scripts.
</P><P>
   <STRONG>Unreal&nbsp;as&nbsp;a&nbsp;Virtual&nbsp;Machine</STRONG>. The Unreal engine can be regarded as a virtual machine for 3D gaming in the same way that the Java language and the built-in Java class hierarchy define a virtual machine for Web page scripting. The Unreal virtual machine is inherently portable (due to splitting out all platform-dependent code in separate modules) and expandable (due to the expandable class hierarchy). However, at this time, there are no plans to document the Unreal VM to the extent necessary for others to create independent but compatible implementations.
</P><P>
   <STRONG>The&nbsp;UnrealScript&nbsp;compiler&nbsp;is&nbsp;three-pass</STRONG>. Unlike C++, UnrealScript is compiled in three distinct passes. In the first pass, variable, struct, enum, const, state and function declarations are parsed and remembered; the skeleton of each class is built.  In the second pass, the script code is compiled to byte codes. This enables complex script hierarchies with circular dependencies to be completely compiled and linked in two passes, without a separate link phase.  The third phase parses and imports default properties for the class using the values specified in the <CODE>defaultproperties</CODE> block in the .uc file.
</P><P>
   <STRONG>Persistent&nbsp;actor&nbsp;state</STRONG>. It is important to note that in Unreal, because the user can save the game at any time, the state of all actors, including their script execution state, can be saved only at times when all actors are at their lowest possible UnrealScript stack level. This persistence requirement is the reason behind the limitation that latent functions may only be called from state code: state code executes at the lowest possible stack level, and thus can be serialized easily. Function code may exist at any stack level, and could have (for example) C++ native functions below it on the stack, which is clearly not a situation which one could save on disk and later restore.
</P><P>
   <STRONG>Unrealfiles are Unreal's native binary file format</STRONG>. Unrealfiles contain an index, serialized dump of the objects in a particular Unreal package. Unrealfiles are similar to DLL's, in that they can contain references to other objects stored in other Unrealfiles. This approach makes it possible to distribute Unreal content in predefined "packages" on the Internet, in order to reduce download time (by never downloading a particular package more than once).
</P><P>
   <STRONG>Why&nbsp;UnrealScript&nbsp;does&nbsp;not&nbsp;support&nbsp;static&nbsp;variables</STRONG>. While C++ supports static (per class-process) variables for good reasons true to the language's low-level roots, and Java support static variables for reasons that appear to be not well thought out, such variables do not have a place in UnrealScript because of ambiguities over their scope with respect to serialization, derivation, and multiple levels: should static variables have "global" semantics, meaning that all static variables in all active Unreal levels have the same value? Should they be per package? Should they be per level? If so, how are they serialized -- with the class in its .u file, or with the level in its .unr file? Are they unique per base class, or do derived versions of classes have their own values of static variables? In UnrealScript, we sidestep the problem by not defining static variables as a language feature, and leaving it up to programmers to manage static-like and global-like variables by creating classes to contain them and exposing them in actual objects. If you want to have variables that are accessible per-level, you can create a new class to contain those variables and assure they are serialized with the level. This way, there is no ambiguity. For examples of classes that serve this kind of purpose, see LevelInfo and GameInfo.
</P><P>
</P><H3><A name="UnrealScript programming strategy"></A> UnrealScript programming strategy </H3>
<P>
Here I want to cover a few topics on how to write UnrealScript code effectively, and take advantage of UnrealScript's strengths while avoiding the pitfalls. 
</P><P>
   <STRONG>UnrealScript is a slow language compared to C/C++</STRONG>. A typical C++ program runs about 20X faster than UnrealScript. The programming philosophy behind all of our own script writing is this: Write scripts that are almost always idle. In other words, use UnrealScript only to handle the "interesting" events that you want to customize, not the rote tasks, like basic movement, which Unreal's physics code can handle for you. For example, when writing a projectile script, you typically write a HitWall(), Bounce(), and Touch() function describing what to do when key events happen. Thus 95% of the time, your projectile script isn't executing any code, and is just waiting for the physics code to notify it of an event. This is inherently very efficient. In our typical level, even though UnrealScript is comparably much slower than C++, UnrealScript execution time averages 5-10% of CPU time.
</P><P>
   <STRONG>Exploit latent functions (like FinishAnim and Sleep) as much as possible</STRONG>. By basing the flow of your script execution on them, you are creating animation-driven or time-driven code, which is fairly efficient in UnrealScript. 
</P><P>
   <STRONG>Keep an eye on the Unreal log while you're testing your scripts</STRONG>. The UnrealScript runtime often generates useful warnings in the log that notify you of nonfatal problems that are occuring. 
</P><P>
   <STRONG>Be wary of code that can cause infinite recursion</STRONG>. For example, the "Move" command moves the actor and calls your Bump() function if you hit something. Therefore, if you use a Move command within a Bump function, you run the risk of recursing forever. Be careful. Infinite recursion and infinite looping are the two error conditions which UnrealScript doesn't handle gracefully. 
</P><P>
   <STRONG>Spawning and destroying actors are fairly expensive operations on the server side, and are even more expensive in network games, because spawns and destroys take up network bandwidth</STRONG>. Use them reasonably, and regard actors as "heavy weight" objects. For example, do not try to create a particle system by spawning 100 unique actors and sending them off on different trajectories using the physics code. That will be sloooow. 
</P><P>
   <STRONG>Exploit UnrealScript's object-oriented capabilities as much as possible</STRONG>. Creating new functionality by overriding existing functions and states leads to clean code that is easy to modify and easy to integrate with other peoples' work. Avoid using traditional C techniques, like doing a switch() statement based on the class of an actor or the state, because code like this tends to break as you add new classes and modify things.
</P><P>
   <STRONG>UnrealScript .u packages are compiled strictly in the order specified by the .ini file's EditPackages list</STRONG>, so each package can only reference other objects in itself and in previously-compiled packages, and never in subsequently-compiled packages.   If you find that a need for circular references between packages arises, the two solutions are:  </P><OL>
 <LI>
 <OL>
<LI> Factor the classes into a set of base classes compiled in the first .u package, and a set of child classes compiled in the second .u package, making sure that the base classes never reference the child classes.  This is a good programming practice anyway, and it usually works.<BR>Note that if a given class C needs to reference a class or object O in a later-compiled package, you can often factor that class into two parts: an abstract base class definition C that defines a variable MyO in the first package (but doesn't contain a default value for MyO in its default properties), and a subclass D in the second package that specifies the proper default value for MyO which can only be done from within that second package.
</LI> <LI> If the two .u packages are inextricably intertwined by references, then merge them into a single package.  This is reasonable because packages are intended as a unit of code modularity, and there's not a real benefit (such as memory savings) to separating these inseparable sets of classes into multiple packages.
</LI></OL> 
</LI></OL> 
<P>
</P></DIV></DIV><DIV id="footer"><TABLE style="BACKGROUND-COLOR: transparent" cellpadding="0" cellspacing="0" border="0" width="100%"><TBODY><TR><TD align="left" style="BACKGROUND-COLOR: transparent"><A href="http://www.videogamevoters.org/"><IMG src="./UDN - Three - UnrealScriptReference_files/vgvn.jpg" border="0" width="234" height="60" alt="Video Game Voters Network"></A></TD><TD style="BACKGROUND-COLOR: transparent" align="right" valign="bottom">Copyright  2001-2009 <A href="http://www.epicgames.com/" target="_top">Epic Games, Inc.</A><BR><A href="http://udn.epicgames.com/Main/TermsAndConditions.html" class="twikiLink">Terms and Conditions</A></TD></TR></TBODY></TABLE></DIV></DIV>
<P>

</P></BODY></HTML>